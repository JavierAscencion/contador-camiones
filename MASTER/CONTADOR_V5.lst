CCS PCH C Compiler, Version 5.025, 24934               05-may.-22 10:04

               Filename:   D:\PROYECTOS\TRANSPORTE\ENCAPSULADO NUEVO\Contadores_V5.02\MASTER\CONTADOR_V5.lst

               ROM used:   12762 bytes (39%)
                           Largest free fragment is 20002
               RAM used:   392 (26%) at main() level
                           418 (27%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2976
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0200
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00DA
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   018E
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... //2021/05/13 *V5.01 Se recalcula frecuencia de IR 
.................... //2020/03/31 *V4.A1 Se agrega etiqueta para identificar por LCD si hay comunicacion entre los postes 
.................... //2020/02/28 *V04.A Se modifica codigo para evitar que postes cuenten solos 
.................... //2019/12/09 Se modifica la forma de contar con sensores bloqueados 
.................... //2019/11/19 Se modifica codigo para detectar una recepcion serial de dato poste posterior erronea, asi como identificar error de conexion tambien, 
.................... //           Se quita funcion de boton silenciador que nunca se uso 
.................... //2019/11/14 Se modifica la escucha de la cuenta del poste secundario, se cambia limite a 20 para dato posterior recibido. 
.................... //D01.2 2019/03/28 Se agrega cambios para confirmar reset a nuevo GSM y enter al final de envio de cuenta 
.................... //                 Se discriminan los primneros 2 caracteres de validacion serial 
.................... // ultima modificacion; 
.................... /* 
.................... VER.  FECHA 
.................... D02.6 2019/12/09 Cambia la forma de contar 
.................... - Poste de datos esta identificado como 1, el esclavo como 2 
.................... */ 
....................  
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 28,0C
00D8:  DATA 01,06
*
026E:  DATA 42,4F
0270:  DATA 52,52
0272:  DATA 41,52
0274:  DATA 5F,41
0276:  DATA 4C,4C
0278:  DATA 0D,00
027A:  DATA 0C,42
027C:  DATA 4F,52
027E:  DATA 52,41
0280:  DATA 52,5F
0282:  DATA 41,4C
0284:  DATA 4C,00
0286:  DATA 42,4F
0288:  DATA 52,52
028A:  DATA 41,52
028C:  DATA 5F,41
028E:  DATA 4C,4C
0290:  DATA 0D,00
0292:  DATA 52,45
0294:  DATA 53,45
0296:  DATA 54,5F
0298:  DATA 4F,4B
029A:  DATA 0D,0A
029C:  DATA 00,00
029E:  DATA 42,4F
02A0:  DATA 52,52
02A2:  DATA 41,52
02A4:  DATA 5F,41
02A6:  DATA 4C,4C
02A8:  DATA 0D,00
02AA:  DATA 43,32
02AC:  DATA 4F,4B
02AE:  DATA 00,00
02B0:  DATA 43,31
02B2:  DATA 4F,4B
02B4:  DATA 00,00
02B6:  DATA 53,45
02B8:  DATA 52,49
02BA:  DATA 41,4C
02BC:  DATA 5F,54
02BE:  DATA 4F,4B
02C0:  DATA 0D,00
02C2:  DATA 43,32
02C4:  DATA 4F,4B
02C6:  DATA 00,00
02C8:  DATA 53,75
02CA:  DATA 62,32
02CC:  DATA 00,00
02CE:  DATA 20,20
02D0:  DATA 20,20
02D2:  DATA 00,00
02D4:  DATA 20,20
02D6:  DATA 20,20
02D8:  DATA 00,00
02DA:  DATA 20,20
02DC:  DATA 20,20
02DE:  DATA 00,00
02E0:  DATA 42,4C
02E2:  DATA 00,00
02E4:  DATA 42,4C
02E6:  DATA 00,00
02E8:  DATA 42,4C
02EA:  DATA 00,00
02EC:  DATA 20,20
02EE:  DATA 00,00
02F0:  DATA 53,4F
02F2:  DATA 4C,49
02F4:  DATA 43,49
02F6:  DATA 54,41
02F8:  DATA 44,4F
02FA:  DATA 0D,00
02FC:  DATA 50,41
02FE:  DATA 53,41
0300:  DATA 4A,45
0302:  DATA 52,4F
0304:  DATA 53,3A
0306:  DATA 0D,00
0308:  DATA 41,43
030A:  DATA 43,2B
030C:  DATA 30,31
030E:  DATA 3A,25
0310:  DATA 30,34
0312:  DATA 4C,75
0314:  DATA 2C,25
0316:  DATA 30,34
0318:  DATA 4C,75
031A:  DATA 2C,25
031C:  DATA 30,34
031E:  DATA 4C,75
0320:  DATA 2C,25
0322:  DATA 30,33
0324:  DATA 4C,75
0326:  DATA 2C,25
0328:  DATA 30,33
032A:  DATA 4C,75
032C:  DATA 2C,25
032E:  DATA 30,32
0330:  DATA 75,2C
0332:  DATA 0D,0A
0334:  DATA 00,00
0336:  DATA 41,43
0338:  DATA 43,2B
033A:  DATA 30,31
033C:  DATA 3A,25
033E:  DATA 30,34
0340:  DATA 4C,75
0342:  DATA 2C,25
0344:  DATA 30,34
0346:  DATA 4C,75
0348:  DATA 2C,44
034A:  DATA 45,53
034C:  DATA 43,2C
034E:  DATA 25,30
0350:  DATA 33,4C
0352:  DATA 75,2C
0354:  DATA 30,30
0356:  DATA 30,2C
0358:  DATA 25,30
035A:  DATA 32,75
035C:  DATA 2C,0D
035E:  DATA 0A,00
0360:  DATA 44,45
0362:  DATA 53,43
0364:  DATA 00,00
0366:  DATA 0C,00
0368:  DATA 20,00
036A:  DATA 20,00
036C:  DATA 20,00
036E:  DATA 20,00
0370:  DATA 20,00
0372:  DATA 20,00
0374:  DATA 20,00
0376:  DATA 20,00
0378:  DATA 20,00
037A:  DATA 20,00
037C:  DATA 20,00
037E:  DATA 20,00
0380:  DATA 6D,65
0382:  DATA 6D,6F
0384:  DATA 72,79
0386:  DATA 3A,25
0388:  DATA 73,0D
038A:  DATA 00,00
038C:  DATA 53,31
038E:  DATA 3A,25
0390:  DATA 4C,64
0392:  DATA 20,00
0394:  DATA 42,31
0396:  DATA 3A,25
0398:  DATA 4C,64
039A:  DATA 20,00
039C:  DATA 53,32
039E:  DATA 3A,25
03A0:  DATA 4C,64
03A2:  DATA 20,00
03A4:  DATA 42,32
03A6:  DATA 3A,25
03A8:  DATA 4C,64
03AA:  DATA 20,00
03AC:  DATA 53,31
03AE:  DATA 3A,20
03B0:  DATA 20,20
03B2:  DATA 20,00
03B4:  DATA 42,31
03B6:  DATA 3A,20
03B8:  DATA 20,20
03BA:  DATA 20,00
03BC:  DATA 53,32
03BE:  DATA 3A,25
03C0:  DATA 4C,64
03C2:  DATA 20,00
03C4:  DATA 42,32
03C6:  DATA 3A,25
03C8:  DATA 4C,64
03CA:  DATA 20,00
03CC:  DATA 53,45
03CE:  DATA 52,49
03D0:  DATA 41,4C
03D2:  DATA 54,45
03D4:  DATA 53,54
03D6:  DATA 0D,0A
03D8:  DATA 00,00
03DA:  DATA 43,3D
03DC:  DATA 35,00
*
08F4:  TBLRD*+
08F6:  MOVFF  FF6,18A
08FA:  MOVFF  FF7,18B
08FE:  MOVFF  FF5,192
0902:  RCALL  0894
0904:  MOVFF  18A,FF6
0908:  MOVFF  18B,FF7
090C:  MOVLB  1
090E:  DECFSZ x89,F
0910:  BRA    0914
0912:  BRA    0918
0914:  MOVLB  0
0916:  BRA    08F4
0918:  MOVLB  0
091A:  RETURN 0
091C:  MOVFF  FEA,191
0920:  MOVFF  FE9,190
0924:  MOVLB  1
0926:  BTFSS  x8A.7
0928:  BRA    093A
092A:  BSF    x90.7
092C:  BTFSS  x90.4
092E:  INCF   x90,F
0930:  COMF   x89,F
0932:  COMF   x8A,F
0934:  INCF   x89,F
0936:  BTFSC  FD8.2
0938:  INCF   x8A,F
093A:  SWAPF  x8A,W
093C:  IORLW  F0
093E:  MOVWF  x8C
0940:  ADDWF  x8C,F
0942:  ADDLW  E2
0944:  MOVWF  x8D
0946:  ADDLW  32
0948:  MOVWF  x8F
094A:  MOVF   x8A,W
094C:  ANDLW  0F
094E:  ADDWF  x8D,F
0950:  ADDWF  x8D,F
0952:  ADDWF  x8F,F
0954:  ADDLW  E9
0956:  MOVWF  x8E
0958:  ADDWF  x8E,F
095A:  ADDWF  x8E,F
095C:  SWAPF  x89,W
095E:  ANDLW  0F
0960:  ADDWF  x8E,F
0962:  ADDWF  x8F,F
0964:  RLCF   x8E,F
0966:  RLCF   x8F,F
0968:  COMF   x8F,F
096A:  RLCF   x8F,F
096C:  MOVF   x89,W
096E:  ANDLW  0F
0970:  ADDWF  x8F,F
0972:  RLCF   x8C,F
0974:  MOVLW  07
0976:  MOVWF  x8B
0978:  MOVLW  0A
097A:  DECF   x8E,F
097C:  ADDWF  x8F,F
097E:  BNC   097A
0980:  DECF   x8D,F
0982:  ADDWF  x8E,F
0984:  BNC   0980
0986:  DECF   x8C,F
0988:  ADDWF  x8D,F
098A:  BNC   0986
098C:  DECF   x8B,F
098E:  ADDWF  x8C,F
0990:  BNC   098C
0992:  MOVLW  01
0994:  MOVWF  FEA
0996:  MOVLW  8B
0998:  MOVWF  FE9
099A:  MOVLW  07
099C:  ANDWF  x90,W
099E:  BCF    x90.6
09A0:  MOVF   FED,F
09A2:  ANDWF  x90,W
09A4:  BNZ   09B4
09A6:  BTFSC  x90.4
09A8:  MOVF   FEE,F
09AA:  BTFSC  x90.4
09AC:  BRA    09B4
09AE:  MOVLW  20
09B0:  MOVWF  00
09B2:  BRA    09F4
09B4:  ADDWF  FE9,F
09B6:  MOVLW  00
09B8:  ADDWFC FEA,F
09BA:  MOVF   FE9,W
09BC:  SUBLW  8F
09BE:  BNZ   09C6
09C0:  DECFSZ FEA,W
09C2:  BRA    09C6
09C4:  BSF    x90.6
09C6:  MOVF   FEF,W
09C8:  MOVWF  00
09CA:  BNZ   09DC
09CC:  BTFSC  x90.6
09CE:  BRA    09DC
09D0:  BTFSC  x90.4
09D2:  BRA    0A0E
09D4:  BTFSC  x90.3
09D6:  BRA    09DC
09D8:  MOVLW  20
09DA:  BRA    09F2
09DC:  BTFSS  x90.7
09DE:  BRA    09EC
09E0:  MOVLW  2D
09E2:  MOVWF  00
09E4:  MOVF   FED,W
09E6:  BCF    x90.6
09E8:  BCF    x90.7
09EA:  BRA    09F4
09EC:  BSF    x90.3
09EE:  BCF    x90.4
09F0:  MOVLW  30
09F2:  ADDWF  00,F
09F4:  MOVFF  FEA,18A
09F8:  MOVFF  FE9,189
09FC:  MOVFF  00,192
0A00:  MOVLB  0
0A02:  RCALL  0894
0A04:  MOVFF  18A,FEA
0A08:  MOVFF  189,FE9
0A0C:  MOVLB  1
0A0E:  MOVF   FEE,W
0A10:  BTFSS  x90.6
0A12:  BRA    09BA
0A14:  MOVLB  0
0A16:  RETURN 0
0A18:  TBLRD*+
0A1A:  MOVF   FF5,F
0A1C:  BZ    0A36
0A1E:  MOVFF  FF6,18D
0A22:  MOVFF  FF7,18E
0A26:  MOVFF  FF5,192
0A2A:  RCALL  0894
0A2C:  MOVFF  18D,FF6
0A30:  MOVFF  18E,FF7
0A34:  BRA    0A18
0A36:  RETURN 0
*
0E10:  TBLRD*+
0E12:  MOVF   FF5,F
0E14:  BZ    0E30
0E16:  MOVFF  FF6,18B
0E1A:  MOVFF  FF7,18C
0E1E:  MOVF   FF5,W
0E20:  BTFSS  F9E.4
0E22:  BRA    0E20
0E24:  MOVWF  FAD
0E26:  MOVFF  18B,FF6
0E2A:  MOVFF  18C,FF7
0E2E:  BRA    0E10
0E30:  RETURN 0
*
10AE:  MOVLB  1
10B0:  MOVF   x90,W
10B2:  CLRF   01
10B4:  SUBWF  x8F,W
10B6:  BC    10BE
10B8:  MOVFF  18F,00
10BC:  BRA    10D6
10BE:  CLRF   00
10C0:  MOVLW  08
10C2:  MOVWF  x91
10C4:  RLCF   x8F,F
10C6:  RLCF   00,F
10C8:  MOVF   x90,W
10CA:  SUBWF  00,W
10CC:  BTFSC  FD8.0
10CE:  MOVWF  00
10D0:  RLCF   01,F
10D2:  DECFSZ x91,F
10D4:  BRA    10C4
10D6:  MOVLB  0
10D8:  RETURN 0
10DA:  MOVLW  20
10DC:  MOVLB  1
10DE:  BTFSS  x8A.4
10E0:  MOVLW  30
10E2:  MOVWF  x8B
10E4:  MOVFF  189,00
10E8:  BTFSS  x89.7
10EA:  BRA    10FC
10EC:  COMF   00,F
10EE:  INCF   00,F
10F0:  MOVFF  00,189
10F4:  MOVLW  2D
10F6:  MOVWF  x8B
10F8:  BSF    x8A.7
10FA:  BSF    x8A.0
10FC:  MOVF   01,W
10FE:  MOVFF  189,18F
1102:  MOVLW  64
1104:  MOVWF  x90
1106:  MOVLB  0
1108:  RCALL  10AE
110A:  MOVFF  00,189
110E:  MOVLW  30
1110:  ADDWF  01,W
1112:  MOVLB  1
1114:  MOVWF  x8C
1116:  MOVFF  189,18F
111A:  MOVLW  0A
111C:  MOVWF  x90
111E:  MOVLB  0
1120:  RCALL  10AE
1122:  MOVLW  30
1124:  ADDWF  00,W
1126:  MOVLB  1
1128:  MOVWF  x8E
112A:  MOVLW  30
112C:  ADDWF  01,W
112E:  MOVWF  x8D
1130:  MOVFF  18B,00
1134:  MOVLW  30
1136:  SUBWF  x8C,W
1138:  BZ    1142
113A:  BSF    x8A.1
113C:  BTFSC  x8A.7
113E:  BSF    x8A.2
1140:  BRA    1166
1142:  MOVFF  18B,18C
1146:  MOVLW  20
1148:  MOVWF  x8B
114A:  MOVLW  30
114C:  SUBWF  x8D,W
114E:  BZ    1158
1150:  BSF    x8A.0
1152:  BTFSC  x8A.7
1154:  BSF    x8A.1
1156:  BRA    1166
1158:  BTFSS  FD8.2
115A:  BSF    x8A.0
115C:  BNZ   1166
115E:  MOVFF  18C,18D
1162:  MOVLW  20
1164:  MOVWF  x8C
1166:  BTFSC  x8A.2
1168:  BRA    1174
116A:  BTFSC  x8A.1
116C:  BRA    117E
116E:  BTFSC  x8A.0
1170:  BRA    1188
1172:  BRA    1192
1174:  MOVFF  18B,192
1178:  MOVLB  0
117A:  CALL   0894
117E:  MOVFF  18C,192
1182:  MOVLB  0
1184:  CALL   0894
1188:  MOVFF  18D,192
118C:  MOVLB  0
118E:  CALL   0894
1192:  MOVFF  18E,192
1196:  MOVLB  0
1198:  CALL   0894
119C:  RETURN 0
*
1204:  TBLRD*+
1206:  MOVF   FF5,F
1208:  BZ    1222
120A:  MOVFF  FF6,189
120E:  MOVFF  FF7,18A
1212:  MOVFF  FF5,192
1216:  RCALL  11B6
1218:  MOVFF  189,FF6
121C:  MOVFF  18A,FF7
1220:  BRA    1204
1222:  GOTO   2E6E (RETURN)
*
127C:  TSTFSZ 01
127E:  BRA    1286
1280:  TSTFSZ 02
1282:  BRA    1288
1284:  BRA    1294
1286:  INCF   02,F
1288:  MOVFF  00,FEE
128C:  DECFSZ 01,F
128E:  BRA    1288
1290:  DECFSZ 02,F
1292:  BRA    1288
1294:  RETURN 0
*
1416:  TBLRD*+
1418:  MOVFF  FF6,18A
141C:  MOVFF  FF7,18B
1420:  MOVFF  FF5,192
1424:  RCALL  11B6
1426:  MOVFF  18A,FF6
142A:  MOVFF  18B,FF7
142E:  MOVLB  1
1430:  DECFSZ x89,F
1432:  BRA    1436
1434:  BRA    143A
1436:  MOVLB  0
1438:  BRA    1416
143A:  MOVLB  0
143C:  RETURN 0
143E:  MOVFF  FEA,191
1442:  MOVFF  FE9,190
1446:  MOVLB  1
1448:  SWAPF  x8A,W
144A:  IORLW  F0
144C:  MOVWF  x8C
144E:  ADDWF  x8C,F
1450:  ADDLW  E2
1452:  MOVWF  x8D
1454:  ADDLW  32
1456:  MOVWF  x8F
1458:  MOVF   x8A,W
145A:  ANDLW  0F
145C:  ADDWF  x8D,F
145E:  ADDWF  x8D,F
1460:  ADDWF  x8F,F
1462:  ADDLW  E9
1464:  MOVWF  x8E
1466:  ADDWF  x8E,F
1468:  ADDWF  x8E,F
146A:  SWAPF  x89,W
146C:  ANDLW  0F
146E:  ADDWF  x8E,F
1470:  ADDWF  x8F,F
1472:  RLCF   x8E,F
1474:  RLCF   x8F,F
1476:  COMF   x8F,F
1478:  RLCF   x8F,F
147A:  MOVF   x89,W
147C:  ANDLW  0F
147E:  ADDWF  x8F,F
1480:  RLCF   x8C,F
1482:  MOVLW  07
1484:  MOVWF  x8B
1486:  MOVLW  0A
1488:  DECF   x8E,F
148A:  ADDWF  x8F,F
148C:  BNC   1488
148E:  DECF   x8D,F
1490:  ADDWF  x8E,F
1492:  BNC   148E
1494:  DECF   x8C,F
1496:  ADDWF  x8D,F
1498:  BNC   1494
149A:  DECF   x8B,F
149C:  ADDWF  x8C,F
149E:  BNC   149A
14A0:  MOVLW  01
14A2:  MOVWF  FEA
14A4:  MOVLW  8B
14A6:  MOVWF  FE9
14A8:  MOVLW  07
14AA:  ANDWF  x90,W
14AC:  BCF    x90.6
14AE:  ADDWF  FE9,F
14B0:  MOVLW  00
14B2:  ADDWFC FEA,F
14B4:  MOVF   FE9,W
14B6:  SUBLW  8F
14B8:  BNZ   14C0
14BA:  DECFSZ FEA,W
14BC:  BRA    14C0
14BE:  BSF    x90.6
14C0:  MOVF   FEF,W
14C2:  MOVWF  00
14C4:  BNZ   14D6
14C6:  BTFSC  x90.6
14C8:  BRA    14D6
14CA:  BTFSC  x90.4
14CC:  BRA    14F8
14CE:  BTFSC  x90.3
14D0:  BRA    14D6
14D2:  MOVLW  20
14D4:  BRA    14DC
14D6:  BSF    x90.3
14D8:  BCF    x90.4
14DA:  MOVLW  30
14DC:  ADDWF  00,F
14DE:  MOVFF  FEA,18A
14E2:  MOVFF  FE9,189
14E6:  MOVFF  00,192
14EA:  MOVLB  0
14EC:  RCALL  11B6
14EE:  MOVFF  18A,FEA
14F2:  MOVFF  189,FE9
14F6:  MOVLB  1
14F8:  MOVF   FEE,W
14FA:  BTFSS  x90.6
14FC:  BRA    14B4
14FE:  MOVLB  0
1500:  RETURN 0
1502:  MOVF   01,W
1504:  MOVFF  189,18F
1508:  MOVLW  64
150A:  MOVLB  1
150C:  MOVWF  x90
150E:  MOVLB  0
1510:  RCALL  10AE
1512:  MOVFF  00,189
1516:  MOVF   01,W
1518:  MOVLW  30
151A:  BNZ   152C
151C:  MOVLB  1
151E:  BTFSS  x8A.1
1520:  BRA    1540
1522:  BTFSC  x8A.3
1524:  BRA    1540
1526:  BTFSC  x8A.4
1528:  MOVLW  20
152A:  BRA    1534
152C:  MOVLB  1
152E:  BCF    x8A.3
1530:  BCF    x8A.4
1532:  BSF    x8A.0
1534:  ADDWF  01,F
1536:  MOVFF  01,192
153A:  MOVLB  0
153C:  RCALL  11B6
153E:  MOVLB  1
1540:  MOVFF  189,18F
1544:  MOVLW  0A
1546:  MOVWF  x90
1548:  MOVLB  0
154A:  RCALL  10AE
154C:  MOVFF  00,189
1550:  MOVF   01,W
1552:  MOVLW  30
1554:  BNZ   1566
1556:  MOVLB  1
1558:  BTFSC  x8A.3
155A:  BRA    1570
155C:  BTFSS  x8A.0
155E:  BRA    1570
1560:  BTFSC  x8A.4
1562:  MOVLW  20
1564:  MOVLB  0
1566:  ADDWF  01,F
1568:  MOVFF  01,192
156C:  RCALL  11B6
156E:  MOVLB  1
1570:  MOVLW  30
1572:  ADDWF  x89,F
1574:  MOVFF  189,192
1578:  MOVLB  0
157A:  RCALL  11B6
157C:  RETURN 0
*
1FCE:  ADDWF  FE8,W
1FD0:  CLRF   FF7
1FD2:  RLCF   FF7,F
1FD4:  ADDLW  E9
1FD6:  MOVWF  FF6
1FD8:  MOVLW  1F
1FDA:  ADDWFC FF7,F
1FDC:  TBLRD*-
1FDE:  MOVF   FF5,W
1FE0:  MOVWF  FFA
1FE2:  TBLRD*
1FE4:  MOVF   FF5,W
1FE6:  MOVWF  FF9
1FE8:  DATA 9E,1F
1FEA:  DATA C8,1F
1FEC:  DATA C8,1F
1FEE:  DATA C8,1F
1FF0:  DATA A0,1F
1FF2:  DATA B0,1F
1FF4:  DATA B4,1F
1FF6:  DATA C8,1F
1FF8:  DATA C8,1F
1FFA:  DATA C8,1F
1FFC:  DATA B6,1F
1FFE:  DATA C6,1F
*
22D6:  ADDWF  FE8,W
22D8:  CLRF   FF7
22DA:  RLCF   FF7,F
22DC:  ADDLW  F1
22DE:  MOVWF  FF6
22E0:  MOVLW  22
22E2:  ADDWFC FF7,F
22E4:  TBLRD*-
22E6:  MOVF   FF5,W
22E8:  MOVWF  FFA
22EA:  TBLRD*
22EC:  MOVF   FF5,W
22EE:  MOVWF  FF9
22F0:  DATA A6,22
22F2:  DATA D0,22
22F4:  DATA D0,22
22F6:  DATA D0,22
22F8:  DATA A8,22
22FA:  DATA B8,22
22FC:  DATA BC,22
22FE:  DATA D0,22
2300:  DATA D0,22
2302:  DATA D0,22
2304:  DATA BE,22
2306:  DATA CE,22
*
25E0:  ADDWF  FE8,W
25E2:  CLRF   FF7
25E4:  RLCF   FF7,F
25E6:  ADDLW  FB
25E8:  MOVWF  FF6
25EA:  MOVLW  25
25EC:  ADDWFC FF7,F
25EE:  TBLRD*-
25F0:  MOVF   FF5,W
25F2:  MOVWF  FFA
25F4:  TBLRD*
25F6:  MOVF   FF5,W
25F8:  MOVWF  FF9
25FA:  DATA B0,25
25FC:  DATA DA,25
25FE:  DATA DA,25
2600:  DATA DA,25
2602:  DATA B2,25
2604:  DATA C2,25
2606:  DATA C6,25
2608:  DATA DA,25
260A:  DATA DA,25
260C:  DATA DA,25
260E:  DATA C8,25
2610:  DATA D8,25
*
31B4:  ADDWF  FE8,W
31B6:  CLRF   FF7
31B8:  RLCF   FF7,F
31BA:  ADDLW  CF
31BC:  MOVWF  FF6
31BE:  MOVLW  31
31C0:  ADDWFC FF7,F
31C2:  TBLRD*-
31C4:  MOVF   FF5,W
31C6:  MOVWF  FFA
31C8:  TBLRD*
31CA:  MOVF   FF5,W
31CC:  MOVWF  FF9
31CE:  DATA 3A,2E
31D0:  DATA 54,2E
31D2:  DATA 5E,2E
31D4:  DATA A0,2E
31D6:  DATA AA,2E
31D8:  DATA D6,2E
31DA:  DATA 0A,2F
31DC:  DATA 32,2F
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0F8C:  MOVLB  1
0F8E:  MOVFF  18F,FE9
0F92:  MOVFF  190,FEA
0F96:  MOVFF  FEF,193
0F9A:  MOVFF  192,03
0F9E:  MOVFF  191,FE9
0FA2:  MOVFF  192,FEA
0FA6:  MOVF   FEF,W
0FA8:  SUBWF  x93,W
0FAA:  BNZ   0FD6
....................       if (*s1 == '\0') 
0FAC:  MOVFF  190,03
0FB0:  MOVFF  18F,FE9
0FB4:  MOVFF  03,FEA
0FB8:  MOVF   FEF,F
0FBA:  BNZ   0FC2
....................          return(0); 
0FBC:  MOVLW  00
0FBE:  MOVWF  01
0FC0:  BRA    1000
0FC2:  MOVFF  190,03
0FC6:  MOVF   x8F,W
0FC8:  INCF   x8F,F
0FCA:  BTFSC  FD8.2
0FCC:  INCF   x90,F
0FCE:  INCF   x91,F
0FD0:  BTFSC  FD8.2
0FD2:  INCF   x92,F
0FD4:  BRA    0F8E
....................    return((*s1 < *s2) ? -1: 1); 
0FD6:  MOVFF  190,03
0FDA:  MOVFF  18F,FE9
0FDE:  MOVFF  190,FEA
0FE2:  MOVFF  FEF,193
0FE6:  MOVFF  192,03
0FEA:  MOVFF  191,FE9
0FEE:  MOVFF  192,FEA
0FF2:  MOVF   FEF,W
0FF4:  SUBWF  x93,W
0FF6:  BC    0FFC
0FF8:  MOVLW  FF
0FFA:  BRA    0FFE
0FFC:  MOVLW  01
0FFE:  MOVWF  01
1000:  MOVLB  0
1002:  GOTO   1046 (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=20000000) 
*
01A2:  MOVLW  03
01A4:  MOVLB  1
01A6:  SUBWF  xA1,F
01A8:  BNC   01BE
01AA:  MOVLW  01
01AC:  MOVWF  FEA
01AE:  MOVLW  A1
01B0:  MOVWF  FE9
01B2:  MOVF   FEF,W
01B4:  BZ    01BE
01B6:  BRA    01BA
01B8:  BRA    01BA
01BA:  DECFSZ FEF,F
01BC:  BRA    01B8
01BE:  MOVLB  0
01C0:  GOTO   01D6 (RETURN)
*
03DE:  MOVLW  01
03E0:  MOVWF  FEA
03E2:  MOVLW  93
03E4:  MOVWF  FE9
03E6:  MOVF   FEF,W
03E8:  BZ    0404
03EA:  MOVLW  06
03EC:  MOVWF  01
03EE:  CLRF   00
03F0:  DECFSZ 00,F
03F2:  BRA    03F0
03F4:  DECFSZ 01,F
03F6:  BRA    03EE
03F8:  MOVLW  7B
03FA:  MOVWF  00
03FC:  DECFSZ 00,F
03FE:  BRA    03FC
0400:  DECFSZ FEF,F
0402:  BRA    03EA
0404:  RETURN 0
.................... #use rs232(uart1, baud=9600,TIMEOUT=10,stream=monitor)//pic to pic 
*
01C4:  MOVLW  20
01C6:  MOVLB  1
01C8:  MOVWF  x9F
01CA:  MOVLW  02
01CC:  MOVWF  xA0
01CE:  MOVLW  9B
01D0:  MOVWF  xA1
01D2:  MOVLB  0
01D4:  BRA    01A2
01D6:  MOVLB  1
01D8:  DECFSZ xA0,F
01DA:  BRA    01CE
01DC:  DECFSZ x9F,F
01DE:  BRA    01E6
01E0:  CLRF   1F
01E2:  CLRF   01
01E4:  BRA    01FA
01E6:  BTFSS  F9E.5
01E8:  BRA    01CA
01EA:  MOVF   FAB,W
01EC:  MOVWF  1F
01EE:  MOVF   FAE,W
01F0:  MOVWF  01
01F2:  BTFSS  1F.1
01F4:  BRA    01FA
01F6:  BCF    FAB.4
01F8:  BSF    FAB.4
01FA:  MOVLB  0
01FC:  GOTO   0228 (RETURN)
.................... #use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
*
0E6A:  MOVLW  10
0E6C:  MOVLB  1
0E6E:  MOVWF  x8A
0E70:  MOVLW  01
0E72:  MOVWF  x89
0E74:  BSF    20.6
0E76:  BSF    F94.1
0E78:  MOVLW  10
0E7A:  MOVWF  00
0E7C:  DECFSZ 00,F
0E7E:  BRA    0E7C
0E80:  NOP   
0E82:  DECFSZ x89,F
0E84:  BRA    0E90
0E86:  DECFSZ x8A,F
0E88:  BRA    0E90
0E8A:  CLRF   20
0E8C:  CLRF   01
0E8E:  BRA    0ED8
0E90:  BTFSC  F82.1
0E92:  BRA    0E78
0E94:  MOVLW  08
0E96:  MOVWF  00
0E98:  CLRF   x8B
0E9A:  MOVFF  FF2,18C
0E9E:  BCF    FF2.7
0EA0:  BSF    00.7
0EA2:  BRA    0EC0
0EA4:  BCF    00.7
0EA6:  BRA    0EC0
0EA8:  BCF    FD8.0
0EAA:  BTFSC  F82.1
0EAC:  BSF    FD8.0
0EAE:  RRCF   x8B,F
0EB0:  BSF    00.6
0EB2:  BRA    0EC0
0EB4:  BCF    00.6
0EB6:  DECFSZ 00,F
0EB8:  BRA    0EA8
0EBA:  MOVF   x8B,W
0EBC:  MOVWF  01
0EBE:  BRA    0ED8
0EC0:  MOVLW  A7
0EC2:  BTFSC  00.7
0EC4:  MOVLW  2D
0EC6:  MOVWF  01
0EC8:  DECFSZ 01,F
0ECA:  BRA    0EC8
0ECC:  NOP   
0ECE:  BTFSC  00.7
0ED0:  BRA    0EA4
0ED2:  BTFSC  00.6
0ED4:  BRA    0EB4
0ED6:  BRA    0EA8
0ED8:  BTFSC  x8C.7
0EDA:  BSF    FF2.7
0EDC:  MOVLB  0
0EDE:  GOTO   2D64 (RETURN)
*
11B6:  MOVFF  FF2,03
11BA:  BCF    FF2.7
11BC:  BCF    F94.0
11BE:  BCF    F8B.0
11C0:  MOVLW  08
11C2:  MOVWF  01
11C4:  BRA    11C6
11C6:  NOP   
11C8:  BSF    01.7
11CA:  BRA    11EC
11CC:  BCF    01.7
11CE:  MOVLB  1
11D0:  RRCF   x92,F
11D2:  MOVLB  0
11D4:  BTFSC  FD8.0
11D6:  BSF    F8B.0
11D8:  BTFSS  FD8.0
11DA:  BCF    F8B.0
11DC:  BSF    01.6
11DE:  BRA    11EC
11E0:  BCF    01.6
11E2:  DECFSZ 01,F
11E4:  BRA    11CE
11E6:  BRA    11E8
11E8:  NOP   
11EA:  BSF    F8B.0
11EC:  MOVLW  A7
11EE:  MOVWF  FE9
11F0:  DECFSZ FE9,F
11F2:  BRA    11F0
11F4:  BRA    11F6
11F6:  BTFSC  01.7
11F8:  BRA    11CC
11FA:  BTFSC  01.6
11FC:  BRA    11E0
11FE:  BTFSC  03.7
1200:  BSF    FF2.7
1202:  RETURN 0
.................... #fuses HS,NOLVP,PUT,PROTECT,NODEBUG,NOWDT,WDT4096//pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0406:  MOVLB  1
0408:  BTFSC  x9A.0
040A:  BRA    0410
040C:  BCF    F89.4
040E:  BRA    0412
0410:  BSF    F89.4
0412:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0414:  BTFSC  x9A.1
0416:  BRA    041C
0418:  BCF    F89.2
041A:  BRA    041E
041C:  BSF    F89.2
041E:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0420:  BTFSC  x9A.2
0422:  BRA    0428
0424:  BCF    F89.1
0426:  BRA    042A
0428:  BSF    F89.1
042A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
042C:  BTFSC  x9A.3
042E:  BRA    0434
0430:  BCF    F89.0
0432:  BRA    0436
0434:  BSF    F89.0
0436:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0438:  NOP   
....................  output_high(LCD_E);  
043A:  BCF    F92.3
043C:  BSF    F89.3
....................  delay_us(2);  
043E:  MOVLW  02
0440:  MOVWF  00
0442:  DECFSZ 00,F
0444:  BRA    0442
0446:  BRA    0448
0448:  NOP   
....................  output_low(LCD_E);  
044A:  BCF    F92.3
044C:  BCF    F89.3
044E:  MOVLB  0
0450:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0452:  BCF    F96.2
0454:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0456:  MOVLW  63
0458:  MOVWF  00
045A:  DECFSZ 00,F
045C:  BRA    045A
045E:  BRA    0460
.................... #endif  
....................  
.................... if(address)  
0460:  MOVLB  1
0462:  MOVF   x97,F
0464:  BZ    046C
....................    output_high(LCD_RS);  
0466:  BCF    F96.2
0468:  BSF    F8D.2
046A:  BRA    0470
.................... else  
....................    output_low(LCD_RS);  
046C:  BCF    F96.2
046E:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0470:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0472:  BCF    F92.3
0474:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
0476:  SWAPF  x98,W
0478:  MOVWF  x99
047A:  MOVLW  0F
047C:  ANDWF  x99,F
047E:  MOVFF  199,19A
0482:  MOVLB  0
0484:  RCALL  0406
.................... lcd_send_nibble(n & 0xf);  
0486:  MOVLB  1
0488:  MOVF   x98,W
048A:  ANDLW  0F
048C:  MOVWF  x99
048E:  MOVWF  x9A
0490:  MOVLB  0
0492:  RCALL  0406
0494:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
0496:  MOVLW  01
0498:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
049A:  BCF    F96.2
049C:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
049E:  BCF    F92.3
04A0:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
04A2:  MOVLW  23
04A4:  MOVLB  1
04A6:  MOVWF  x93
04A8:  MOVLB  0
04AA:  RCALL  03DE
....................  
....................    for(i=0 ;i < 3; i++)  
04AC:  MOVLB  1
04AE:  CLRF   x89
04B0:  MOVF   x89,W
04B2:  SUBLW  02
04B4:  BNC   04CE
....................    {  
....................       lcd_send_nibble(0x03);  
04B6:  MOVLW  03
04B8:  MOVWF  x9A
04BA:  MOVLB  0
04BC:  RCALL  0406
....................       delay_ms(5);  
04BE:  MOVLW  05
04C0:  MOVLB  1
04C2:  MOVWF  x93
04C4:  MOVLB  0
04C6:  RCALL  03DE
04C8:  MOVLB  1
04CA:  INCF   x89,F
04CC:  BRA    04B0
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04CE:  MOVLW  02
04D0:  MOVWF  x9A
04D2:  MOVLB  0
04D4:  RCALL  0406
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
04D6:  MOVLB  1
04D8:  CLRF   x89
04DA:  MOVF   x89,W
04DC:  SUBLW  03
04DE:  BNC   0504
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
04E0:  CLRF   03
04E2:  MOVF   x89,W
04E4:  MOVLB  0
04E6:  RCALL  00C6
04E8:  MOVLB  1
04EA:  MOVWF  x8A
04EC:  CLRF   x97
04EE:  MOVWF  x98
04F0:  MOVLB  0
04F2:  RCALL  0452
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
04F4:  MOVLW  05
04F6:  MOVLB  1
04F8:  MOVWF  x93
04FA:  MOVLB  0
04FC:  RCALL  03DE
....................       #endif  
04FE:  MOVLB  1
0500:  INCF   x89,F
0502:  BRA    04DA
....................    }  
0504:  MOVLB  0
0506:  GOTO   2B36 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
0842:  MOVLB  1
0844:  MOVF   x94,W
0846:  XORLW  01
0848:  MOVLB  0
084A:  BZ    085A
084C:  XORLW  03
084E:  BZ    0860
0850:  XORLW  01
0852:  BZ    0868
0854:  XORLW  07
0856:  BZ    0870
0858:  BRA    087A
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
085A:  MOVLB  1
085C:  CLRF   x95
....................      break;  
085E:  BRA    087E
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0860:  MOVLW  40
0862:  MOVLB  1
0864:  MOVWF  x95
....................      break;  
0866:  BRA    087E
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0868:  MOVLW  14
086A:  MOVLB  1
086C:  MOVWF  x95
....................      break;  
086E:  BRA    087E
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0870:  MOVLW  54
0872:  MOVLB  1
0874:  MOVWF  x95
....................      break;  
0876:  BRA    087E
0878:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
087A:  MOVLB  1
087C:  CLRF   x95
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
087E:  MOVLW  01
0880:  SUBWF  x93,W
0882:  ADDWF  x95,F
.................... lcd_send_byte(0, 0x80 | address);  
0884:  MOVF   x95,W
0886:  IORLW  80
0888:  MOVWF  x96
088A:  CLRF   x97
088C:  MOVWF  x98
088E:  MOVLB  0
0890:  RCALL  0452
0892:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0894:  MOVLB  1
0896:  MOVF   x92,W
0898:  XORLW  0C
089A:  MOVLB  0
089C:  BZ    08A8
089E:  XORLW  06
08A0:  BZ    08C4
08A2:  XORLW  02
08A4:  BZ    08D6
08A6:  BRA    08E4
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
08A8:  MOVLB  1
08AA:  CLRF   x97
08AC:  MOVLW  01
08AE:  MOVWF  x98
08B0:  MOVLB  0
08B2:  RCALL  0452
....................       lcd_line = 1;  
08B4:  MOVLW  01
08B6:  MOVWF  21
....................       delay_ms(2);  
08B8:  MOVLW  02
08BA:  MOVLB  1
08BC:  MOVWF  x93
08BE:  MOVLB  0
08C0:  RCALL  03DE
....................       break;  
08C2:  BRA    08F2
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08C4:  INCF   21,F
08C6:  MOVLW  01
08C8:  MOVLB  1
08CA:  MOVWF  x93
08CC:  MOVFF  21,194
08D0:  MOVLB  0
08D2:  RCALL  0842
....................        break;  
08D4:  BRA    08F2
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
08D6:  MOVLB  1
08D8:  CLRF   x97
08DA:  MOVLW  10
08DC:  MOVWF  x98
08DE:  MOVLB  0
08E0:  RCALL  0452
....................        break;  
08E2:  BRA    08F2
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
08E4:  MOVLW  01
08E6:  MOVLB  1
08E8:  MOVWF  x97
08EA:  MOVFF  192,198
08EE:  MOVLB  0
08F0:  RCALL  0452
....................        break;  
....................    }  
08F2:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0512:  MOVLW  08
0514:  MOVWF  01
0516:  MOVLW  05
0518:  MOVWF  00
051A:  DECFSZ 00,F
051C:  BRA    051A
051E:  BCF    F8C.7
0520:  BCF    F95.7
0522:  MOVLW  06
0524:  MOVWF  00
0526:  DECFSZ 00,F
0528:  BRA    0526
052A:  MOVLB  1
052C:  RLCF   x93,F
052E:  BCF    F8C.6
0530:  BTFSC  FD8.0
0532:  BSF    F95.6
0534:  BTFSS  FD8.0
0536:  BCF    F95.6
0538:  BSF    F95.7
053A:  BTFSS  F83.7
053C:  BRA    053A
053E:  DECFSZ 01,F
0540:  BRA    0544
0542:  BRA    0548
0544:  MOVLB  0
0546:  BRA    0516
0548:  MOVLW  05
054A:  MOVWF  00
054C:  DECFSZ 00,F
054E:  BRA    054C
0550:  BCF    F8C.7
0552:  BCF    F95.7
0554:  NOP   
0556:  BSF    F95.6
0558:  MOVLW  06
055A:  MOVWF  00
055C:  DECFSZ 00,F
055E:  BRA    055C
0560:  MOVLW  06
0562:  MOVWF  00
0564:  DECFSZ 00,F
0566:  BRA    0564
0568:  BSF    F95.7
056A:  BTFSS  F83.7
056C:  BRA    056A
056E:  CLRF   01
0570:  MOVLW  06
0572:  MOVWF  00
0574:  DECFSZ 00,F
0576:  BRA    0574
0578:  BTFSC  F83.6
057A:  BSF    01.0
057C:  BCF    F8C.7
057E:  BCF    F95.7
0580:  BCF    F8C.6
0582:  BCF    F95.6
0584:  MOVLB  0
0586:  RETURN 0
*
06DC:  MOVLW  08
06DE:  MOVLB  1
06E0:  MOVWF  x91
06E2:  MOVFF  00,192
06E6:  BSF    F95.6
06E8:  MOVLW  06
06EA:  MOVWF  00
06EC:  DECFSZ 00,F
06EE:  BRA    06EC
06F0:  BSF    F95.7
06F2:  BTFSS  F83.7
06F4:  BRA    06F2
06F6:  BTFSC  F83.6
06F8:  BSF    FD8.0
06FA:  BTFSS  F83.6
06FC:  BCF    FD8.0
06FE:  RLCF   01,F
0700:  MOVLW  05
0702:  MOVWF  00
0704:  DECFSZ 00,F
0706:  BRA    0704
0708:  BCF    F95.7
070A:  BCF    F8C.7
070C:  DECFSZ x91,F
070E:  BRA    06E6
0710:  BSF    F95.6
0712:  MOVLW  06
0714:  MOVWF  00
0716:  DECFSZ 00,F
0718:  BRA    0716
071A:  BCF    F8C.6
071C:  MOVF   x92,W
071E:  BTFSS  FD8.2
0720:  BCF    F95.6
0722:  NOP   
0724:  BSF    F95.7
0726:  BTFSS  F83.7
0728:  BRA    0726
072A:  MOVLW  05
072C:  MOVWF  00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  BCF    F8C.7
0734:  BCF    F95.7
0736:  MOVLW  06
0738:  MOVWF  00
073A:  DECFSZ 00,F
073C:  BRA    073A
073E:  BCF    F8C.6
0740:  BCF    F95.6
0742:  MOVLB  0
0744:  GOTO   07C2 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
050A:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
050C:  BSF    F95.6
050E:  GOTO   2B3A (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0588:  BSF    F95.6
058A:  MOVLW  05
058C:  MOVWF  00
058E:  DECFSZ 00,F
0590:  BRA    058E
0592:  BSF    F95.7
0594:  MOVLW  06
0596:  MOVWF  00
0598:  DECFSZ 00,F
059A:  BRA    0598
059C:  BCF    F8C.6
059E:  BCF    F95.6
05A0:  MOVLW  05
05A2:  MOVWF  00
05A4:  DECFSZ 00,F
05A6:  BRA    05A4
05A8:  BCF    F8C.7
05AA:  BCF    F95.7
....................    i2c_write(0xa0); 
05AC:  MOVLW  A0
05AE:  MOVLB  1
05B0:  MOVWF  x93
05B2:  MOVLB  0
05B4:  RCALL  0512
....................    i2c_write(address>>8); 
05B6:  MOVFF  18E,191
05BA:  MOVLB  1
05BC:  CLRF   x92
05BE:  MOVFF  18E,193
05C2:  MOVLB  0
05C4:  RCALL  0512
....................    i2c_write(address); 
05C6:  MOVFF  18D,193
05CA:  RCALL  0512
....................    i2c_write(data); 
05CC:  MOVFF  18F,193
05D0:  RCALL  0512
....................    i2c_stop(); 
05D2:  BCF    F95.6
05D4:  NOP   
05D6:  BSF    F95.7
05D8:  BTFSS  F83.7
05DA:  BRA    05D8
05DC:  MOVLW  05
05DE:  MOVWF  00
05E0:  DECFSZ 00,F
05E2:  BRA    05E0
05E4:  BRA    05E6
05E6:  NOP   
05E8:  BSF    F95.6
05EA:  MOVLW  05
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
....................    i2c_start(); 
05F2:  BSF    F95.6
05F4:  MOVLW  05
05F6:  MOVWF  00
05F8:  DECFSZ 00,F
05FA:  BRA    05F8
05FC:  BSF    F95.7
05FE:  MOVLW  06
0600:  MOVWF  00
0602:  DECFSZ 00,F
0604:  BRA    0602
0606:  BCF    F8C.6
0608:  BCF    F95.6
060A:  MOVLW  05
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  BCF    F8C.7
0614:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0616:  MOVLW  A0
0618:  MOVLB  1
061A:  MOVWF  x93
061C:  MOVLB  0
061E:  RCALL  0512
0620:  MOVF   01,W
0622:  MOVLB  1
0624:  BCF    x90.0
0626:  BTFSC  01.0
0628:  BSF    x90.0
....................    while(status==1) 
062A:  BTFSS  x90.0
062C:  BRA    066A
....................    { 
....................    i2c_start(); 
062E:  BSF    F95.6
0630:  MOVLW  05
0632:  MOVWF  00
0634:  DECFSZ 00,F
0636:  BRA    0634
0638:  BSF    F95.7
063A:  MOVLW  06
063C:  MOVWF  00
063E:  DECFSZ 00,F
0640:  BRA    063E
0642:  BTFSS  F83.7
0644:  BRA    0642
0646:  BCF    F8C.6
0648:  BCF    F95.6
064A:  MOVLW  05
064C:  MOVWF  00
064E:  DECFSZ 00,F
0650:  BRA    064E
0652:  BCF    F8C.7
0654:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0656:  MOVLW  A0
0658:  MOVWF  x93
065A:  MOVLB  0
065C:  RCALL  0512
065E:  MOVF   01,W
0660:  MOVLB  1
0662:  BCF    x90.0
0664:  BTFSC  01.0
0666:  BSF    x90.0
0668:  BRA    062A
....................    } 
....................    i2c_stop(); 
066A:  BCF    F95.6
066C:  NOP   
066E:  BSF    F95.7
0670:  BTFSS  F83.7
0672:  BRA    0670
0674:  MOVLW  05
0676:  MOVWF  00
0678:  DECFSZ 00,F
067A:  BRA    0678
067C:  BRA    067E
067E:  NOP   
0680:  BSF    F95.6
0682:  MOVLW  05
0684:  MOVWF  00
0686:  DECFSZ 00,F
0688:  BRA    0686
068A:  MOVLB  0
068C:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0748:  BSF    F95.6
074A:  MOVLW  05
074C:  MOVWF  00
074E:  DECFSZ 00,F
0750:  BRA    074E
0752:  BSF    F95.7
0754:  MOVLW  06
0756:  MOVWF  00
0758:  DECFSZ 00,F
075A:  BRA    0758
075C:  BCF    F8C.6
075E:  BCF    F95.6
0760:  MOVLW  05
0762:  MOVWF  00
0764:  DECFSZ 00,F
0766:  BRA    0764
0768:  BCF    F8C.7
076A:  BCF    F95.7
....................    i2c_write(0xa0); 
076C:  MOVLW  A0
076E:  MOVLB  1
0770:  MOVWF  x93
0772:  MOVLB  0
0774:  RCALL  0512
....................    i2c_write(address>>8); 
0776:  MOVFF  18E,190
077A:  MOVLB  1
077C:  CLRF   x91
077E:  MOVFF  18E,193
0782:  MOVLB  0
0784:  RCALL  0512
....................    i2c_write(address); 
0786:  MOVFF  18D,193
078A:  RCALL  0512
....................    i2c_start(); 
078C:  BSF    F95.6
078E:  MOVLW  05
0790:  MOVWF  00
0792:  DECFSZ 00,F
0794:  BRA    0792
0796:  BSF    F95.7
0798:  MOVLW  06
079A:  MOVWF  00
079C:  DECFSZ 00,F
079E:  BRA    079C
07A0:  BTFSS  F83.7
07A2:  BRA    07A0
07A4:  BCF    F8C.6
07A6:  BCF    F95.6
07A8:  MOVLW  05
07AA:  MOVWF  00
07AC:  DECFSZ 00,F
07AE:  BRA    07AC
07B0:  BCF    F8C.7
07B2:  BCF    F95.7
....................    i2c_write(0xa1); 
07B4:  MOVLW  A1
07B6:  MOVLB  1
07B8:  MOVWF  x93
07BA:  MOVLB  0
07BC:  RCALL  0512
....................    data=i2c_read(0); 
07BE:  CLRF   00
07C0:  BRA    06DC
07C2:  MOVFF  01,18F
....................    i2c_stop(); 
07C6:  BCF    F95.6
07C8:  NOP   
07CA:  BSF    F95.7
07CC:  BTFSS  F83.7
07CE:  BRA    07CC
07D0:  MOVLW  05
07D2:  MOVWF  00
07D4:  DECFSZ 00,F
07D6:  BRA    07D4
07D8:  BRA    07DA
07DA:  NOP   
07DC:  BSF    F95.6
07DE:  MOVLW  05
07E0:  MOVWF  00
07E2:  DECFSZ 00,F
07E4:  BRA    07E2
....................    return(data); 
07E6:  MOVLB  1
07E8:  MOVFF  18F,01
07EC:  MOVLB  0
07EE:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... //entradas 
.................... #define entrada01  PIN_B4////SENSOR 1              2  1 
.................... #define entrada02  PIN_D4////SENSOR 2              4  3 
.................... #define entrada03  PIN_B2////SENSOR 3              6  5 
.................... #define entrada04  PIN_B3////SENSOR 4 
.................... #define entrada05  PIN_B0////SENSOR 5 
.................... #define entrada06  PIN_B1////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3////REINICIAR CONTADOR 
.................... #define frente  PIN_D2///INDICADOR DE MAESTRO 
.................... #define B_silencio  PIN_D1///BOTON PARA SILENCIAR (eliminado) 
.................... //salidas 
.................... #define salida01  PIN_C3//Buzzer 
.................... #define salida02  PIN_C4//Indicador de Sensado 
.................... #define salida03  PIN_C5//Relay 
....................  
.................... #define HB PIN_E0 
.................... #define EN PIN_E1 
....................  
....................  
.................... const int s_cta=5;//numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;//Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error,transmitir;//variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1,sumas1;//Variables temporales de suma de entradas y salidas 
.................... int lim_b;//cuenta de sensores bloqueados 
.................... int fse1,fse2,fse3,fss1,fss2,fss3;//banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1,temporal2,tempo_tn,sub_atras,baj_atras;//variables temporales para hacer calculos. 
.................... int16 entran1,salen1;//variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian,time_clr;//variable temporal para guardar salidas 
.................... int ini,i,ii,j=0,a,master=0,flag_enviar,f_clr; 
.................... int16 b,n,cta_bloqueo,cta_enviar,total2_t;//,envia_ent,envia_sal; 
.................... int cta_bloq1=0,cta_bloq2=0,cta_bloq3=0;//variables para contar bloqueos por pares 
.................... int ent1=0,ent2=0,ent3=0,ent4=0,ent5=0,ent6=0;//variables de estado de sensores 
.................... int sen_ent=0,sen_sal=0;//variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1=0,sub_cta2=0,sub_cta3=0,sub_cta4=0,sub_cta5=0,sub_cta6=0;//variables para calculos de cuentas 
.................... int detec1,detec2,detec3,detec4,detec5,detec6;//variables para determinar el cambio de estado de los sensores 
.................... int sub_d1,sub_d2,sub_d3,sub_d4,sub_d5,sub_d6;//variables para determinar el cambio de estado de los sensores 
.................... int entra_act1=0,edo1=0,entra1=0,sale1=0,edoa1=0,enable1=0,entra_temp1=0;//variables para la maquina de estados de sensores par1 
.................... int entra_act2=0,edo2=0,entra2=0,sale2=0,edoa2=0,enable2=0,entra_temp2=0;//variables para la maquina de estados de sensores par2 
.................... int entra_act3=0,edo3=0,entra3=0,sale3=0,edoa3=0,enable3=0,entra_temp3=0;//variables para la maquina de estados de sensores par3 
.................... int16 entraront=0,salieront=0,pasaje=0,pasajet=0;//cuenta total de entradas y salidas 
.................... int16 tem_entraront=0,tem_salieront=0,temporal3;//cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1=0,des2=0,des3=0; 
.................... int bloq_p1,bloq_p2,bloq_p3,en_b1,en_b2,en_b3; 
.................... int16 tim_p1,tim_p2,tim_p3,segundoen,time_envio; 
.................... const int32 set_timer=59286;//10ms 
.................... const int16 time_bloqueo=500;//5seg. 100=1seg. 
.................... int clear_lcd1,time_lcd1; 
.................... int y=0; 
.................... int bandera_revision=0; 
.................... int16 cntbnd=0; 
....................  
.................... /* 
.................... char texto1[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char texto2[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char texto3[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char texto4[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char texto5[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char texto6[]= "SERIALTEST"; // 
.................... char texto7[]= "SERIAL_TOK"; // 
.................... char texto8[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char texto9[]= "SINFUNCION"; // 
.................... char texto []= "          "; 
.................... char version[]="V5.01";//<---Version de codigo de contador 
....................  
....................  
.................... char grabar_historial_pic[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char leer_historial_pic[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char borrar_todo[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char solicitar[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char conteo_poste_trasero[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char prueba_serial[]= "SERIALTEST"; // 
.................... char serial_ok[]= "SERIAL_TOK"; // 
.................... char suben_poste_trasero[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char sin_funcion[]= "SINFUNCION"; // 
.................... char espacios []= "          "; 
.................... char version_firmware[]="V5.01";//<---Version de codigo de contador 
.................... */ 
.................... //char textosearch[] = {"GRABAR_DAT","LEERCUENTA","BORRAR_ALL","SOLICITADO","PASAJEROS:","SERIALTEST","SERIAL_TOK","SUBIENDOC2","SINFUNCION","          ","V5.01"}; 
.................... /* 
.................... char *textosearch[11] =    { "GRABAR_DAT\r", 
....................                              "LEERCUENTA\r", 
....................                              "BORRAR_ALL\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r", 
....................                              "V5.01     \r" 
....................                            }; 
.................... */ 
....................  
.................... char *textosearch[11] =    { "V5.01     \r", 
....................                              "BORRAR_ALL\r", 
....................                              "GRABAR_DAT\r",//GRABAR_DAT 
....................                              "LEERCUENTA\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r" 
....................                              
....................                            }; 
....................  
....................  
....................  
.................... char version[]="V5.02";//<---Version de codigo de contador 
....................  
....................  
.................... /////EEPROM/////////// 
.................... const int word_size =10;//TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set=9; 
.................... char XX[word_size+19];// ARREGLO SERIAL 
.................... char entran[4]; 
.................... char salen[4]; 
.................... char bloqueado[3]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[4]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... //void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
....................    time_clr++; 
*
00DA:  INCF   3E,F
00DC:  BTFSC  FD8.2
00DE:  INCF   3F,F
....................    segundoen++; 
00E0:  INCF   xA7,F
00E2:  BTFSC  FD8.2
00E4:  INCF   xA8,F
....................    if(segundoen>=100) { 
00E6:  MOVF   xA8,F
00E8:  BNZ   00F0
00EA:  MOVF   xA7,W
00EC:  SUBLW  63
00EE:  BC    00FC
....................       segundoen=0; 
00F0:  CLRF   xA8
00F2:  CLRF   xA7
....................       time_envio++; 
00F4:  INCF   xA9,F
00F6:  BTFSC  FD8.2
00F8:  INCF   xAA,F
....................       time_lcd1++; 
00FA:  INCF   xAC,F
....................    } 
.................... //****Se definen los estados de los sensores (deteccion)***// 
....................    //sensor1 
....................    ent1=input(entrada01); 
00FC:  BSF    F93.4
00FE:  CLRF   55
0100:  BTFSC  F81.4
0102:  INCF   55,F
....................    if(ent1==0) sub_cta1++;//ent1 =0 (no pulso) 
0104:  MOVF   55,F
0106:  BNZ   010E
0108:  INCF   5D,F
010A:  BTFSC  FD8.2
010C:  INCF   5E,F
....................    //sensor2 
....................    ent2=input(entrada02); 
010E:  BSF    F95.4
0110:  CLRF   56
0112:  BTFSC  F83.4
0114:  INCF   56,F
....................    if(ent2==0) sub_cta2++; 
0116:  MOVF   56,F
0118:  BNZ   0120
011A:  INCF   5F,F
011C:  BTFSC  FD8.2
011E:  INCF   x60,F
....................    //sensor3 
....................    ent3=input(entrada03); 
0120:  BSF    F93.2
0122:  CLRF   57
0124:  BTFSC  F81.2
0126:  INCF   57,F
....................    if(ent3==0) sub_cta3++; 
0128:  MOVF   57,F
012A:  BNZ   0132
012C:  INCF   x61,F
012E:  BTFSC  FD8.2
0130:  INCF   x62,F
....................    //sensor4 
....................    ent4=input(entrada04); 
0132:  BSF    F93.3
0134:  CLRF   58
0136:  BTFSC  F81.3
0138:  INCF   58,F
....................    if(ent4==0) sub_cta4++; 
013A:  MOVF   58,F
013C:  BNZ   0144
013E:  INCF   x63,F
0140:  BTFSC  FD8.2
0142:  INCF   x64,F
....................    //sensor5 
....................    ent5=input(entrada05); 
0144:  BSF    F93.0
0146:  CLRF   59
0148:  BTFSC  F81.0
014A:  INCF   59,F
....................    if(ent5==0) sub_cta5++; 
014C:  MOVF   59,F
014E:  BNZ   0156
0150:  INCF   x65,F
0152:  BTFSC  FD8.2
0154:  INCF   x66,F
....................    //sensor6 
....................    ent6=input(entrada06); 
0156:  BSF    F93.1
0158:  CLRF   5A
015A:  BTFSC  F81.1
015C:  INCF   5A,F
....................    if(ent6==0) sub_cta6++; 
015E:  MOVF   5A,F
0160:  BNZ   0168
0162:  INCF   x67,F
0164:  BTFSC  FD8.2
0166:  INCF   x68,F
.................... //****************************************// 
....................    tim_p1++; 
0168:  INCF   xA1,F
016A:  BTFSC  FD8.2
016C:  INCF   xA2,F
....................    tim_p2++; 
016E:  INCF   xA3,F
0170:  BTFSC  FD8.2
0172:  INCF   xA4,F
....................    tim_p3++; 
0174:  INCF   xA5,F
0176:  BTFSC  FD8.2
0178:  INCF   xA6,F
....................    cta_enviar++; 
017A:  INCF   4E,F
017C:  BTFSC  FD8.2
017E:  INCF   4F,F
.................... set_timer1(set_timer);// 10ms 
0180:  MOVLW  E7
0182:  MOVWF  FCF
0184:  MOVLW  96
0186:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
.................... /* 
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................    while (i <= size_s){ 
....................          XX[i] = fgetc(monitor);//se captura el dato del serial monitor(comunicacion entre pics) 
....................         i++; 
....................    } 
.................... j=1; 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
.................... */ 
....................  
.................... //----------------------------------------------------------------------------- 
....................  
0188:  BCF    F9E.0
018A:  GOTO   0078
.................... #int_TIMER3 
.................... void  TIMER3_isr(void)  
.................... { 
....................   // output_toggle(salida01);  
....................    cntbnd++; 
018E:  INCF   xAF,F
0190:  BTFSC  FD8.2
0192:  INCF   xB0,F
....................     
....................   // if(cntbnd>=5000){ ///3  ORIGINAL 13889 
....................   // lcd_gotoxy(12,2); 
....................    //printf(lcd_putc,"%Ld",cntbnd); 
....................    //output_toggle(salida03); 
....................     
....................   // cntbnd=0; 
....................   // } 
....................    
....................    set_timer3(65036);  
0194:  MOVLW  FE
0196:  MOVWF  FB3
0198:  MOVLW  0C
019A:  MOVWF  FB2
....................     
.................... } 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
019C:  BCF    FA1.1
019E:  GOTO   0078
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... disable_interrupts(GLOBAL);//deshabilita interrupciones globales 
*
0200:  BCF    FF2.6
0202:  BCF    FF2.7
0204:  BTFSC  FF2.7
0206:  BRA    0202
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
0208:  CLRF   41
....................  
....................    while(i<=25){ 
020A:  MOVF   41,W
020C:  SUBLW  19
020E:  BNC   0262
....................    XX[i] = fgetc(monitor); 
0210:  CLRF   03
0212:  MOVF   41,W
0214:  ADDLW  51
0216:  MOVWF  FE9
0218:  MOVLW  01
021A:  ADDWFC 03,W
021C:  MOVWF  FEA
021E:  MOVFF  FEA,19E
0222:  MOVFF  FE9,19D
0226:  BRA    01C4
0228:  MOVFF  19E,FEA
022C:  MOVFF  19D,FE9
0230:  MOVFF  01,FEF
....................    i++; 
0234:  INCF   41,F
....................    if(XX[i]==13 || XX[i]==45)break; 
0236:  CLRF   03
0238:  MOVF   41,W
023A:  ADDLW  51
023C:  MOVWF  FE9
023E:  MOVLW  01
0240:  ADDWFC 03,W
0242:  MOVWF  FEA
0244:  MOVF   FEF,W
0246:  SUBLW  0D
0248:  BZ    025E
024A:  CLRF   03
024C:  MOVF   41,W
024E:  ADDLW  51
0250:  MOVWF  FE9
0252:  MOVLW  01
0254:  ADDWFC 03,W
0256:  MOVWF  FEA
0258:  MOVF   FEF,W
025A:  SUBLW  2D
025C:  BTFSC  FD8.2
025E:  BRA    0262
0260:  BRA    020A
....................    };//se captura el dato del serial monitor(comunicacion entre pics) 
....................     
....................     
....................   // XX[i]=fgetc(monitor); 
.................... j=1; 
0262:  MOVLW  01
0264:  MOVWF  43
.................... y=1; 
0266:  MOVWF  xAD
.................... //fprintf(monitor,"XX:%s",XX); 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
0268:  BCF    F9E.5
026A:  GOTO   0078
.................... #ZERO_RAM 
.................... void main(){ 
*
2976:  CLRF   FF8
2978:  BCF    FD0.7
297A:  BSF    07.7
297C:  MOVLW  FE
297E:  MOVWF  00
2980:  MOVLW  06
2982:  MOVWF  01
2984:  MOVLW  02
2986:  MOVWF  FE9
2988:  MOVLW  00
298A:  MOVWF  FEA
298C:  CLRF   FEE
298E:  DECFSZ 00,F
2990:  BRA    298C
2992:  DECFSZ 01,F
2994:  BRA    298C
2996:  CLRF   1F
2998:  BSF    FB8.3
299A:  MOVLW  08
299C:  MOVWF  FAF
299E:  MOVLW  02
29A0:  MOVWF  FB0
29A2:  MOVLW  A6
29A4:  MOVWF  FAC
29A6:  MOVLW  90
29A8:  MOVWF  FAB
29AA:  CLRF   20
29AC:  BCF    F94.0
29AE:  BSF    F8B.0
29B0:  CLRF   43
29B2:  CLRF   45
29B4:  CLRF   52
29B6:  CLRF   53
29B8:  CLRF   54
29BA:  CLRF   55
29BC:  CLRF   56
29BE:  CLRF   57
29C0:  CLRF   58
29C2:  CLRF   59
29C4:  CLRF   5A
29C6:  CLRF   5B
29C8:  CLRF   5C
29CA:  CLRF   5E
29CC:  CLRF   5D
29CE:  CLRF   x60
29D0:  CLRF   5F
29D2:  CLRF   x62
29D4:  CLRF   x61
29D6:  CLRF   x64
29D8:  CLRF   x63
29DA:  CLRF   x66
29DC:  CLRF   x65
29DE:  CLRF   x68
29E0:  CLRF   x67
29E2:  CLRF   x75
29E4:  CLRF   x76
29E6:  CLRF   x77
29E8:  CLRF   x78
29EA:  CLRF   x79
29EC:  CLRF   x7A
29EE:  CLRF   x7B
29F0:  CLRF   x7C
29F2:  CLRF   x7D
29F4:  CLRF   x7E
29F6:  CLRF   x7F
29F8:  CLRF   x80
29FA:  CLRF   x81
29FC:  CLRF   x82
29FE:  CLRF   x83
2A00:  CLRF   x84
2A02:  CLRF   x85
2A04:  CLRF   x86
2A06:  CLRF   x87
2A08:  CLRF   x88
2A0A:  CLRF   x89
2A0C:  CLRF   x8B
2A0E:  CLRF   x8A
2A10:  CLRF   x8D
2A12:  CLRF   x8C
2A14:  CLRF   x8F
2A16:  CLRF   x8E
2A18:  CLRF   x91
2A1A:  CLRF   x90
2A1C:  CLRF   x93
2A1E:  CLRF   x92
2A20:  CLRF   x95
2A22:  CLRF   x94
2A24:  CLRF   x98
2A26:  CLRF   x99
2A28:  CLRF   x9A
2A2A:  CLRF   xAD
2A2C:  CLRF   xAE
2A2E:  CLRF   xB0
2A30:  CLRF   xAF
2A32:  MOVF   FC1,W
2A34:  ANDLW  C0
2A36:  IORLW  0F
2A38:  MOVWF  FC1
2A3A:  MOVLW  07
2A3C:  MOVWF  FB4
2A3E:  BRA    2AEA
2A40:  DATA 02,00
2A42:  DATA 19,00
2A44:  DATA 00,05
2A46:  DATA 00,C7
2A48:  DATA 56,35
2A4A:  DATA 2E,30
2A4C:  DATA 31,05
2A4E:  DATA C0,20
2A50:  DATA 6E,80
2A52:  DATA 0D,00
2A54:  DATA 42,4F
2A56:  DATA 52,52
2A58:  DATA 41,52
2A5A:  DATA 5F,41
2A5C:  DATA 4C,4C
2A5E:  DATA 0D,00
2A60:  DATA 47,52
2A62:  DATA 41,42
2A64:  DATA 41,52
2A66:  DATA 5F,44
2A68:  DATA 41,54
2A6A:  DATA 0D,00
2A6C:  DATA 4C,45
2A6E:  DATA 45,52
2A70:  DATA 43,55
2A72:  DATA 45,4E
2A74:  DATA 54,41
2A76:  DATA 0D,00
2A78:  DATA 53,4F
2A7A:  DATA 4C,49
2A7C:  DATA 43,49
2A7E:  DATA 54,41
2A80:  DATA 44,4F
2A82:  DATA 0D,00
2A84:  DATA 50,41
2A86:  DATA 53,41
2A88:  DATA 4A,45
2A8A:  DATA 52,4F
2A8C:  DATA 53,3A
2A8E:  DATA 0D,00
2A90:  DATA 53,45
2A92:  DATA 52,49
2A94:  DATA 41,4C
2A96:  DATA 54,45
2A98:  DATA 53,54
2A9A:  DATA 0D,00
2A9C:  DATA 53,45
2A9E:  DATA 52,49
2AA0:  DATA 41,4C
2AA2:  DATA 5F,54
2AA4:  DATA 4F,4B
2AA6:  DATA 0D,00
2AA8:  DATA 53,55
2AAA:  DATA 42,49
2AAC:  DATA 45,4E
2AAE:  DATA 44,4F
2AB0:  DATA 43,32
2AB2:  DATA 0D,00
2AB4:  DATA 53,49
2AB6:  DATA 4E,46
2AB8:  DATA 55,4E
2ABA:  DATA 43,49
2ABC:  DATA 4F,4E
2ABE:  DATA 0D,00
2AC0:  DATA 0A,C0
2AC2:  DATA 20,02
2AC4:  DATA 80,0D
2AC6:  DATA 00,16
2AC8:  DATA 00,B1
2ACA:  DATA C7,00
2ACC:  DATA D3,00
2ACE:  DATA DF,00
2AD0:  DATA EB,00
2AD2:  DATA F7,00
2AD4:  DATA 03,01
2AD6:  DATA 0F,01
2AD8:  DATA 1B,01
2ADA:  DATA 27,01
2ADC:  DATA 33,01
2ADE:  DATA 3F,01
2AE0:  DATA 06,01
2AE2:  DATA 4B,56
2AE4:  DATA 35,2E
2AE6:  DATA 30,32
2AE8:  DATA 00,00
2AEA:  MOVLW  00
2AEC:  MOVWF  FF8
2AEE:  MOVLW  2A
2AF0:  MOVWF  FF7
2AF2:  MOVLW  40
2AF4:  MOVWF  FF6
2AF6:  TBLRD*+
2AF8:  MOVF   FF5,W
2AFA:  MOVWF  00
2AFC:  XORLW  00
2AFE:  BZ    2B26
2B00:  TBLRD*+
2B02:  MOVF   FF5,W
2B04:  MOVWF  01
2B06:  BTFSC  FE8.7
2B08:  BRA    2B14
2B0A:  ANDLW  0F
2B0C:  MOVWF  FEA
2B0E:  TBLRD*+
2B10:  MOVFF  FF5,FE9
2B14:  BTFSC  01.6
2B16:  TBLRD*+
2B18:  BTFSS  01.6
2B1A:  TBLRD*+
2B1C:  MOVFF  FF5,FEE
2B20:  DCFSNZ 00,F
2B22:  BRA    2AF6
2B24:  BRA    2B18
2B26:  CLRF   FF8
.................... //Apaga entradas analogicas 
.................... setup_adc_ports(NO_ANALOGS); 
2B28:  MOVF   FC1,W
2B2A:  ANDLW  C0
2B2C:  IORLW  0F
2B2E:  MOVWF  FC1
.................... setup_adc(ADC_OFF); 
2B30:  BCF    FC2.0
.................... lcd_init();//inicia LCD 
2B32:  GOTO   0496
.................... init_ext_eeprom();//Inicia EEPROM 
2B36:  GOTO   050A
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Configura timer1:Reloj interno, preescaler=8 
2B3A:  MOVLW  B5
2B3C:  MOVWF  FCD
.................... enable_interrupts(INT_TIMER1);//Habilito interrupcin particular del TIMER1 
2B3E:  BSF    F9D.0
.................... set_timer1(set_timer);//Setea cuenta para la interrupcion. 
2B40:  MOVLW  E7
2B42:  MOVWF  FCF
2B44:  MOVLW  96
2B46:  MOVWF  FCE
.................... disable_interrupts(INT_EXT);//desabilita interrupciones externas 
2B48:  BCF    FF2.4
.................... enable_interrupts(GLOBAL);//habilita interrupciones globales 
2B4A:  MOVLW  C0
2B4C:  IORWF  FF2,F
.................... ///**************************************************************************/// 
.................... ////////Confuguracion de PWM//////// 
.................... output_low(PIN_C2);//CCP1 
2B4E:  BCF    F94.2
2B50:  BCF    F8B.2
.................... setup_ccp1(CCP_PWM); 
2B52:  BCF    F94.2
2B54:  BCF    F8B.2
2B56:  MOVLW  0C
2B58:  MOVWF  FBD
.................... setup_timer_2(t2_div_By_1,131,1);//frecuencia 38khz 
2B5A:  MOVLW  00
2B5C:  IORLW  04
2B5E:  MOVWF  FCA
2B60:  MOVLW  83
2B62:  MOVWF  FCB
.................... //set_pwm1_duty(26);//(5%) alto 
.................... set_pwm1_duty(279);//(10%) Parte alta del ciclo  
2B64:  MOVLW  45
2B66:  MOVWF  FBE
2B68:  MOVF   FBD,W
2B6A:  ANDLW  CF
2B6C:  IORLW  30
2B6E:  MOVWF  FBD
.................... //////////////////////////////////// 
.................... ini=read_eeprom(100);//Carga estado de inicio 
2B70:  MOVFF  FF2,189
2B74:  BCF    FF2.7
2B76:  MOVLW  64
2B78:  MOVWF  FA9
2B7A:  BCF    FA6.6
2B7C:  BCF    FA6.7
2B7E:  BSF    FA6.0
2B80:  MOVF   FA8,W
2B82:  MOVLB  1
2B84:  BTFSC  x89.7
2B86:  BSF    FF2.7
2B88:  MOVWF  40
.................... if(ini!=1){//Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
2B8A:  DECFSZ 40,W
2B8C:  BRA    2B90
2B8E:  BRA    2BC2
....................    write_eeprom(100,1);//Graba inicio 
2B90:  MOVF   FF2,W
2B92:  MOVWF  00
2B94:  BCF    FF2.7
2B96:  MOVLW  64
2B98:  MOVWF  FA9
2B9A:  MOVLW  01
2B9C:  MOVWF  FA8
2B9E:  BCF    FA6.6
2BA0:  BCF    FA6.7
2BA2:  BSF    FA6.2
2BA4:  MOVLB  F
2BA6:  MOVLW  55
2BA8:  MOVWF  FA7
2BAA:  MOVLW  AA
2BAC:  MOVWF  FA7
2BAE:  BSF    FA6.1
2BB0:  BTFSC  FA6.1
2BB2:  BRA    2BB0
2BB4:  BCF    FA6.2
2BB6:  MOVF   00,W
2BB8:  IORWF  FF2,F
....................    limpiar();//pone en 0 el registro de cuentas almacenadas. 
2BBA:  MOVLB  0
2BBC:  CALL   0CF0
2BC0:  MOVLB  1
.................... } 
....................  
.................... //llaves();//Graba instrucciones de control en eeprom 
.................... ///////////////////////////////lee que tienen la memoria eeprom////////////////////////////////// 
.................... //rd_eeprom_inicio(); 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... entraron_total();//carga el total de entradas registradas 
2BC2:  MOVLB  0
2BC4:  GOTO   0D5C
.................... salieron_total();//carga el total de salidas registradas 
2BC8:  GOTO   0DB6
.................... ent1=ent2=ent3=ent4=ent5=ent6=0;//inicia en 0 variables de estado de sensores 
2BCC:  CLRF   5A
2BCE:  MOVFF  5A,59
2BD2:  MOVFF  59,58
2BD6:  MOVFF  58,57
2BDA:  MOVFF  57,56
2BDE:  MOVFF  56,55
.................... tim_p1=tim_p2=tim_p3=0;//inicia en 0 las cuentas para detectar sensores bloqueados 
2BE2:  CLRF   xA6
2BE4:  CLRF   xA5
2BE6:  MOVFF  A6,A4
2BEA:  MOVFF  A5,A3
2BEE:  MOVFF  A4,A2
2BF2:  MOVFF  A3,A1
.................... en_b1=en_b2=en_b3=0;//bandera de pares bloqueados 
2BF6:  CLRF   xA0
2BF8:  MOVFF  A0,9F
2BFC:  MOVFF  9F,9E
.................... time_envio=0;//inicia en 0 cuenta para transmitir datos 
2C00:  CLRF   xAA
2C02:  CLRF   xA9
.................... if(input(frente) ) {//revisa si es maestro (1) o escalvo (2) 
2C04:  BSF    F95.2
2C06:  BTFSS  F83.2
2C08:  BRA    2C14
....................    master=1; 
2C0A:  MOVLW  01
2C0C:  MOVWF  45
....................    size_s=29; 
2C0E:  MOVLW  1D
2C10:  MOVWF  22
.................... } 
2C12:  BRA    2C1A
.................... else { 
....................    master=0; 
2C14:  CLRF   45
....................    size_s=15; 
2C16:  MOVLW  0F
2C18:  MOVWF  22
.................... } 
.................... lcd_cuentas();//Escribe texto base en LCD 
2C1A:  CALL   0A38
.................... cta_bloq1=read_ext_eeprom(9);//carga bloqueos acumulados en par1 
2C1E:  MOVLB  1
2C20:  CLRF   x8E
2C22:  MOVLW  09
2C24:  MOVWF  x8D
2C26:  MOVLB  0
2C28:  CALL   0748
2C2C:  MOVFF  01,52
.................... cta_bloq2=read_ext_eeprom(10);//carga bloqueos acumulados en par2 
2C30:  MOVLB  1
2C32:  CLRF   x8E
2C34:  MOVLW  0A
2C36:  MOVWF  x8D
2C38:  MOVLB  0
2C3A:  CALL   0748
2C3E:  MOVFF  01,53
.................... cta_bloq3=read_ext_eeprom(11);//carga bloqueos acumulados en par3 
2C42:  MOVLB  1
2C44:  CLRF   x8E
2C46:  MOVLW  0B
2C48:  MOVWF  x8D
2C4A:  MOVLB  0
2C4C:  CALL   0748
2C50:  MOVFF  01,54
.................... int tem_res; 
.................... tem_res=input(rst_cta);//inicializa variable de reset de cuenta fisico 
2C54:  BSF    F95.3
2C56:  MOVLB  1
2C58:  CLRF   x87
2C5A:  BTFSC  F83.3
2C5C:  INCF   x87,F
.................... j=0; 
2C5E:  CLRF   43
.................... flag_enviar=0; 
2C60:  CLRF   46
.................... salian=0; 
2C62:  CLRF   3D
2C64:  CLRF   3C
.................... enable_interrupts(INT_RDA);//habilita interrupcion serial 
2C66:  BSF    F9D.5
.................... setup_wdt(WDT_ON);//habilita watch dog 
2C68:  BSF    FD1.0
.................... sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
2C6A:  MOVLB  0
2C6C:  CLRF   x68
2C6E:  CLRF   x67
2C70:  MOVFF  68,66
2C74:  MOVFF  67,65
2C78:  MOVFF  66,64
2C7C:  MOVFF  65,63
2C80:  MOVFF  64,62
2C84:  MOVFF  63,61
2C88:  MOVFF  62,60
2C8C:  MOVFF  61,5F
2C90:  MOVFF  60,5E
2C94:  MOVFF  5F,5D
.................... tem_entraront=tem_salieront=0; 
2C98:  CLRF   x95
2C9A:  CLRF   x94
2C9C:  MOVFF  95,93
2CA0:  MOVFF  94,92
.................... error=0; 
2CA4:  CLRF   23
.................... reset();//Revisa causa de inicio del pic 
2CA6:  GOTO   0E32
.................... transmitir=0; 
2CAA:  CLRF   24
.................... output_low(salida02); 
2CAC:  BCF    F94.4
2CAE:  BCF    F8B.4
.................... sub_atras=baj_atras=0; 
2CB0:  CLRF   37
2CB2:  CLRF   36
2CB4:  MOVFF  37,35
2CB8:  MOVFF  36,34
.................... clear_lcd1=0; 
2CBC:  CLRF   xAB
....................  
.................... output_low(HB); 
2CBE:  BCF    F96.0
2CC0:  BCF    F8D.0
.................... bandera_revision=1; 
2CC2:  MOVLW  01
2CC4:  MOVWF  xAE
....................  
.................... while(TRUE){ 
.................... ///////////////////////preuba comunicacion serial con poste trasero/////////////// 
....................  //fprintf(monitor,"SOLICITADO");//4 
....................  //delay_ms(100); 
....................  if(y==1){ 
2CC6:  DECFSZ xAD,W
2CC8:  BRA    2CD0
....................   //fprintf(monitor,"XX=%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6]); 
....................   //fprintf(monitor,"XX=%s",XX); 
....................   enable_interrupts(GLOBAL);//habilita interrupciones globales 
2CCA:  MOVLW  C0
2CCC:  IORWF  FF2,F
....................   y=0; 
2CCE:  CLRF   xAD
....................  } 
....................   
.................... ////////////////////////////////////////////////////////////////////////////////// 
....................    if(tem_res!=input(rst_cta) ){//BOTON DE RESET DE CUENTA 
2CD0:  BSF    F95.3
2CD2:  MOVLW  00
2CD4:  BTFSC  F83.3
2CD6:  MOVLW  01
2CD8:  MOVLB  1
2CDA:  SUBWF  x87,W
2CDC:  BZ    2D26
....................       delay_ms(50); 
2CDE:  MOVLW  32
2CE0:  MOVWF  x93
2CE2:  MOVLB  0
2CE4:  CALL   03DE
....................       if(tem_res!=input(rst_cta) ){ 
2CE8:  BSF    F95.3
2CEA:  MOVLW  00
2CEC:  BTFSC  F83.3
2CEE:  MOVLW  01
2CF0:  MOVLB  1
2CF2:  SUBWF  x87,W
2CF4:  BZ    2D26
....................          tem_res=input(rst_cta); 
2CF6:  BSF    F95.3
2CF8:  CLRF   x87
2CFA:  BTFSC  F83.3
2CFC:  INCF   x87,F
....................          if( (master==1)&&(tem_res==0) ) { 
2CFE:  DECFSZ 45,W
2D00:  BRA    2D26
2D02:  MOVF   x87,F
2D04:  BNZ   2D26
....................             fprintf(monitor,"BORRAR_ALL\r"); 
2D06:  MOVLW  6E
2D08:  MOVWF  FF6
2D0A:  MOVLW  02
2D0C:  MOVWF  FF7
2D0E:  MOVLB  0
2D10:  CALL   0E10
....................             printf(lcd_putc,"\fBORRAR_ALL"); 
2D14:  MOVLW  7A
2D16:  MOVWF  FF6
2D18:  MOVLW  02
2D1A:  MOVWF  FF7
2D1C:  CALL   0A18
....................             limpiar(); 
2D20:  CALL   0CF0
2D24:  MOVLB  1
....................          } 
....................       } 
....................    } 
.................... //!    
.................... /* 
....................    if( kbhit(GPS) && master ){//escucha gsm 
....................        i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................        XX[i] = fgetc(GPS); 
....................        i++; 
....................        if( (XX[0]>=65)&&(XX[0]<=90) ){//validar no sea ruido 
....................           while (i <= word_size){ 
....................                 XX[i] = fgetc(GPS); 
....................                 i++; 
....................           } 
....................           if(XX[1]=='R') XX[0]='G'; 
....................           j=1; 
....................        }/// 
....................       // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................    }//end gps 
.................... //! 
.................... */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... if(input(EN) == 1  && bandera_revision == 1){ 
2D26:  BSF    F96.1
2D28:  BTFSS  F84.1
2D2A:  BRA    2DDC
2D2C:  MOVLB  0
2D2E:  DECFSZ xAE,W
2D30:  BRA    2D34
2D32:  BRA    2D38
2D34:  MOVLB  1
2D36:  BRA    2DDC
....................   output_high(HB); 
2D38:  BCF    F96.0
2D3A:  BSF    F8D.0
....................   cntbnd=0;  
2D3C:  CLRF   xB0
2D3E:  CLRF   xAF
....................   bandera_revision=0; 
2D40:  CLRF   xAE
....................   output_high(salida03); 
2D42:  BCF    F94.5
2D44:  BSF    F8B.5
....................   //lcd_gotoxy(12,1); 
....................    //printf(lcd_putc,"Recibi bandera"); 
....................   //while(kbhit(GPS) != 1); 
.................... // delay_ms(200); 
.................... while (kbhit(GPS)!=1 || cntbnd >= 200) 
2D46:  MOVLW  00
2D48:  BTFSS  F82.1
2D4A:  MOVLW  01
2D4C:  SUBLW  01
2D4E:  BNZ   2D5A
2D50:  MOVF   xB0,F
2D52:  BNZ   2D5A
2D54:  MOVF   xAF,W
2D56:  SUBLW  C7
2D58:  BC    2D60
.................... { 
....................   // lcd_gotoxy(12,2); 
....................   // printf(lcd_putc,"WT"); 
....................   bandera_revision=1; 
2D5A:  MOVLW  01
2D5C:  MOVWF  xAE
2D5E:  BRA    2D46
.................... } 
....................   // lcd_gotoxy(12,3); 
....................   // printf(lcd_putc,"%x",fgetc(GPS)); 
....................   XX[0] = fgetc(GPS); 
2D60:  GOTO   0E6A
2D64:  MOVFF  01,151
....................  // lcd_gotoxy(12,3); 
....................   //printf(lcd_putc,"%c",XX[0]); 
....................   if(XX[0]==63) 
2D68:  MOVLB  1
2D6A:  MOVF   x51,W
2D6C:  SUBLW  3F
2D6E:  BNZ   2DDC
....................   { 
....................   output_low(salida03); 
2D70:  BCF    F94.5
2D72:  BCF    F8B.5
....................       j=1; 
2D74:  MOVLW  01
2D76:  MOVWF  43
....................       sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
2D78:  MOVLB  0
2D7A:  CLRF   x68
2D7C:  CLRF   x67
2D7E:  MOVFF  68,66
2D82:  MOVFF  67,65
2D86:  MOVFF  66,64
2D8A:  MOVFF  65,63
2D8E:  MOVFF  64,62
2D92:  MOVFF  63,61
2D96:  MOVFF  62,60
2D9A:  MOVFF  61,5F
2D9E:  MOVFF  60,5E
2DA2:  MOVFF  5F,5D
....................       XX[0] = 'B'; 
2DA6:  MOVLW  42
2DA8:  MOVLB  1
2DAA:  MOVWF  x51
....................       XX[1] = 'O'; 
2DAC:  MOVLW  4F
2DAE:  MOVWF  x52
....................       XX[2] = 'R'; 
2DB0:  MOVLW  52
2DB2:  MOVWF  x53
....................       XX[3] = 'R'; 
2DB4:  MOVWF  x54
....................       XX[4] = 'A'; 
2DB6:  MOVLW  41
2DB8:  MOVWF  x55
....................       XX[5] = 'R'; 
2DBA:  MOVLW  52
2DBC:  MOVWF  x56
....................       XX[6] = '_'; 
2DBE:  MOVLW  5F
2DC0:  MOVWF  x57
....................       XX[7] = 'A'; 
2DC2:  MOVLW  41
2DC4:  MOVWF  x58
....................       XX[8] = 'L'; 
2DC6:  MOVLW  4C
2DC8:  MOVWF  x59
....................       XX[9] = 'L'; 
2DCA:  MOVWF  x5A
....................       XX[10] = '\n'; 
2DCC:  MOVLW  0A
2DCE:  MOVWF  x5B
....................       output_low(HB); 
2DD0:  BCF    F96.0
2DD2:  BCF    F8D.0
....................       bandera_revision=1; 
2DD4:  MOVLW  01
2DD6:  MOVLB  0
2DD8:  MOVWF  xAE
2DDA:  MOVLB  1
....................   } 
....................   
....................  /* 
....................    if( kbhit(GPS) && master ){//escucha gsm 
....................        //for (i=0;i<=10;++i){ 
....................       // lcd_gotoxy(12,3); 
....................        //printf(lcd_putc,"%c",fgetc(GPS)); 
....................         i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................         XX[i] = fgetc(GPS); 
....................          
....................        //i++; 
....................       // } 
....................        lcd_gotoxy(1,4); 
....................        printf(lcd_putc,"%c%c%c%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6],XX[7],XX[8],XX[9]); 
....................        if( (XX[0]>=65)&&(XX[0]<=90) ){//validar no sea ruido 
....................           while (i <= word_size){ 
....................                 XX[i] = fgetc(GPS); 
....................                 i++; 
....................           } 
....................           if(XX[1]=='R') XX[0]='G'; 
....................           j=1; 
....................        }/// 
....................        sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................    }//end gps 
....................    */ 
....................     
.................... } 
....................  //------------------------------------------------------------------------------  
....................  
....................    if(j==1){//Revisa si hubo datos por cualquiera de los 2 puertos seriales 
2DDC:  DECFSZ 43,W
2DDE:  BRA    2F7E
....................        
....................       // fprintf(monitor,"%s",XX);//4 
....................        
....................       rd_eeprom();//valida dato recibido para ver si es una palabra de control 
2DE0:  MOVLB  0
2DE2:  GOTO   0EE2
....................       //int caso_valor = evaluar_string("BORRAR_ALL\r"); 
....................       //fprintf(monitor,"XX:%s",XX); 
....................       int caso_valor = evaluar_string(XX); 
2DE6:  MOVLW  01
2DE8:  MOVLB  1
2DEA:  MOVWF  x8A
2DEC:  MOVLW  51
2DEE:  MOVWF  x89
2DF0:  MOVLB  0
2DF2:  GOTO   1006
2DF6:  MOVFF  01,188
....................       //int caso_valor; 
....................       //evaluar_string('B'); 
....................       //char textosearch[]= "PASAJEROS:"; 
....................      // fprintf(monitor,"compare = %s", strstr(XX,textosearch)); 
....................       //if((strstr(XX,textosearch))==0)b=5; 
....................       lcd_gotoxy(9,1); 
2DFA:  MOVLW  09
2DFC:  MOVLB  1
2DFE:  MOVWF  x93
2E00:  MOVLW  01
2E02:  MOVWF  x94
2E04:  MOVLB  0
2E06:  CALL   0842
....................       //printf(lcd_putc,"%Ld ",b);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................       printf(lcd_putc,"%d ",caso_valor);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
2E0A:  MOVFF  188,189
2E0E:  MOVLW  18
2E10:  MOVLB  1
2E12:  MOVWF  x8A
2E14:  MOVLB  0
2E16:  CALL   10DA
2E1A:  MOVLW  20
2E1C:  MOVLB  1
2E1E:  MOVWF  x92
2E20:  MOVLB  0
2E22:  CALL   0894
....................  
....................        
....................       //switch (b) { 
....................       switch (caso_valor) { 
2E26:  MOVLW  01
2E28:  MOVLB  1
2E2A:  SUBWF  x88,W
2E2C:  ADDLW  F8
2E2E:  BTFSC  FD8.0
2E30:  BRA    2F5C
2E32:  ADDLW  08
2E34:  MOVLB  0
2E36:  GOTO   31B4
....................           case 1: {//Se pone en 0 la cuenta 
....................                   limpiar(); 
2E3A:  CALL   0CF0
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
2E3E:  DECFSZ 45,W
2E40:  BRA    2E4E
2E42:  MOVLW  86
2E44:  MOVWF  FF6
2E46:  MOVLW  02
2E48:  MOVWF  FF7
2E4A:  CALL   0E10
....................                   break;} 
2E4E:  MOVLB  1
2E50:  BRA    2F5C
2E52:  MOVLB  0
....................           case 2: {//Se hace solicitud de cuenta del poste trasero 
....................                   solicitar(); 
2E54:  CALL   119E
....................                   break;} 
2E58:  MOVLB  1
2E5A:  BRA    2F5C
2E5C:  MOVLB  0
....................           case 3: {//Se pone en 0 la cuenta por peticion del GPRS 
....................                   if(master==1) fprintf(GPS,"RESET_OK\r\n");//confirma a gsm  
2E5E:  DECFSZ 45,W
2E60:  BRA    2E6E
2E62:  MOVLW  92
2E64:  MOVWF  FF6
2E66:  MOVLW  02
2E68:  MOVWF  FF7
2E6A:  GOTO   1204
....................                   delay_ms(1000); 
2E6E:  MOVLW  04
2E70:  MOVLB  1
2E72:  MOVWF  x89
2E74:  MOVLW  FA
2E76:  MOVWF  x93
2E78:  MOVLB  0
2E7A:  CALL   03DE
2E7E:  MOVLB  1
2E80:  DECFSZ x89,F
2E82:  BRA    2E74
....................                   limpiar(); 
2E84:  MOVLB  0
2E86:  CALL   0CF0
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
2E8A:  DECFSZ 45,W
2E8C:  BRA    2E9A
2E8E:  MOVLW  9E
2E90:  MOVWF  FF6
2E92:  MOVLW  02
2E94:  MOVWF  FF7
2E96:  CALL   0E10
....................                   break;} 
2E9A:  MOVLB  1
2E9C:  BRA    2F5C
2E9E:  MOVLB  0
....................           case 4: {//ver pasaje total de este acceso (contador atras) 
....................                   envio_master(); 
2EA0:  CALL   1226
....................                   break;} 
2EA4:  MOVLB  1
2EA6:  BRA    2F5C
2EA8:  MOVLB  0
....................           case 5: {//envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................                   flag_enviar=0; 
2EAA:  CLRF   46
....................                   enviop1(); 
2EAC:  GOTO   1296
....................                   transmitir=1; 
2EB0:  MOVLW  01
2EB2:  MOVWF  24
....................                   lcd_gotoxy(9,4); 
2EB4:  MOVLW  09
2EB6:  MOVLB  1
2EB8:  MOVWF  x93
2EBA:  MOVLW  04
2EBC:  MOVWF  x94
2EBE:  MOVLB  0
2EC0:  CALL   0842
....................                   lcd_putc("C2OK"); 
2EC4:  MOVLW  AA
2EC6:  MOVWF  FF6
2EC8:  MOVLW  02
2ECA:  MOVWF  FF7
2ECC:  CALL   0A18
....................                   break;} 
2ED0:  MOVLB  1
2ED2:  BRA    2F5C
2ED4:  MOVLB  0
....................           case 6: {//TEST DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
2ED6:  MOVLW  01
2ED8:  MOVWF  xAB
....................                   time_lcd1=0; 
2EDA:  CLRF   xAC
....................                   lcd_gotoxy(9,3); 
2EDC:  MOVLW  09
2EDE:  MOVLB  1
2EE0:  MOVWF  x93
2EE2:  MOVLW  03
2EE4:  MOVWF  x94
2EE6:  MOVLB  0
2EE8:  CALL   0842
....................                   lcd_putc("C1OK"); 
2EEC:  MOVLW  B0
2EEE:  MOVWF  FF6
2EF0:  MOVLW  02
2EF2:  MOVWF  FF7
2EF4:  CALL   0A18
....................                   fprintf(monitor,"SERIAL_TOK\r");// 
2EF8:  MOVLW  B6
2EFA:  MOVWF  FF6
2EFC:  MOVLW  02
2EFE:  MOVWF  FF7
2F00:  CALL   0E10
....................                   break;} 
2F04:  MOVLB  1
2F06:  BRA    2F5C
2F08:  MOVLB  0
....................           case 7: {//CONFIRMACION DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
2F0A:  MOVLW  01
2F0C:  MOVWF  xAB
....................                   time_lcd1=0; 
2F0E:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
2F10:  MOVLW  09
2F12:  MOVLB  1
2F14:  MOVWF  x93
2F16:  MOVLW  04
2F18:  MOVWF  x94
2F1A:  MOVLB  0
2F1C:  CALL   0842
....................                   lcd_putc("C2OK"); 
2F20:  MOVLW  C2
2F22:  MOVWF  FF6
2F24:  MOVLW  02
2F26:  MOVWF  FF7
2F28:  CALL   0A18
....................                   break;} 
2F2C:  MOVLB  1
2F2E:  BRA    2F5C
2F30:  MOVLB  0
....................           case 8: {//Suben por atras 
....................                   clear_lcd1=1; 
2F32:  MOVLW  01
2F34:  MOVWF  xAB
....................                   time_lcd1=0; 
2F36:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
2F38:  MOVLW  09
2F3A:  MOVLB  1
2F3C:  MOVWF  x93
2F3E:  MOVLW  04
2F40:  MOVWF  x94
2F42:  MOVLB  0
2F44:  CALL   0842
....................                   lcd_putc("Sub2"); 
2F48:  MOVLW  C8
2F4A:  MOVWF  FF6
2F4C:  MOVLW  02
2F4E:  MOVWF  FF7
2F50:  CALL   0A18
....................                   break;} 
2F54:  MOVLB  1
2F56:  BRA    2F5C
2F58:  MOVLB  0
2F5A:  MOVLB  1
....................       }//end switch 
....................       memset(XX, 0, sizeof(XX) ); 
2F5C:  MOVLW  01
2F5E:  MOVWF  FEA
2F60:  MOVLW  51
2F62:  MOVWF  FE9
2F64:  CLRF   00
2F66:  CLRF   02
2F68:  MOVLW  1D
2F6A:  MOVWF  01
2F6C:  MOVLB  0
2F6E:  CALL   127C
....................       time_clr=0; 
2F72:  CLRF   3F
2F74:  CLRF   3E
....................       f_clr=1; 
2F76:  MOVLW  01
2F78:  MOVWF  47
....................       j=0; 
2F7A:  CLRF   43
2F7C:  MOVLB  1
....................    } 
....................    //if( (time_envio>=180)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................     if( (time_envio>=10)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
2F7E:  MOVLB  0
2F80:  MOVF   xAA,F
2F82:  BNZ   2F8A
2F84:  MOVF   xA9,W
2F86:  SUBLW  09
2F88:  BC    2F92
2F8A:  MOVF   45,F
2F8C:  BZ    2F92
....................          solicitar(); 
2F8E:  CALL   119E
....................          
....................    } 
....................    if( (clear_lcd1)&&(time_lcd1>=10) ){//cronometro para limpiar notificaciones LCD 
2F92:  MOVF   xAB,F
2F94:  BZ    2FF2
2F96:  MOVF   xAC,W
2F98:  SUBLW  09
2F9A:  BC    2FF2
....................       clear_lcd1=0; 
2F9C:  CLRF   xAB
....................       lcd_gotoxy(9,1); 
2F9E:  MOVLW  09
2FA0:  MOVLB  1
2FA2:  MOVWF  x93
2FA4:  MOVLW  01
2FA6:  MOVWF  x94
2FA8:  MOVLB  0
2FAA:  CALL   0842
....................       lcd_putc("    "); 
2FAE:  MOVLW  CE
2FB0:  MOVWF  FF6
2FB2:  MOVLW  02
2FB4:  MOVWF  FF7
2FB6:  CALL   0A18
....................       lcd_gotoxy(9,3); 
2FBA:  MOVLW  09
2FBC:  MOVLB  1
2FBE:  MOVWF  x93
2FC0:  MOVLW  03
2FC2:  MOVWF  x94
2FC4:  MOVLB  0
2FC6:  CALL   0842
....................       lcd_putc("    "); 
2FCA:  MOVLW  D4
2FCC:  MOVWF  FF6
2FCE:  MOVLW  02
2FD0:  MOVWF  FF7
2FD2:  CALL   0A18
....................       lcd_gotoxy(9,4); 
2FD6:  MOVLW  09
2FD8:  MOVLB  1
2FDA:  MOVWF  x93
2FDC:  MOVLW  04
2FDE:  MOVWF  x94
2FE0:  MOVLB  0
2FE2:  CALL   0842
....................       lcd_putc("    "); 
2FE6:  MOVLW  DA
2FE8:  MOVWF  FF6
2FEA:  MOVLW  02
2FEC:  MOVWF  FF7
2FEE:  CALL   0A18
....................    } 
....................     
....................    if( (flag_enviar)&&(cta_enviar>=2000)&&(master) ) envia2();//Si el poste esclavo no contesta enviar sin conexion 
2FF2:  MOVF   46,F
2FF4:  BZ    300E
2FF6:  MOVF   4F,W
2FF8:  SUBLW  06
2FFA:  BC    300E
2FFC:  XORLW  FF
2FFE:  BNZ   3006
3000:  MOVF   4E,W
3002:  SUBLW  CF
3004:  BC    300E
3006:  MOVF   45,F
3008:  BTFSS  FD8.2
300A:  GOTO   157E
....................    if(transmitir) envio();//cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
300E:  MOVF   24,F
3010:  BTFSC  FD8.2
3012:  BRA    3018
3014:  GOTO   1774
....................     
....................    if( (bloq_p1)&&(tim_p1>=time_bloqueo)&&(!en_b1) ) {//bloqueo de par 1 por ms de X segundos 
3018:  MOVF   x9B,F
301A:  BZ    3088
301C:  MOVF   xA2,W
301E:  SUBLW  00
3020:  BC    3088
3022:  XORLW  FF
3024:  BNZ   302C
3026:  MOVF   xA1,W
3028:  SUBLW  F3
302A:  BC    3088
302C:  MOVF   x9E,F
302E:  BNZ   3088
....................        bloq_p1=0;//bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
3030:  CLRF   x9B
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){//si no habia un bloqueo antes 
3032:  MOVF   x9E,F
3034:  BNZ   3084
3036:  MOVF   x9F,F
3038:  BNZ   3084
303A:  MOVF   xA0,F
303C:  BNZ   3084
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
303E:  MOVLW  0A
3040:  MOVLB  1
3042:  MOVWF  x93
3044:  MOVLW  01
3046:  MOVWF  x94
3048:  MOVLB  0
304A:  CALL   0842
....................             lcd_putc("BL"); 
304E:  MOVLW  E0
3050:  MOVWF  FF6
3052:  MOVLW  02
3054:  MOVWF  FF7
3056:  CALL   0A18
....................             cta_bloq1++; 
305A:  INCF   52,F
....................             write_ext_eeprom(9,cta_bloq1);//bloq1 
305C:  MOVLB  1
305E:  CLRF   x8E
3060:  MOVLW  09
3062:  MOVWF  x8D
3064:  MOVFF  52,18F
3068:  MOVLB  0
306A:  CALL   0588
....................             if( (master==1)&&(j==0) ) solicitar(); 
306E:  DECFSZ 45,W
3070:  BRA    307C
3072:  MOVF   43,F
3074:  BNZ   307C
3076:  CALL   119E
307A:  BRA    3084
....................             else if(j==0) envio_master(); 
307C:  MOVF   43,F
307E:  BTFSC  FD8.2
3080:  CALL   1226
....................        } 
....................        en_b1=1;//bandera de bloqueo detectado en par 1 
3084:  MOVLW  01
3086:  MOVWF  x9E
....................    } 
....................    if( (bloq_p2)&&(tim_p2>=time_bloqueo)&&(!en_b2) ) {//bloqueo de par 2 por ms de X segundos 
3088:  MOVF   x9C,F
308A:  BZ    30F8
308C:  MOVF   xA4,W
308E:  SUBLW  00
3090:  BC    30F8
3092:  XORLW  FF
3094:  BNZ   309C
3096:  MOVF   xA3,W
3098:  SUBLW  F3
309A:  BC    30F8
309C:  MOVF   x9F,F
309E:  BNZ   30F8
....................        bloq_p2=0; 
30A0:  CLRF   x9C
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
30A2:  MOVF   x9E,F
30A4:  BNZ   30F4
30A6:  MOVF   x9F,F
30A8:  BNZ   30F4
30AA:  MOVF   xA0,F
30AC:  BNZ   30F4
....................            lcd_gotoxy(10,1);//cronometro para limpiar 
30AE:  MOVLW  0A
30B0:  MOVLB  1
30B2:  MOVWF  x93
30B4:  MOVLW  01
30B6:  MOVWF  x94
30B8:  MOVLB  0
30BA:  CALL   0842
....................            lcd_putc("BL"); 
30BE:  MOVLW  E4
30C0:  MOVWF  FF6
30C2:  MOVLW  02
30C4:  MOVWF  FF7
30C6:  CALL   0A18
....................            cta_bloq2++; 
30CA:  INCF   53,F
....................            write_ext_eeprom(10,cta_bloq2);//bloq2 
30CC:  MOVLB  1
30CE:  CLRF   x8E
30D0:  MOVLW  0A
30D2:  MOVWF  x8D
30D4:  MOVFF  53,18F
30D8:  MOVLB  0
30DA:  CALL   0588
....................            if( (master==1)&&(j==0) ) solicitar(); 
30DE:  DECFSZ 45,W
30E0:  BRA    30EC
30E2:  MOVF   43,F
30E4:  BNZ   30EC
30E6:  CALL   119E
30EA:  BRA    30F4
....................            else if(j==0) envio_master(); 
30EC:  MOVF   43,F
30EE:  BTFSC  FD8.2
30F0:  CALL   1226
....................        } 
....................        en_b2=1; 
30F4:  MOVLW  01
30F6:  MOVWF  x9F
....................    } 
....................    if( (bloq_p3)&&(tim_p3>=time_bloqueo)&&(!en_b3) ) {//bloqueo de par 3 por ms de X segundos 
30F8:  MOVF   x9D,F
30FA:  BZ    3168
30FC:  MOVF   xA6,W
30FE:  SUBLW  00
3100:  BC    3168
3102:  XORLW  FF
3104:  BNZ   310C
3106:  MOVF   xA5,W
3108:  SUBLW  F3
310A:  BC    3168
310C:  MOVF   xA0,F
310E:  BNZ   3168
....................        bloq_p3=0; 
3110:  CLRF   x9D
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3112:  MOVF   x9E,F
3114:  BNZ   3164
3116:  MOVF   x9F,F
3118:  BNZ   3164
311A:  MOVF   xA0,F
311C:  BNZ   3164
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
311E:  MOVLW  0A
3120:  MOVLB  1
3122:  MOVWF  x93
3124:  MOVLW  01
3126:  MOVWF  x94
3128:  MOVLB  0
312A:  CALL   0842
....................             lcd_putc("BL"); 
312E:  MOVLW  E8
3130:  MOVWF  FF6
3132:  MOVLW  02
3134:  MOVWF  FF7
3136:  CALL   0A18
....................             cta_bloq3++; 
313A:  INCF   54,F
....................             write_ext_eeprom(11,cta_bloq3);//bloq3 
313C:  MOVLB  1
313E:  CLRF   x8E
3140:  MOVLW  0B
3142:  MOVWF  x8D
3144:  MOVFF  54,18F
3148:  MOVLB  0
314A:  CALL   0588
....................             if( (master==1)&&(j==0) ) solicitar(); 
314E:  DECFSZ 45,W
3150:  BRA    315C
3152:  MOVF   43,F
3154:  BNZ   315C
3156:  CALL   119E
315A:  BRA    3164
....................             else if(j==0) envio_master(); 
315C:  MOVF   43,F
315E:  BTFSC  FD8.2
3160:  CALL   1226
....................        } 
....................        en_b3=1; 
3164:  MOVLW  01
3166:  MOVWF  xA0
....................    }//end deteccion 
....................    if( (!bloq_p3)&&(!bloq_p2)&&(!bloq_p1) ){//Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
3168:  MOVF   x9D,F
316A:  BNZ   3190
316C:  MOVF   x9C,F
316E:  BNZ   3190
3170:  MOVF   x9B,F
3172:  BNZ   3190
....................       lcd_gotoxy(10,1); 
3174:  MOVLW  0A
3176:  MOVLB  1
3178:  MOVWF  x93
317A:  MOVLW  01
317C:  MOVWF  x94
317E:  MOVLB  0
3180:  CALL   0842
....................       lcd_putc("  "); 
3184:  MOVLW  EC
3186:  MOVWF  FF6
3188:  MOVLW  02
318A:  MOVWF  FF7
318C:  CALL   0A18
....................    } 
....................     
....................    if( (time_clr>=900)&&(f_clr) ){//refresca LCD 
3190:  MOVF   3F,W
3192:  SUBLW  02
3194:  BC    31AA
3196:  XORLW  FF
3198:  BNZ   31A0
319A:  MOVF   3E,W
319C:  SUBLW  83
319E:  BC    31AA
31A0:  MOVF   47,F
31A2:  BZ    31AA
....................         lcd_cuentas(); 
31A4:  CALL   0A38
....................          f_clr=0; 
31A8:  CLRF   47
....................    } 
....................    sensores();//Revisa estado de los sensores 
31AA:  GOTO   2612
....................        
....................    restart_wdt(); 
31AE:  CLRWDT
31B0:  BRA    2CC6
....................  }//end true 
.................... }//end main 
....................  
31B2:  SLEEP 
.................... void solicitar(){//Solicita cuenta al poste esclavo 
....................    fprintf(monitor,"SOLICITADO\r");//4 
*
119E:  MOVLW  F0
11A0:  MOVWF  FF6
11A2:  MOVLW  02
11A4:  MOVWF  FF7
11A6:  RCALL  0E10
....................    time_envio=0; 
11A8:  CLRF   xAA
11AA:  CLRF   xA9
....................    flag_enviar=1; 
11AC:  MOVLW  01
11AE:  MOVWF  46
....................    cta_enviar=0; 
11B0:  CLRF   4F
11B2:  CLRF   4E
11B4:  RETURN 0
.................... } 
....................  
.................... void envio_master(){//reporta al maestro 
....................     int16 envit; 
....................     envit=(entraront + salieront)/2; 
*
1226:  MOVF   x8C,W
1228:  ADDWF  x8A,W
122A:  MOVLB  1
122C:  MOVWF  x8B
122E:  MOVLB  0
1230:  MOVF   x8D,W
1232:  ADDWFC x8B,W
1234:  MOVLB  1
1236:  MOVWF  x8C
1238:  BCF    FD8.0
123A:  RRCF   x8C,W
123C:  MOVWF  x8A
123E:  RRCF   x8B,W
1240:  MOVWF  x89
....................     cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1242:  MOVF   53,W
1244:  ADDWF  52,W
1246:  ADDWF  54,W
1248:  MOVWF  4C
124A:  CLRF   4D
....................     clear_lcd1=1; 
124C:  MOVLW  01
124E:  MOVLB  0
1250:  MOVWF  xAB
....................     time_lcd1=0; 
1252:  CLRF   xAC
....................     lcd_gotoxy(9,3);//cronometro para limpiar 
1254:  MOVLW  09
1256:  MOVLB  1
1258:  MOVWF  x93
125A:  MOVLW  03
125C:  MOVWF  x94
125E:  MOVLB  0
1260:  CALL   0842
....................     lcd_putc(0xAB); 
1264:  MOVLW  AB
1266:  MOVLB  1
1268:  MOVWF  x92
126A:  MOVLB  0
126C:  CALL   0894
....................     //fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
....................       fprintf(monitor,"PASAJEROS:\r"); 
1270:  MOVLW  FC
1272:  MOVWF  FF6
1274:  MOVLW  02
1276:  MOVWF  FF7
1278:  RCALL  0E10
127A:  RETURN 0
....................      // fprintf(monitor,"PASAJEROS\r%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
.................... } 
....................  
.................... int convertir_to_entero(char *cadena) { 
*
16CC:  MOVLB  1
16CE:  CLRF   x8B
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
16D0:  MOVF   x89,W
16D2:  SUBLW  30
16D4:  BNZ   16DE
16D6:  MOVF   x8A,F
16D8:  BNZ   16DE
16DA:  CLRF   x8B
16DC:  BRA    176C
....................    else if(cadena=='1') valor=1; 
16DE:  MOVF   x89,W
16E0:  SUBLW  31
16E2:  BNZ   16EE
16E4:  MOVF   x8A,F
16E6:  BNZ   16EE
16E8:  MOVLW  01
16EA:  MOVWF  x8B
16EC:  BRA    176C
....................    else if(cadena=='2') valor=2; 
16EE:  MOVF   x89,W
16F0:  SUBLW  32
16F2:  BNZ   16FE
16F4:  MOVF   x8A,F
16F6:  BNZ   16FE
16F8:  MOVLW  02
16FA:  MOVWF  x8B
16FC:  BRA    176C
....................    else if(cadena=='3') valor=3; 
16FE:  MOVF   x89,W
1700:  SUBLW  33
1702:  BNZ   170E
1704:  MOVF   x8A,F
1706:  BNZ   170E
1708:  MOVLW  03
170A:  MOVWF  x8B
170C:  BRA    176C
....................    else if(cadena=='4') valor=4; 
170E:  MOVF   x89,W
1710:  SUBLW  34
1712:  BNZ   171E
1714:  MOVF   x8A,F
1716:  BNZ   171E
1718:  MOVLW  04
171A:  MOVWF  x8B
171C:  BRA    176C
....................    else if(cadena=='5') valor=5; 
171E:  MOVF   x89,W
1720:  SUBLW  35
1722:  BNZ   172E
1724:  MOVF   x8A,F
1726:  BNZ   172E
1728:  MOVLW  05
172A:  MOVWF  x8B
172C:  BRA    176C
....................    else if(cadena=='6') valor=6; 
172E:  MOVF   x89,W
1730:  SUBLW  36
1732:  BNZ   173E
1734:  MOVF   x8A,F
1736:  BNZ   173E
1738:  MOVLW  06
173A:  MOVWF  x8B
173C:  BRA    176C
....................    else if(cadena=='7') valor=7; 
173E:  MOVF   x89,W
1740:  SUBLW  37
1742:  BNZ   174E
1744:  MOVF   x8A,F
1746:  BNZ   174E
1748:  MOVLW  07
174A:  MOVWF  x8B
174C:  BRA    176C
....................    else if(cadena=='8') valor=8; 
174E:  MOVF   x89,W
1750:  SUBLW  38
1752:  BNZ   175E
1754:  MOVF   x8A,F
1756:  BNZ   175E
1758:  MOVLW  08
175A:  MOVWF  x8B
175C:  BRA    176C
....................    else if(cadena=='9') valor=9; 
175E:  MOVF   x89,W
1760:  SUBLW  39
1762:  BNZ   176C
1764:  MOVF   x8A,F
1766:  BNZ   176C
1768:  MOVLW  09
176A:  MOVWF  x8B
....................    return valor; 
176C:  MOVFF  18B,01
1770:  MOVLB  0
1772:  RETURN 0
.................... } 
....................  
.................... void enviop1(){//Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
1296:  BCF    F9D.5
....................    entran1=0; 
1298:  CLRF   39
129A:  CLRF   38
....................    salen1=0; 
129C:  CLRF   3B
129E:  CLRF   3A
....................    temporal1=0; 
12A0:  CLRF   2F
12A2:  CLRF   2E
....................    temporal2=0; 
12A4:  CLRF   31
12A6:  CLRF   30
....................    temporal3=0; 
12A8:  CLRF   x97
12AA:  CLRF   x96
....................    tempo_tn=0; 
12AC:  CLRF   33
12AE:  CLRF   32
....................    pasajet=0; 
12B0:  CLRF   x91
12B2:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));//entran=0; 
12B4:  MOVLW  01
12B6:  MOVWF  FEA
12B8:  MOVLW  6E
12BA:  MOVWF  FE9
12BC:  CLRF   00
12BE:  CLRF   02
12C0:  MOVLW  04
12C2:  MOVWF  01
12C4:  RCALL  127C
....................    memset(salen, 0, sizeof(salen));//salen=0; 
12C6:  MOVLW  01
12C8:  MOVWF  FEA
12CA:  MOVLW  72
12CC:  MOVWF  FE9
12CE:  CLRF   00
12D0:  CLRF   02
12D2:  MOVLW  04
12D4:  MOVWF  01
12D6:  RCALL  127C
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
12D8:  MOVLW  01
12DA:  MOVWF  FEA
12DC:  MOVLW  76
12DE:  MOVWF  FE9
12E0:  CLRF   00
12E2:  CLRF   02
12E4:  MOVLW  03
12E6:  MOVWF  01
12E8:  RCALL  127C
....................    memset(bloqueado, 0, sizeof(tempo_tc));//total 
12EA:  MOVLW  01
12EC:  MOVWF  FEA
12EE:  MOVLW  76
12F0:  MOVWF  FE9
12F2:  CLRF   00
12F4:  CLRF   02
12F6:  MOVLW  04
12F8:  MOVWF  01
12FA:  RCALL  127C
....................    i=10; 
12FC:  MOVLW  0A
12FE:  MOVWF  41
....................    ii=0; 
1300:  CLRF   42
....................    for(ii=0;ii<=3;ii++)  entran[ii]=XX[10 +ii]; 
1302:  CLRF   42
1304:  MOVF   42,W
1306:  SUBLW  03
1308:  BNC   1346
130A:  CLRF   03
130C:  MOVF   42,W
130E:  ADDLW  6E
1310:  MOVWF  01
1312:  MOVLW  01
1314:  ADDWFC 03,F
1316:  MOVFF  01,189
131A:  MOVLB  1
131C:  MOVFF  03,18A
1320:  MOVLW  0A
1322:  ADDWF  42,W
1324:  CLRF   03
1326:  ADDLW  51
1328:  MOVWF  FE9
132A:  MOVLW  01
132C:  ADDWFC 03,W
132E:  MOVWF  FEA
1330:  MOVFF  FEF,18B
1334:  MOVFF  18A,FEA
1338:  MOVFF  01,FE9
133C:  MOVFF  18B,FEF
1340:  INCF   42,F
1342:  MOVLB  0
1344:  BRA    1304
....................    for(ii=0;ii<=3;ii++)  salen[ii]=XX[15 +ii]; 
1346:  CLRF   42
1348:  MOVF   42,W
134A:  SUBLW  03
134C:  BNC   138A
134E:  CLRF   03
1350:  MOVF   42,W
1352:  ADDLW  72
1354:  MOVWF  01
1356:  MOVLW  01
1358:  ADDWFC 03,F
135A:  MOVFF  01,189
135E:  MOVLB  1
1360:  MOVFF  03,18A
1364:  MOVLW  0F
1366:  ADDWF  42,W
1368:  CLRF   03
136A:  ADDLW  51
136C:  MOVWF  FE9
136E:  MOVLW  01
1370:  ADDWFC 03,W
1372:  MOVWF  FEA
1374:  MOVFF  FEF,18B
1378:  MOVFF  18A,FEA
137C:  MOVFF  01,FE9
1380:  MOVFF  18B,FEF
1384:  INCF   42,F
1386:  MOVLB  0
1388:  BRA    1348
....................    for(ii=0;ii<=2;ii++)  bloqueado[ii]=XX[20 +ii]; 
138A:  CLRF   42
138C:  MOVF   42,W
138E:  SUBLW  02
1390:  BNC   13CE
1392:  CLRF   03
1394:  MOVF   42,W
1396:  ADDLW  76
1398:  MOVWF  01
139A:  MOVLW  01
139C:  ADDWFC 03,F
139E:  MOVFF  01,189
13A2:  MOVLB  1
13A4:  MOVFF  03,18A
13A8:  MOVLW  14
13AA:  ADDWF  42,W
13AC:  CLRF   03
13AE:  ADDLW  51
13B0:  MOVWF  FE9
13B2:  MOVLW  01
13B4:  ADDWFC 03,W
13B6:  MOVWF  FEA
13B8:  MOVFF  FEF,18B
13BC:  MOVFF  18A,FEA
13C0:  MOVFF  01,FE9
13C4:  MOVFF  18B,FEF
13C8:  INCF   42,F
13CA:  MOVLB  0
13CC:  BRA    138C
....................    for(ii=0;ii<=3;ii++)  tempo_tc[ii]=XX[24 +ii]; 
13CE:  CLRF   42
13D0:  MOVF   42,W
13D2:  SUBLW  03
13D4:  BNC   1412
13D6:  CLRF   03
13D8:  MOVF   42,W
13DA:  ADDLW  83
13DC:  MOVWF  01
13DE:  MOVLW  01
13E0:  ADDWFC 03,F
13E2:  MOVFF  01,189
13E6:  MOVLB  1
13E8:  MOVFF  03,18A
13EC:  MOVLW  18
13EE:  ADDWF  42,W
13F0:  CLRF   03
13F2:  ADDLW  51
13F4:  MOVWF  FE9
13F6:  MOVLW  01
13F8:  ADDWFC 03,W
13FA:  MOVWF  FEA
13FC:  MOVFF  FEF,18B
1400:  MOVFF  18A,FEA
1404:  MOVFF  01,FE9
1408:  MOVFF  18B,FEF
140C:  INCF   42,F
140E:  MOVLB  0
1410:  BRA    13D0
1412:  GOTO   2EB0 (RETURN)
.................... //!   lcd_gotoxy(15,3);// 
.................... //!   printf(lcd_putc,"A:%c%c%c%c",tempo_tc[0],tempo_tc[1],tempo_tc[2],tempo_tc[3]); 
.................... } 
....................  
.................... void envio(){//crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................    if(convertir_to_entero(tempo_tc[0]) >0) for(i=0;i< convertir_to_entero(tempo_tc[0]);i++) tempo_tn=tempo_tn+1000; 
*
1774:  MOVLB  1
1776:  CLRF   x8A
1778:  MOVFF  183,189
177C:  MOVLB  0
177E:  RCALL  16CC
1780:  MOVF   01,F
1782:  BZ    17A4
1784:  CLRF   41
1786:  MOVLB  1
1788:  CLRF   x8A
178A:  MOVFF  183,189
178E:  MOVLB  0
1790:  RCALL  16CC
1792:  MOVF   01,W
1794:  SUBWF  41,W
1796:  BC    17A4
1798:  MOVLW  E8
179A:  ADDWF  32,F
179C:  MOVLW  03
179E:  ADDWFC 33,F
17A0:  INCF   41,F
17A2:  BRA    1786
....................    if(convertir_to_entero(tempo_tc[1]) >0) for(i=0;i< convertir_to_entero(tempo_tc[1]);i++) tempo_tn=tempo_tn+100; 
17A4:  MOVLB  1
17A6:  CLRF   x8A
17A8:  MOVFF  184,189
17AC:  MOVLB  0
17AE:  RCALL  16CC
17B0:  MOVF   01,F
17B2:  BZ    17D4
17B4:  CLRF   41
17B6:  MOVLB  1
17B8:  CLRF   x8A
17BA:  MOVFF  184,189
17BE:  MOVLB  0
17C0:  RCALL  16CC
17C2:  MOVF   01,W
17C4:  SUBWF  41,W
17C6:  BC    17D4
17C8:  MOVLW  64
17CA:  ADDWF  32,F
17CC:  MOVLW  00
17CE:  ADDWFC 33,F
17D0:  INCF   41,F
17D2:  BRA    17B6
....................    if(convertir_to_entero(tempo_tc[2]) >0) for(i=0;i< convertir_to_entero(tempo_tc[2]);i++) tempo_tn=tempo_tn+10; 
17D4:  MOVLB  1
17D6:  CLRF   x8A
17D8:  MOVFF  185,189
17DC:  MOVLB  0
17DE:  RCALL  16CC
17E0:  MOVF   01,F
17E2:  BZ    1804
17E4:  CLRF   41
17E6:  MOVLB  1
17E8:  CLRF   x8A
17EA:  MOVFF  185,189
17EE:  MOVLB  0
17F0:  RCALL  16CC
17F2:  MOVF   01,W
17F4:  SUBWF  41,W
17F6:  BC    1804
17F8:  MOVLW  0A
17FA:  ADDWF  32,F
17FC:  MOVLW  00
17FE:  ADDWFC 33,F
1800:  INCF   41,F
1802:  BRA    17E6
....................    tempo_tn=tempo_tn+convertir_to_entero(tempo_tc[3]); 
1804:  MOVLB  1
1806:  CLRF   x8A
1808:  MOVFF  186,189
180C:  MOVLB  0
180E:  RCALL  16CC
1810:  MOVF   01,W
1812:  ADDWF  32,F
1814:  MOVLW  00
1816:  ADDWFC 33,F
....................    //////////////////////////////////////////////////// 
....................    if(convertir_to_entero(entran[0]) >0) for(i=0;i< convertir_to_entero(entran[0]);i++) temporal1=temporal1+1000; 
1818:  MOVLB  1
181A:  CLRF   x8A
181C:  MOVFF  16E,189
1820:  MOVLB  0
1822:  RCALL  16CC
1824:  MOVF   01,F
1826:  BZ    1848
1828:  CLRF   41
182A:  MOVLB  1
182C:  CLRF   x8A
182E:  MOVFF  16E,189
1832:  MOVLB  0
1834:  RCALL  16CC
1836:  MOVF   01,W
1838:  SUBWF  41,W
183A:  BC    1848
183C:  MOVLW  E8
183E:  ADDWF  2E,F
1840:  MOVLW  03
1842:  ADDWFC 2F,F
1844:  INCF   41,F
1846:  BRA    182A
....................    if(convertir_to_entero(entran[1]) >0) for(i=0;i< convertir_to_entero(entran[1]);i++) temporal1=temporal1+100; 
1848:  MOVLB  1
184A:  CLRF   x8A
184C:  MOVFF  16F,189
1850:  MOVLB  0
1852:  RCALL  16CC
1854:  MOVF   01,F
1856:  BZ    1878
1858:  CLRF   41
185A:  MOVLB  1
185C:  CLRF   x8A
185E:  MOVFF  16F,189
1862:  MOVLB  0
1864:  RCALL  16CC
1866:  MOVF   01,W
1868:  SUBWF  41,W
186A:  BC    1878
186C:  MOVLW  64
186E:  ADDWF  2E,F
1870:  MOVLW  00
1872:  ADDWFC 2F,F
1874:  INCF   41,F
1876:  BRA    185A
....................    if(convertir_to_entero(entran[2]) >0) for(i=0;i< convertir_to_entero(entran[2]);i++) temporal1=temporal1+10; 
1878:  MOVLB  1
187A:  CLRF   x8A
187C:  MOVFF  170,189
1880:  MOVLB  0
1882:  RCALL  16CC
1884:  MOVF   01,F
1886:  BZ    18A8
1888:  CLRF   41
188A:  MOVLB  1
188C:  CLRF   x8A
188E:  MOVFF  170,189
1892:  MOVLB  0
1894:  RCALL  16CC
1896:  MOVF   01,W
1898:  SUBWF  41,W
189A:  BC    18A8
189C:  MOVLW  0A
189E:  ADDWF  2E,F
18A0:  MOVLW  00
18A2:  ADDWFC 2F,F
18A4:  INCF   41,F
18A6:  BRA    188A
....................    sub_atras=temporal1=temporal1+convertir_to_entero(entran[3]); 
18A8:  MOVLB  1
18AA:  CLRF   x8A
18AC:  MOVFF  171,189
18B0:  MOVLB  0
18B2:  RCALL  16CC
18B4:  MOVF   01,W
18B6:  ADDWF  2E,F
18B8:  MOVLW  00
18BA:  ADDWFC 2F,F
18BC:  MOVFF  2F,35
18C0:  MOVFF  2E,34
....................     
....................    if(convertir_to_entero(salen[0]) >0) for(i=0;i< convertir_to_entero(salen[0]);i++) temporal2=temporal2+1000; 
18C4:  MOVLB  1
18C6:  CLRF   x8A
18C8:  MOVFF  172,189
18CC:  MOVLB  0
18CE:  RCALL  16CC
18D0:  MOVF   01,F
18D2:  BZ    18F4
18D4:  CLRF   41
18D6:  MOVLB  1
18D8:  CLRF   x8A
18DA:  MOVFF  172,189
18DE:  MOVLB  0
18E0:  RCALL  16CC
18E2:  MOVF   01,W
18E4:  SUBWF  41,W
18E6:  BC    18F4
18E8:  MOVLW  E8
18EA:  ADDWF  30,F
18EC:  MOVLW  03
18EE:  ADDWFC 31,F
18F0:  INCF   41,F
18F2:  BRA    18D6
....................    if(convertir_to_entero(salen[1]) >0) for(i=0;i< convertir_to_entero(salen[1]);i++) temporal2=temporal2+100; 
18F4:  MOVLB  1
18F6:  CLRF   x8A
18F8:  MOVFF  173,189
18FC:  MOVLB  0
18FE:  RCALL  16CC
1900:  MOVF   01,F
1902:  BZ    1924
1904:  CLRF   41
1906:  MOVLB  1
1908:  CLRF   x8A
190A:  MOVFF  173,189
190E:  MOVLB  0
1910:  RCALL  16CC
1912:  MOVF   01,W
1914:  SUBWF  41,W
1916:  BC    1924
1918:  MOVLW  64
191A:  ADDWF  30,F
191C:  MOVLW  00
191E:  ADDWFC 31,F
1920:  INCF   41,F
1922:  BRA    1906
....................    if(convertir_to_entero(salen[2]) >0) for(i=0;i< convertir_to_entero(salen[2]);i++) temporal2=temporal2+10; 
1924:  MOVLB  1
1926:  CLRF   x8A
1928:  MOVFF  174,189
192C:  MOVLB  0
192E:  RCALL  16CC
1930:  MOVF   01,F
1932:  BZ    1954
1934:  CLRF   41
1936:  MOVLB  1
1938:  CLRF   x8A
193A:  MOVFF  174,189
193E:  MOVLB  0
1940:  RCALL  16CC
1942:  MOVF   01,W
1944:  SUBWF  41,W
1946:  BC    1954
1948:  MOVLW  0A
194A:  ADDWF  30,F
194C:  MOVLW  00
194E:  ADDWFC 31,F
1950:  INCF   41,F
1952:  BRA    1936
....................    baj_atras=temporal2=temporal2+convertir_to_entero(salen[3]); 
1954:  MOVLB  1
1956:  CLRF   x8A
1958:  MOVFF  175,189
195C:  MOVLB  0
195E:  RCALL  16CC
1960:  MOVF   01,W
1962:  ADDWF  30,F
1964:  MOVLW  00
1966:  ADDWFC 31,F
1968:  MOVFF  31,37
196C:  MOVFF  30,36
....................     
....................    if(convertir_to_entero(bloqueado[0]) >0) for(i=0;i< convertir_to_entero(bloqueado[0]);i++) temporal3=temporal3+100; 
1970:  MOVLB  1
1972:  CLRF   x8A
1974:  MOVFF  176,189
1978:  MOVLB  0
197A:  RCALL  16CC
197C:  MOVF   01,F
197E:  BZ    19A0
1980:  CLRF   41
1982:  MOVLB  1
1984:  CLRF   x8A
1986:  MOVFF  176,189
198A:  MOVLB  0
198C:  RCALL  16CC
198E:  MOVF   01,W
1990:  SUBWF  41,W
1992:  BC    19A0
1994:  MOVLW  64
1996:  ADDWF  x96,F
1998:  MOVLW  00
199A:  ADDWFC x97,F
199C:  INCF   41,F
199E:  BRA    1982
....................    if(convertir_to_entero(bloqueado[1]) >0) for(i=0;i< convertir_to_entero(bloqueado[1]);i++) temporal3=temporal3+10; 
19A0:  MOVLB  1
19A2:  CLRF   x8A
19A4:  MOVFF  177,189
19A8:  MOVLB  0
19AA:  RCALL  16CC
19AC:  MOVF   01,F
19AE:  BZ    19D0
19B0:  CLRF   41
19B2:  MOVLB  1
19B4:  CLRF   x8A
19B6:  MOVFF  177,189
19BA:  MOVLB  0
19BC:  RCALL  16CC
19BE:  MOVF   01,W
19C0:  SUBWF  41,W
19C2:  BC    19D0
19C4:  MOVLW  0A
19C6:  ADDWF  x96,F
19C8:  MOVLW  00
19CA:  ADDWFC x97,F
19CC:  INCF   41,F
19CE:  BRA    19B2
....................    temporal3=temporal3+convertir_to_entero(bloqueado[2]); 
19D0:  MOVLB  1
19D2:  CLRF   x8A
19D4:  MOVFF  178,189
19D8:  MOVLB  0
19DA:  RCALL  16CC
19DC:  MOVF   01,W
19DE:  ADDWF  x96,F
19E0:  MOVLW  00
19E2:  ADDWFC x97,F
....................     
....................    entran1=(entraront+salieront)/2; 
19E4:  MOVF   x8C,W
19E6:  ADDWF  x8A,W
19E8:  MOVLB  1
19EA:  MOVWF  x89
19EC:  MOVLB  0
19EE:  MOVF   x8D,W
19F0:  ADDWFC x8B,W
19F2:  MOVLB  1
19F4:  MOVWF  x8A
19F6:  BCF    FD8.0
19F8:  RRCF   x8A,W
19FA:  MOVWF  39
19FC:  RRCF   x89,W
19FE:  MOVWF  38
....................     
....................    total2_t=(temporal1+temporal2)/2; 
1A00:  MOVF   30,W
1A02:  ADDWF  2E,W
1A04:  MOVWF  x89
1A06:  MOVF   31,W
1A08:  ADDWFC 2F,W
1A0A:  MOVWF  x8A
1A0C:  BCF    FD8.0
1A0E:  RRCF   x8A,W
1A10:  MOVWF  51
1A12:  RRCF   x89,W
1A14:  MOVWF  50
....................    ////////////////// 
.................... //!   lcd_gotoxy(16,1);// 
.................... //!   printf(lcd_putc,"S:%Lu",total2_t); 
.................... //!   lcd_gotoxy(16,2);// 
.................... //!   printf(lcd_putc,"R:%Lu",tempo_tn); 
....................    ///////////////// 
....................    leer_conta2(); 
1A16:  MOVLB  0
1A18:  CALL   07F0
....................    if( total2_t== tempo_tn ) {//dato recibido correcto 
1A1C:  MOVF   32,W
1A1E:  SUBWF  50,W
1A20:  BNZ   1A40
1A22:  MOVF   33,W
1A24:  SUBWF  51,W
1A26:  BNZ   1A40
....................          salian=salen1=total2_t; 
1A28:  MOVFF  51,3B
1A2C:  MOVFF  50,3A
1A30:  MOVFF  3B,3D
1A34:  MOVFF  3A,3C
....................          graba_conta2(); 
1A38:  CALL   068E
....................          error=0; 
1A3C:  CLRF   23
....................    } 
1A3E:  BRA    1A44
....................    else error=2; 
1A40:  MOVLW  02
1A42:  MOVWF  23
....................    ///////////// 
....................    pasajet=entran1+salen1; 
1A44:  MOVF   3A,W
1A46:  ADDWF  38,W
1A48:  MOVWF  x90
1A4A:  MOVF   3B,W
1A4C:  ADDWFC 39,W
1A4E:  MOVWF  x91
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1A50:  MOVF   53,W
1A52:  ADDWF  52,W
1A54:  ADDWF  54,W
1A56:  MOVWF  4C
1A58:  CLRF   4D
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entran1,salen1,cta_bloqueo,temporal3,error); 
1A5A:  MOVLW  08
1A5C:  MOVWF  FF6
1A5E:  MOVLW  03
1A60:  MOVWF  FF7
1A62:  MOVLW  07
1A64:  MOVLB  1
1A66:  MOVWF  x89
1A68:  MOVLB  0
1A6A:  RCALL  1416
1A6C:  MOVLW  09
1A6E:  MOVWF  FE9
1A70:  MOVFF  91,18A
1A74:  MOVFF  90,189
1A78:  RCALL  143E
1A7A:  MOVLW  2C
1A7C:  MOVLB  1
1A7E:  MOVWF  x92
1A80:  MOVLB  0
1A82:  CALL   11B6
1A86:  MOVLW  09
1A88:  MOVWF  FE9
1A8A:  MOVFF  39,18A
1A8E:  MOVFF  38,189
1A92:  RCALL  143E
1A94:  MOVLW  2C
1A96:  MOVLB  1
1A98:  MOVWF  x92
1A9A:  MOVLB  0
1A9C:  CALL   11B6
1AA0:  MOVLW  09
1AA2:  MOVWF  FE9
1AA4:  MOVFF  3B,18A
1AA8:  MOVFF  3A,189
1AAC:  RCALL  143E
1AAE:  MOVLW  2C
1AB0:  MOVLB  1
1AB2:  MOVWF  x92
1AB4:  MOVLB  0
1AB6:  CALL   11B6
1ABA:  MOVLW  0A
1ABC:  MOVWF  FE9
1ABE:  MOVFF  4D,18A
1AC2:  MOVFF  4C,189
1AC6:  RCALL  143E
1AC8:  MOVLW  2C
1ACA:  MOVLB  1
1ACC:  MOVWF  x92
1ACE:  MOVLB  0
1AD0:  CALL   11B6
1AD4:  MOVLW  0A
1AD6:  MOVWF  FE9
1AD8:  MOVFF  97,18A
1ADC:  MOVFF  96,189
1AE0:  RCALL  143E
1AE2:  MOVLW  2C
1AE4:  MOVLB  1
1AE6:  MOVWF  x92
1AE8:  MOVLB  0
1AEA:  CALL   11B6
1AEE:  MOVFF  23,189
1AF2:  MOVLW  01
1AF4:  MOVLB  1
1AF6:  MOVWF  x8A
1AF8:  MOVLB  0
1AFA:  RCALL  1502
1AFC:  MOVLW  31
1AFE:  MOVWF  FF6
1B00:  MOVLW  03
1B02:  MOVWF  FF7
1B04:  MOVLW  03
1B06:  MOVLB  1
1B08:  MOVWF  x89
1B0A:  MOVLB  0
1B0C:  RCALL  1416
....................    lcd_cuentas(); 
1B0E:  CALL   0A38
....................    /////////////////////////// 
.................... //!   lcd_gotoxy(8,4); 
.................... //!   printf(lcd_putc,"M:%Ld E:%Ld T:%Ld ",entran1,salen1,pasajet); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1B12:  MOVLW  09
1B14:  MOVLB  1
1B16:  MOVWF  x93
1B18:  MOVLW  03
1B1A:  MOVWF  x94
1B1C:  MOVLB  0
1B1E:  CALL   0842
....................    lcd_putc(0xAB); 
1B22:  MOVLW  AB
1B24:  MOVLB  1
1B26:  MOVWF  x92
1B28:  MOVLB  0
1B2A:  CALL   0894
....................    //lcd_gotoxy(9,4);//cronometro para limpiar 
....................    //lcd_putc("    "); 
....................    clear_lcd1=1; 
1B2E:  MOVLW  01
1B30:  MOVWF  xAB
....................    time_lcd1=0; 
1B32:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1B34:  CLRF   xAA
1B36:  CLRF   xA9
....................    transmitir=0; 
1B38:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1B3A:  BSF    F9D.5
1B3C:  GOTO   3018 (RETURN)
.................... } 
....................  
.................... void envia2(){//Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
157E:  BCF    F9D.5
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1580:  MOVF   53,W
1582:  ADDWF  52,W
1584:  ADDWF  54,W
1586:  MOVWF  4C
1588:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));//entran=0; 
158A:  MOVLW  01
158C:  MOVWF  FEA
158E:  MOVLW  6E
1590:  MOVWF  FE9
1592:  CLRF   00
1594:  CLRF   02
1596:  MOVLW  04
1598:  MOVWF  01
159A:  RCALL  127C
....................    memset(salen, 0, sizeof(salen));//salen=0; 
159C:  MOVLW  01
159E:  MOVWF  FEA
15A0:  MOVLW  72
15A2:  MOVWF  FE9
15A4:  CLRF   00
15A6:  CLRF   02
15A8:  MOVLW  04
15AA:  MOVWF  01
15AC:  RCALL  127C
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
15AE:  MOVLW  01
15B0:  MOVWF  FEA
15B2:  MOVLW  76
15B4:  MOVWF  FE9
15B6:  CLRF   00
15B8:  CLRF   02
15BA:  MOVLW  03
15BC:  MOVWF  01
15BE:  RCALL  127C
....................    i=10; 
15C0:  MOVLW  0A
15C2:  MOVWF  41
....................    ii=0; 
15C4:  CLRF   42
....................    entran1=(entraront+salieront)/2; 
15C6:  MOVF   x8C,W
15C8:  ADDWF  x8A,W
15CA:  MOVLB  1
15CC:  MOVWF  x89
15CE:  MOVLB  0
15D0:  MOVF   x8D,W
15D2:  ADDWFC x8B,W
15D4:  MOVLB  1
15D6:  MOVWF  x8A
15D8:  BCF    FD8.0
15DA:  RRCF   x8A,W
15DC:  MOVWF  39
15DE:  RRCF   x89,W
15E0:  MOVWF  38
....................    leer_conta2(); 
15E2:  MOVLB  0
15E4:  CALL   07F0
....................    pasajet=entran1+salian; 
15E8:  MOVF   3C,W
15EA:  ADDWF  38,W
15EC:  MOVWF  x90
15EE:  MOVF   3D,W
15F0:  ADDWFC 39,W
15F2:  MOVWF  x91
....................    error=1; 
15F4:  MOVLW  01
15F6:  MOVWF  23
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n",pasajet,entran1,cta_bloqueo,error); 
15F8:  MOVLW  36
15FA:  MOVWF  FF6
15FC:  MOVLW  03
15FE:  MOVWF  FF7
1600:  MOVLW  07
1602:  MOVLB  1
1604:  MOVWF  x89
1606:  MOVLB  0
1608:  RCALL  1416
160A:  MOVLW  09
160C:  MOVWF  FE9
160E:  MOVFF  91,18A
1612:  MOVFF  90,189
1616:  RCALL  143E
1618:  MOVLW  2C
161A:  MOVLB  1
161C:  MOVWF  x92
161E:  MOVLB  0
1620:  RCALL  11B6
1622:  MOVLW  09
1624:  MOVWF  FE9
1626:  MOVFF  39,18A
162A:  MOVFF  38,189
162E:  RCALL  143E
1630:  MOVLW  48
1632:  MOVWF  FF6
1634:  MOVLW  03
1636:  MOVWF  FF7
1638:  MOVLW  06
163A:  MOVLB  1
163C:  MOVWF  x89
163E:  MOVLB  0
1640:  RCALL  1416
1642:  MOVLW  0A
1644:  MOVWF  FE9
1646:  MOVFF  4D,18A
164A:  MOVFF  4C,189
164E:  RCALL  143E
1650:  MOVLW  53
1652:  MOVWF  FF6
1654:  MOVLW  03
1656:  MOVWF  FF7
1658:  MOVLW  05
165A:  MOVLB  1
165C:  MOVWF  x89
165E:  MOVLB  0
1660:  RCALL  1416
1662:  MOVFF  23,189
1666:  MOVLW  01
1668:  MOVLB  1
166A:  MOVWF  x8A
166C:  MOVLB  0
166E:  RCALL  1502
1670:  MOVLW  5C
1672:  MOVWF  FF6
1674:  MOVLW  03
1676:  MOVWF  FF7
1678:  MOVLW  03
167A:  MOVLB  1
167C:  MOVWF  x89
167E:  MOVLB  0
1680:  RCALL  1416
.................... //!   lcd_gotoxy(1,4); 
.................... //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1682:  MOVLW  09
1684:  MOVLB  1
1686:  MOVWF  x93
1688:  MOVLW  03
168A:  MOVWF  x94
168C:  MOVLB  0
168E:  CALL   0842
....................    lcd_putc(0xAB); 
1692:  MOVLW  AB
1694:  MOVLB  1
1696:  MOVWF  x92
1698:  MOVLB  0
169A:  CALL   0894
....................    lcd_gotoxy(9,4);//cronometro para limpiar 
169E:  MOVLW  09
16A0:  MOVLB  1
16A2:  MOVWF  x93
16A4:  MOVLW  04
16A6:  MOVWF  x94
16A8:  MOVLB  0
16AA:  CALL   0842
....................    lcd_putc("DESC"); 
16AE:  MOVLW  60
16B0:  MOVWF  FF6
16B2:  MOVLW  03
16B4:  MOVWF  FF7
16B6:  CALL   0A18
....................    clear_lcd1=1; 
16BA:  MOVLW  01
16BC:  MOVWF  xAB
....................    time_lcd1=0; 
16BE:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
16C0:  CLRF   xAA
16C2:  CLRF   xA9
....................    flag_enviar=0; 
16C4:  CLRF   46
....................    enable_interrupts(INT_RDA); 
16C6:  BSF    F9D.5
16C8:  GOTO   300E (RETURN)
.................... } 
....................  
.................... void limpiar(){//borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront=0; 
*
0CF0:  CLRF   x93
0CF2:  CLRF   x92
....................    tem_salieront=0; 
0CF4:  CLRF   x95
0CF6:  CLRF   x94
....................    salian=0; 
0CF8:  CLRF   3D
0CFA:  CLRF   3C
....................    graba_conta2(); 
0CFC:  RCALL  068E
....................    leer_conta2(); 
0CFE:  RCALL  07F0
....................    pasaje=0; 
0D00:  CLRF   x8F
0D02:  CLRF   x8E
....................    pasajet=0; 
0D04:  CLRF   x91
0D06:  CLRF   x90
....................    salieront=0; 
0D08:  CLRF   x8D
0D0A:  CLRF   x8C
....................    entraront=0; 
0D0C:  CLRF   x8B
0D0E:  CLRF   x8A
....................    write_ent(); 
0D10:  RCALL  0C84
....................    write_sal(); 
0D12:  RCALL  0CBA
....................    cta_bloqueo=0; 
0D14:  CLRF   4D
0D16:  CLRF   4C
....................    cta_bloq1=0; 
0D18:  CLRF   52
....................    cta_bloq2=0; 
0D1A:  CLRF   53
....................    cta_bloq3=0; 
0D1C:  CLRF   54
....................    write_ext_eeprom(9,cta_bloq1);//bloq1 
0D1E:  MOVLB  1
0D20:  CLRF   x8E
0D22:  MOVLW  09
0D24:  MOVWF  x8D
0D26:  MOVFF  52,18F
0D2A:  MOVLB  0
0D2C:  RCALL  0588
....................    write_ext_eeprom(10,cta_bloq2);//bloq2 
0D2E:  MOVLB  1
0D30:  CLRF   x8E
0D32:  MOVLW  0A
0D34:  MOVWF  x8D
0D36:  MOVFF  53,18F
0D3A:  MOVLB  0
0D3C:  RCALL  0588
....................    write_ext_eeprom(11,cta_bloq3);//bloq3 
0D3E:  MOVLB  1
0D40:  CLRF   x8E
0D42:  MOVLW  0B
0D44:  MOVWF  x8D
0D46:  MOVFF  54,18F
0D4A:  MOVLB  0
0D4C:  RCALL  0588
....................    lcd_putc("\f"); 
0D4E:  MOVLW  66
0D50:  MOVWF  FF6
0D52:  MOVLW  03
0D54:  MOVWF  FF7
0D56:  RCALL  0A18
....................    lcd_cuentas(); 
0D58:  RCALL  0A38
0D5A:  RETURN 0
.................... } 
....................  
.................... void detecta_suma(){//Realiza suma de entradas o salidas 
....................     if( (!detec1)&&(!detec2)&&(!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){//suma sin bloqueos 
*
1E10:  MOVF   x69,F
1E12:  BNZ   1E7E
1E14:  MOVF   x6A,F
1E16:  BNZ   1E7E
1E18:  MOVF   x6B,F
1E1A:  BNZ   1E7E
1E1C:  MOVF   x6C,F
1E1E:  BNZ   1E7E
1E20:  MOVF   x6D,F
1E22:  BNZ   1E7E
1E24:  MOVF   x6E,F
1E26:  BNZ   1E7E
....................       sumae1=fse1+fse2+fse3; 
1E28:  MOVF   29,W
1E2A:  ADDWF  28,W
1E2C:  ADDWF  2A,W
1E2E:  MOVWF  25
....................       sumas1=fss1+fss2+fss3; 
1E30:  MOVF   2C,W
1E32:  ADDWF  2B,W
1E34:  ADDWF  2D,W
1E36:  MOVWF  26
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if( (sumae1>=2)||(sumas1>=2) ){ 
1E38:  MOVF   25,W
1E3A:  SUBLW  01
1E3C:  BNC   1E44
1E3E:  MOVF   26,W
1E40:  SUBLW  01
1E42:  BC    1E60
....................          if(sumae1>sumas1) { 
1E44:  MOVF   25,W
1E46:  SUBWF  26,W
1E48:  BC    1E56
....................             entraront++; 
1E4A:  INCF   x8A,F
1E4C:  BTFSC  FD8.2
1E4E:  INCF   x8B,F
....................             write_ent(); 
1E50:  CALL   0C84
....................          } 
1E54:  BRA    1E60
....................          else{ 
....................             salieront++; 
1E56:  INCF   x8C,F
1E58:  BTFSC  FD8.2
1E5A:  INCF   x8D,F
....................             write_sal(); 
1E5C:  CALL   0CBA
....................          } 
....................       } 
....................       sumae1=fse1=fse2=fse3=0; 
1E60:  CLRF   2A
1E62:  MOVFF  2A,29
1E66:  MOVFF  29,28
1E6A:  MOVFF  28,25
....................       sumas1=fss1=fss2=fss3=0; 
1E6E:  CLRF   2D
1E70:  MOVFF  2D,2C
1E74:  MOVFF  2C,2B
1E78:  MOVFF  2B,26
....................       //envio_PC(); 
....................    }//fin suma sin bloqueos 
1E7C:  BRA    1F7C
....................    else if( (en_b1)||(en_b2)||(en_b3) ){//contar con bloqueos 
1E7E:  MOVF   x9E,F
1E80:  BNZ   1E8C
1E82:  MOVF   x9F,F
1E84:  BNZ   1E8C
1E86:  MOVF   xA0,F
1E88:  BTFSC  FD8.2
1E8A:  BRA    1F7C
....................             lim_b= en_b1+ en_b2+ en_b3; 
1E8C:  MOVF   x9F,W
1E8E:  ADDWF  x9E,W
1E90:  ADDWF  xA0,W
1E92:  MOVWF  27
.................... //!            lcd_gotoxy(9,2);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"lim_b:%u ",lim_b);//habilitar unicamente para hacer diagnosticos 
.................... //!            lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................              
....................             if(lim_b==1){//un solo bloqueo 
1E94:  DECFSZ 27,W
1E96:  BRA    1F28
....................                if(en_b1){ 
1E98:  MOVF   x9E,F
1E9A:  BZ    1EC8
....................                   if( (!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){ 
1E9C:  MOVF   x6B,F
1E9E:  BNZ   1EC6
1EA0:  MOVF   x6C,F
1EA2:  BNZ   1EC6
1EA4:  MOVF   x6D,F
1EA6:  BNZ   1EC6
1EA8:  MOVF   x6E,F
1EAA:  BNZ   1EC6
....................                      if(sen_ent==1){ 
1EAC:  DECFSZ 5B,W
1EAE:  BRA    1EBC
....................                         entraront++; 
1EB0:  INCF   x8A,F
1EB2:  BTFSC  FD8.2
1EB4:  INCF   x8B,F
....................                         write_ent(); 
1EB6:  CALL   0C84
....................                      } 
1EBA:  BRA    1EC6
....................                      else{ 
....................                         salieront++; 
1EBC:  INCF   x8C,F
1EBE:  BTFSC  FD8.2
1EC0:  INCF   x8D,F
....................                         write_sal(); 
1EC2:  CALL   0CBA
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin bloqueo par 1 
1EC6:  BRA    1F26
....................                else if(en_b2){//bloqueo en par 2 
1EC8:  MOVF   x9F,F
1ECA:  BZ    1EF8
....................                   if( (!detec1)&&(!detec2)&&(!detec5)&&(!detec6) ){ 
1ECC:  MOVF   x69,F
1ECE:  BNZ   1EF6
1ED0:  MOVF   x6A,F
1ED2:  BNZ   1EF6
1ED4:  MOVF   x6D,F
1ED6:  BNZ   1EF6
1ED8:  MOVF   x6E,F
1EDA:  BNZ   1EF6
....................                      if(sen_ent){ 
1EDC:  MOVF   5B,F
1EDE:  BZ    1EEC
....................                         entraront++; 
1EE0:  INCF   x8A,F
1EE2:  BTFSC  FD8.2
1EE4:  INCF   x8B,F
....................                         write_ent(); 
1EE6:  CALL   0C84
....................                      } 
1EEA:  BRA    1EF6
....................                      else{ 
....................                         salieront++; 
1EEC:  INCF   x8C,F
1EEE:  BTFSC  FD8.2
1EF0:  INCF   x8D,F
....................                         write_sal(); 
1EF2:  CALL   0CBA
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin par 2 
1EF6:  BRA    1F26
....................                else if(en_b3){//bloqueao en par 3 
1EF8:  MOVF   xA0,F
1EFA:  BZ    1F26
....................                   if( (!detec3)&&(!detec4)&&(!detec1)&&(!detec2) ){ 
1EFC:  MOVF   x6B,F
1EFE:  BNZ   1F26
1F00:  MOVF   x6C,F
1F02:  BNZ   1F26
1F04:  MOVF   x69,F
1F06:  BNZ   1F26
1F08:  MOVF   x6A,F
1F0A:  BNZ   1F26
....................                      if(sen_ent){ 
1F0C:  MOVF   5B,F
1F0E:  BZ    1F1C
....................                         entraront++; 
1F10:  INCF   x8A,F
1F12:  BTFSC  FD8.2
1F14:  INCF   x8B,F
....................                         write_ent(); 
1F16:  CALL   0C84
....................                      } 
1F1A:  BRA    1F26
....................                      else{ 
....................                         salieront++; 
1F1C:  INCF   x8C,F
1F1E:  BTFSC  FD8.2
1F20:  INCF   x8D,F
....................                         write_sal(); 
1F22:  CALL   0CBA
....................                      } 
....................                   } 
....................                }//fin par 3 
....................             }//fin un solo bloqueo 
1F26:  BRA    1F60
.................... //----------------------------------------------------------------------------- 
....................             else{//mas de un bloqueo 
....................                sumae1=fse1+fse2+fse3; 
1F28:  MOVF   29,W
1F2A:  ADDWF  28,W
1F2C:  ADDWF  2A,W
1F2E:  MOVWF  25
....................                sumas1=fss1+fss2+fss3; 
1F30:  MOVF   2C,W
1F32:  ADDWF  2B,W
1F34:  ADDWF  2D,W
1F36:  MOVWF  26
....................                //lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................                //printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................                if( (sumae1>=1)||(sumas1>=1) ){ 
1F38:  MOVF   25,W
1F3A:  SUBLW  00
1F3C:  BNC   1F44
1F3E:  MOVF   26,W
1F40:  SUBLW  00
1F42:  BC    1F60
....................                   if(sumae1>sumas1) { 
1F44:  MOVF   25,W
1F46:  SUBWF  26,W
1F48:  BC    1F56
....................                      entraront++; 
1F4A:  INCF   x8A,F
1F4C:  BTFSC  FD8.2
1F4E:  INCF   x8B,F
....................                      write_ent(); 
1F50:  CALL   0C84
....................                   } 
1F54:  BRA    1F60
....................                   else{ 
....................                      salieront++; 
1F56:  INCF   x8C,F
1F58:  BTFSC  FD8.2
1F5A:  INCF   x8D,F
....................                      write_sal(); 
1F5C:  CALL   0CBA
....................                   } 
....................                } 
....................             }//fin mas de un bloqueo 
....................                sumae1=fse1=fse2=fse3=0; 
1F60:  CLRF   2A
1F62:  MOVFF  2A,29
1F66:  MOVFF  29,28
1F6A:  MOVFF  28,25
....................                sumas1=fss1=fss2=fss3=0; 
1F6E:  CLRF   2D
1F70:  MOVFF  2D,2C
1F74:  MOVFF  2C,2B
1F78:  MOVFF  2B,26
.................... //----------------------------------------------------------------------------- 
....................    }//end bloqueos 
1F7C:  RETURN 0
.................... } 
....................  
.................... void finsuma(){//Pinta en LCD la nueva cifra de entrada o salida 
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................       pasaje=(entraront+salieront)/2; 
*
0C46:  MOVF   x8C,W
0C48:  ADDWF  x8A,W
0C4A:  MOVLB  1
0C4C:  MOVWF  x89
0C4E:  MOVLB  0
0C50:  MOVF   x8D,W
0C52:  ADDWFC x8B,W
0C54:  MOVLB  1
0C56:  MOVWF  x8A
0C58:  BCF    FD8.0
0C5A:  RRCF   x8A,W
0C5C:  MOVLB  0
0C5E:  MOVWF  x8F
0C60:  MOVLB  1
0C62:  RRCF   x89,W
0C64:  MOVLB  0
0C66:  MOVWF  x8E
....................       lcd_cuentas(); 
0C68:  RCALL  0A38
....................       sen_ent=0; 
0C6A:  CLRF   5B
....................       sen_sal=0; 
0C6C:  CLRF   5C
....................       fse1=fse2=fse3=0; 
0C6E:  CLRF   2A
0C70:  MOVFF  2A,29
0C74:  MOVFF  29,28
....................       fss1=fss2=fss3=0; 
0C78:  CLRF   2D
0C7A:  MOVFF  2D,2C
0C7E:  MOVFF  2C,2B
0C82:  RETURN 0
.................... } 
....................  
.................... void contando1(){//Revisa maquina de estados para par 1 
....................    if(entra_temp1!=edo1) { 
*
1F7E:  MOVF   x76,W
1F80:  SUBWF  x7B,W
1F82:  BZ    1F8C
....................       entra_temp1=edo1; 
1F84:  MOVFF  76,7B
....................       enable1=1; 
1F88:  MOVLW  01
1F8A:  MOVWF  x7A
....................    } 
....................    if (enable1==1){ 
1F8C:  DECFSZ x7A,W
1F8E:  BRA    1FCC
....................          switch (edo1) { 
1F90:  MOVLW  01
1F92:  SUBWF  x76,W
1F94:  ADDLW  F4
1F96:  BC    1FC8
1F98:  ADDLW  0C
1F9A:  GOTO   1FCE
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
1F9E:  BRA    1FC8
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss1) fse1=1;//si no ha salido antes 
1FA0:  MOVF   2B,F
1FA2:  BNZ   1FAA
1FA4:  MOVLW  01
1FA6:  MOVWF  28
1FA8:  BRA    1FAC
....................                      else fss1=0; 
1FAA:  CLRF   2B
....................                      detecta_suma(); 
1FAC:  RCALL  1E10
....................                      break;} 
1FAE:  BRA    1FC8
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
1FB0:  RCALL  1E10
....................                      break;} 
1FB2:  BRA    1FC8
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
1FB4:  BRA    1FC8
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse1) fss1=1;//si no ha entrado antes 
1FB6:  MOVF   28,F
1FB8:  BNZ   1FC0
1FBA:  MOVLW  01
1FBC:  MOVWF  2B
1FBE:  BRA    1FC2
....................                      else fse1=0; 
1FC0:  CLRF   28
....................                      detecta_suma(); 
1FC2:  RCALL  1E10
....................                      break;} 
1FC4:  BRA    1FC8
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
1FC6:  RCALL  1E10
....................                      break;} 
....................          } 
....................       enable1=0; 
1FC8:  CLRF   x7A
....................       entra_act1=0; 
1FCA:  CLRF   x75
....................    } 
1FCC:  RETURN 0
.................... } 
....................  
.................... void contando2(){//Revisa maquina de estados para par 2 
....................    if(entra_temp2!=edo2) { 
*
2286:  MOVF   x7D,W
2288:  SUBWF  x82,W
228A:  BZ    2294
....................       entra_temp2=edo2; 
228C:  MOVFF  7D,82
....................       enable2=1; 
2290:  MOVLW  01
2292:  MOVWF  x81
....................    } 
....................    if (enable2==1){ 
2294:  DECFSZ x81,W
2296:  BRA    22D4
....................          switch (edo2) { 
2298:  MOVLW  01
229A:  SUBWF  x7D,W
229C:  ADDLW  F4
229E:  BC    22D0
22A0:  ADDLW  0C
22A2:  GOTO   22D6
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
22A6:  BRA    22D0
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss2) fse2=1; 
22A8:  MOVF   2C,F
22AA:  BNZ   22B2
22AC:  MOVLW  01
22AE:  MOVWF  29
22B0:  BRA    22B4
....................                      else fss2=0; 
22B2:  CLRF   2C
....................                      detecta_suma(); 
22B4:  RCALL  1E10
....................                      break;} 
22B6:  BRA    22D0
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
22B8:  RCALL  1E10
....................                      break;} 
22BA:  BRA    22D0
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
22BC:  BRA    22D0
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse2) fss2=1; 
22BE:  MOVF   29,F
22C0:  BNZ   22C8
22C2:  MOVLW  01
22C4:  MOVWF  2C
22C6:  BRA    22CA
....................                      else fse2=0; 
22C8:  CLRF   29
....................                      detecta_suma(); 
22CA:  RCALL  1E10
....................                      break;} 
22CC:  BRA    22D0
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
22CE:  RCALL  1E10
....................                      break;} 
....................          } 
....................       enable2=0; 
22D0:  CLRF   x81
....................       entra_act2=0; 
22D2:  CLRF   x7C
....................    } 
22D4:  RETURN 0
.................... } 
....................  
.................... void contando3(){//Revisa maquina de estados para par 3 
....................    if(entra_temp3!=edo3) { 
*
2590:  MOVF   x84,W
2592:  SUBWF  x89,W
2594:  BZ    259E
....................       entra_temp3=edo3; 
2596:  MOVFF  84,89
....................       enable3=1; 
259A:  MOVLW  01
259C:  MOVWF  x88
....................    } 
....................    if (enable3==1){ 
259E:  DECFSZ x88,W
25A0:  BRA    25DE
....................          switch (edo3) { 
25A2:  MOVLW  01
25A4:  SUBWF  x84,W
25A6:  ADDLW  F4
25A8:  BC    25DA
25AA:  ADDLW  0C
25AC:  GOTO   25E0
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
25B0:  BRA    25DA
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss3) fse3=1; 
25B2:  MOVF   2D,F
25B4:  BNZ   25BC
25B6:  MOVLW  01
25B8:  MOVWF  2A
25BA:  BRA    25BE
....................                      else fss3=0; 
25BC:  CLRF   2D
....................                      detecta_suma(); 
25BE:  RCALL  1E10
....................                      break;} 
25C0:  BRA    25DA
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
25C2:  RCALL  1E10
....................                      break;} 
25C4:  BRA    25DA
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
25C6:  BRA    25DA
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse3) fss3=1; 
25C8:  MOVF   2A,F
25CA:  BNZ   25D2
25CC:  MOVLW  01
25CE:  MOVWF  2D
25D0:  BRA    25D4
....................                      else fse3=0; 
25D2:  CLRF   2A
....................                      detecta_suma(); 
25D4:  RCALL  1E10
....................                      break;} 
25D6:  BRA    25DA
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
25D8:  RCALL  1E10
....................                      break;} 
....................          } 
....................       enable3=0; 
25DA:  CLRF   x88
....................       entra_act3=0; 
25DC:  CLRF   x83
....................    } 
25DE:  RETURN 0
.................... } 
....................  
.................... void sensando1(){//Define estados para la maquina de estados del par 1 
.................... /////normal/////// 
.................... if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==0)){//LLEGA PERSONA EN ENTRADA1 
*
1B8A:  MOVF   x75,F
1B8C:  BNZ   1BD2
1B8E:  DECFSZ x69,W
1B90:  BRA    1BD2
1B92:  MOVF   x6A,F
1B94:  BNZ   1BD2
1B96:  MOVF   x77,F
1B98:  BNZ   1BD2
1B9A:  MOVF   x78,F
1B9C:  BNZ   1BD2
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1B9E:  MOVF   5B,F
1BA0:  BNZ   1BA8
1BA2:  MOVF   5C,F
1BA4:  BTFSC  FD8.2
1BA6:  RCALL  1B40
....................    lcd_gotoxy(8,2); 
1BA8:  MOVLW  08
1BAA:  MOVLB  1
1BAC:  MOVWF  x93
1BAE:  MOVLW  02
1BB0:  MOVWF  x94
1BB2:  MOVLB  0
1BB4:  CALL   0842
....................    lcd_putc(0x7F);//flecha del sentido 
1BB8:  MOVLW  7F
1BBA:  MOVLB  1
1BBC:  MOVWF  x92
1BBE:  MOVLB  0
1BC0:  CALL   0894
....................    des1=1; 
1BC4:  MOVLW  01
1BC6:  MOVWF  x98
....................    //// 
....................    edo1=1; 
1BC8:  MOVWF  x76
....................    entra1=1; 
1BCA:  MOVWF  x77
....................    edoa1=1; 
1BCC:  MOVWF  x79
....................    entra_act1=1;} 
1BCE:  MOVWF  x75
1BD0:  BRA    1E0E
.................... ///prioridad 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA ENTRANDO 
1BD2:  MOVF   x75,F
1BD4:  BNZ   1BF2
1BD6:  DECFSZ x69,W
1BD8:  BRA    1BF2
1BDA:  DECFSZ x6A,W
1BDC:  BRA    1BF2
1BDE:  DECFSZ x77,W
1BE0:  BRA    1BF2
1BE2:  MOVF   x78,F
1BE4:  BNZ   1BF2
....................    edo1=3; 
1BE6:  MOVLW  03
1BE8:  MOVWF  x76
....................    edoa1=0; 
1BEA:  CLRF   x79
....................    entra_act1=1;} 
1BEC:  MOVLW  01
1BEE:  MOVWF  x75
1BF0:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA CASI TERMINA DE ENTRAR 
1BF2:  MOVF   x75,F
1BF4:  BNZ   1C10
1BF6:  MOVF   x69,F
1BF8:  BNZ   1C10
1BFA:  DECFSZ x6A,W
1BFC:  BRA    1C10
1BFE:  DECFSZ x77,W
1C00:  BRA    1C10
1C02:  MOVF   x78,F
1C04:  BNZ   1C10
....................    edo1=4; 
1C06:  MOVLW  04
1C08:  MOVWF  x76
....................    entra_act1=1;} 
1C0A:  MOVLW  01
1C0C:  MOVWF  x75
1C0E:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==1)&&(sale1==0)){//PERSONA A ENTRADO 
1C10:  MOVF   x75,F
1C12:  BNZ   1C68
1C14:  MOVF   x69,F
1C16:  BNZ   1C68
1C18:  MOVF   x6A,F
1C1A:  BNZ   1C68
1C1C:  MOVF   x79,F
1C1E:  BNZ   1C68
1C20:  DECFSZ x77,W
1C22:  BRA    1C68
1C24:  MOVF   x78,F
1C26:  BNZ   1C68
....................    lcd_gotoxy(8,2); 
1C28:  MOVLW  08
1C2A:  MOVLB  1
1C2C:  MOVWF  x93
1C2E:  MOVLW  02
1C30:  MOVWF  x94
1C32:  MOVLB  0
1C34:  CALL   0842
....................    lcd_putc(" "); 
1C38:  MOVLW  68
1C3A:  MOVWF  FF6
1C3C:  MOVLW  03
1C3E:  MOVWF  FF7
1C40:  CALL   0A18
....................    des1=0; 
1C44:  CLRF   x98
....................    if(entra_temp1==4){ 
1C46:  MOVF   x7B,W
1C48:  SUBLW  04
1C4A:  BNZ   1C58
....................       edo1=5; 
1C4C:  MOVLW  05
1C4E:  MOVWF  x76
....................       entra1=0; 
1C50:  CLRF   x77
....................       entra_act1=1; 
1C52:  MOVLW  01
1C54:  MOVWF  x75
....................    } 
1C56:  BRA    1C66
....................    else {//entraba y se regresa 
....................       des1=0; 
1C58:  CLRF   x98
....................       edo1=6; 
1C5A:  MOVLW  06
1C5C:  MOVWF  x76
....................       entra1=0; 
1C5E:  CLRF   x77
....................       edoa1=0; 
1C60:  CLRF   x79
....................       entra_act1=1;   
1C62:  MOVLW  01
1C64:  MOVWF  x75
....................    } 
.................... } 
1C66:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==1)&&(sale1==0)){//entraba y se regresa 
1C68:  MOVF   x75,F
1C6A:  BNZ   1CAC
1C6C:  MOVF   x69,F
1C6E:  BNZ   1CAC
1C70:  MOVF   x6A,F
1C72:  BNZ   1CAC
1C74:  DECFSZ x79,W
1C76:  BRA    1CAC
1C78:  DECFSZ x77,W
1C7A:  BRA    1CAC
1C7C:  MOVF   x78,F
1C7E:  BNZ   1CAC
....................    lcd_gotoxy(8,2); 
1C80:  MOVLW  08
1C82:  MOVLB  1
1C84:  MOVWF  x93
1C86:  MOVLW  02
1C88:  MOVWF  x94
1C8A:  MOVLB  0
1C8C:  CALL   0842
....................    lcd_putc(" "); 
1C90:  MOVLW  6A
1C92:  MOVWF  FF6
1C94:  MOVLW  03
1C96:  MOVWF  FF7
1C98:  CALL   0A18
....................    des1=0; 
1C9C:  CLRF   x98
....................    edo1=6; 
1C9E:  MOVLW  06
1CA0:  MOVWF  x76
....................    entra1=0; 
1CA2:  CLRF   x77
....................    edoa1=0; 
1CA4:  CLRF   x79
....................    entra_act1=1;} 
1CA6:  MOVLW  01
1CA8:  MOVWF  x75
1CAA:  BRA    1E0E
.................... ///// 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==1)&&(sale1==0)){ 
1CAC:  MOVF   x75,F
1CAE:  BNZ   1CCC
1CB0:  DECFSZ x69,W
1CB2:  BRA    1CCC
1CB4:  MOVF   x6A,F
1CB6:  BNZ   1CCC
1CB8:  DECFSZ x77,W
1CBA:  BRA    1CCC
1CBC:  MOVF   x78,F
1CBE:  BNZ   1CCC
....................    edo1=2; 
1CC0:  MOVLW  02
1CC2:  MOVWF  x76
....................    edoa1=1; 
1CC4:  MOVLW  01
1CC6:  MOVWF  x79
....................    entra_act1=1;}//checar prioridad 
1CC8:  MOVWF  x75
1CCA:  BRA    1E0E
.................... //////sentido inverso/// 
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
1CCC:  MOVF   x75,F
1CCE:  BNZ   1D16
1CD0:  MOVF   x69,F
1CD2:  BNZ   1D16
1CD4:  DECFSZ x6A,W
1CD6:  BRA    1D16
1CD8:  MOVF   x77,F
1CDA:  BNZ   1D16
1CDC:  MOVF   x78,F
1CDE:  BNZ   1D16
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1CE0:  MOVF   5B,F
1CE2:  BNZ   1CEA
1CE4:  MOVF   5C,F
1CE6:  BTFSC  FD8.2
1CE8:  RCALL  1B40
....................    lcd_gotoxy(8,2); 
1CEA:  MOVLW  08
1CEC:  MOVLB  1
1CEE:  MOVWF  x93
1CF0:  MOVLW  02
1CF2:  MOVWF  x94
1CF4:  MOVLB  0
1CF6:  CALL   0842
....................    lcd_putc(0x7E);//flecha del sentido 
1CFA:  MOVLW  7E
1CFC:  MOVLB  1
1CFE:  MOVWF  x92
1D00:  MOVLB  0
1D02:  CALL   0894
....................    des1=1; 
1D06:  MOVLW  01
1D08:  MOVWF  x98
....................    edo1=7; 
1D0A:  MOVLW  07
1D0C:  MOVWF  x76
....................    sale1=1; 
1D0E:  MOVLW  01
1D10:  MOVWF  x78
....................    entra_act1=1;} 
1D12:  MOVWF  x75
1D14:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 1 
1D16:  MOVF   x75,F
1D18:  BNZ   1D36
1D1A:  MOVF   x69,F
1D1C:  BNZ   1D36
1D1E:  DECFSZ x6A,W
1D20:  BRA    1D36
1D22:  MOVF   x77,F
1D24:  BNZ   1D36
1D26:  DECFSZ x78,W
1D28:  BRA    1D36
....................    edo1=8; 
1D2A:  MOVLW  08
1D2C:  MOVWF  x76
....................    edoa1=1; 
1D2E:  MOVLW  01
1D30:  MOVWF  x79
....................    entra_act1=1;} 
1D32:  MOVWF  x75
1D34:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 2 
1D36:  MOVF   x75,F
1D38:  BNZ   1D56
1D3A:  DECFSZ x69,W
1D3C:  BRA    1D56
1D3E:  DECFSZ x6A,W
1D40:  BRA    1D56
1D42:  MOVF   x77,F
1D44:  BNZ   1D56
1D46:  DECFSZ x78,W
1D48:  BRA    1D56
....................    edo1=9; 
1D4A:  MOVLW  09
1D4C:  MOVWF  x76
....................    edoa1=0; 
1D4E:  CLRF   x79
....................    entra_act1=1;} 
1D50:  MOVLW  01
1D52:  MOVWF  x75
1D54:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==1)){//CASI TERMINA DE SALIR 
1D56:  MOVF   x75,F
1D58:  BNZ   1D74
1D5A:  DECFSZ x69,W
1D5C:  BRA    1D74
1D5E:  MOVF   x6A,F
1D60:  BNZ   1D74
1D62:  MOVF   x77,F
1D64:  BNZ   1D74
1D66:  DECFSZ x78,W
1D68:  BRA    1D74
....................    edo1=10; 
1D6A:  MOVLW  0A
1D6C:  MOVWF  x76
....................    entra_act1=1;} 
1D6E:  MOVLW  01
1D70:  MOVWF  x75
1D72:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==0)&&(sale1==1)){//PERSONA A SALIDO POR ENTRADA 
1D74:  MOVF   x75,F
1D76:  BNZ   1DCC
1D78:  MOVF   x69,F
1D7A:  BNZ   1DCC
1D7C:  MOVF   x6A,F
1D7E:  BNZ   1DCC
1D80:  MOVF   x79,F
1D82:  BNZ   1DCC
1D84:  MOVF   x77,F
1D86:  BNZ   1DCC
1D88:  DECFSZ x78,W
1D8A:  BRA    1DCC
....................    lcd_gotoxy(8,2); 
1D8C:  MOVLW  08
1D8E:  MOVLB  1
1D90:  MOVWF  x93
1D92:  MOVLW  02
1D94:  MOVWF  x94
1D96:  MOVLB  0
1D98:  CALL   0842
....................    lcd_putc(" "); 
1D9C:  MOVLW  6C
1D9E:  MOVWF  FF6
1DA0:  MOVLW  03
1DA2:  MOVWF  FF7
1DA4:  CALL   0A18
....................    if(entra_temp1==10) { 
1DA8:  MOVF   x7B,W
1DAA:  SUBLW  0A
1DAC:  BNZ   1DBC
....................       des1=0; 
1DAE:  CLRF   x98
....................       edo1=11; 
1DB0:  MOVLW  0B
1DB2:  MOVWF  x76
....................       sale1=0; 
1DB4:  CLRF   x78
....................       entra_act1=1;} 
1DB6:  MOVLW  01
1DB8:  MOVWF  x75
1DBA:  BRA    1DCA
....................    else { 
....................       des1=0; 
1DBC:  CLRF   x98
....................       edo1=12; 
1DBE:  MOVLW  0C
1DC0:  MOVWF  x76
....................       sale1=0; 
1DC2:  CLRF   x78
....................       edoa1=0; 
1DC4:  CLRF   x79
....................       entra_act1=1; 
1DC6:  MOVLW  01
1DC8:  MOVWF  x75
....................    } 
.................... } 
1DCA:  BRA    1E0E
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==0)&&(sale1==1)){//SALIA y se regresa 
1DCC:  MOVF   x75,F
1DCE:  BNZ   1E0E
1DD0:  MOVF   x69,F
1DD2:  BNZ   1E0E
1DD4:  MOVF   x6A,F
1DD6:  BNZ   1E0E
1DD8:  DECFSZ x79,W
1DDA:  BRA    1E0E
1DDC:  MOVF   x77,F
1DDE:  BNZ   1E0E
1DE0:  DECFSZ x78,W
1DE2:  BRA    1E0E
....................    lcd_gotoxy(8,2); 
1DE4:  MOVLW  08
1DE6:  MOVLB  1
1DE8:  MOVWF  x93
1DEA:  MOVLW  02
1DEC:  MOVWF  x94
1DEE:  MOVLB  0
1DF0:  CALL   0842
....................    lcd_putc(" "); 
1DF4:  MOVLW  6E
1DF6:  MOVWF  FF6
1DF8:  MOVLW  03
1DFA:  MOVWF  FF7
1DFC:  CALL   0A18
....................    des1=0; 
1E00:  CLRF   x98
....................    edo1=12; 
1E02:  MOVLW  0C
1E04:  MOVWF  x76
....................    sale1=0; 
1E06:  CLRF   x78
....................    edoa1=0; 
1E08:  CLRF   x79
....................    entra_act1=1;} 
1E0A:  MOVLW  01
1E0C:  MOVWF  x75
1E0E:  RETURN 0
.................... } 
....................  
.................... void sensando2(){//Define estados para la maquina de estados del par 2 
.................... /////normal/////// 
.................... if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==0)){//LLEGA PERSONA EN ENTRADA1 
*
2000:  MOVF   x7C,F
2002:  BNZ   2048
2004:  DECFSZ x6B,W
2006:  BRA    2048
2008:  MOVF   x6C,F
200A:  BNZ   2048
200C:  MOVF   x7E,F
200E:  BNZ   2048
2010:  MOVF   x7F,F
2012:  BNZ   2048
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2014:  MOVF   5B,F
2016:  BNZ   201E
2018:  MOVF   5C,F
201A:  BTFSC  FD8.2
201C:  RCALL  1B40
....................    lcd_gotoxy(8,3); 
201E:  MOVLW  08
2020:  MOVLB  1
2022:  MOVWF  x93
2024:  MOVLW  03
2026:  MOVWF  x94
2028:  MOVLB  0
202A:  CALL   0842
....................    lcd_putc(0x7F); 
202E:  MOVLW  7F
2030:  MOVLB  1
2032:  MOVWF  x92
2034:  MOVLB  0
2036:  CALL   0894
....................    des2=1; 
203A:  MOVLW  01
203C:  MOVWF  x99
....................    edo2=1; 
203E:  MOVWF  x7D
....................    entra2=1; 
2040:  MOVWF  x7E
....................    edoa2=1; 
2042:  MOVWF  x80
....................    entra_act2=1;} 
2044:  MOVWF  x7C
2046:  BRA    2284
.................... ///prioridad 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA ENTRANDO 
2048:  MOVF   x7C,F
204A:  BNZ   2068
204C:  DECFSZ x6B,W
204E:  BRA    2068
2050:  DECFSZ x6C,W
2052:  BRA    2068
2054:  DECFSZ x7E,W
2056:  BRA    2068
2058:  MOVF   x7F,F
205A:  BNZ   2068
....................    edo2=3; 
205C:  MOVLW  03
205E:  MOVWF  x7D
....................    edoa2=0; 
2060:  CLRF   x80
....................    entra_act2=1;} 
2062:  MOVLW  01
2064:  MOVWF  x7C
2066:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA CASI TERMINA DE ENTRAR 
2068:  MOVF   x7C,F
206A:  BNZ   2086
206C:  MOVF   x6B,F
206E:  BNZ   2086
2070:  DECFSZ x6C,W
2072:  BRA    2086
2074:  DECFSZ x7E,W
2076:  BRA    2086
2078:  MOVF   x7F,F
207A:  BNZ   2086
....................    edo2=4; 
207C:  MOVLW  04
207E:  MOVWF  x7D
....................    entra_act2=1;} 
2080:  MOVLW  01
2082:  MOVWF  x7C
2084:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==1)&&(sale2==0)){//PERSONA A ENTRADO 
2086:  MOVF   x7C,F
2088:  BNZ   20DE
208A:  MOVF   x6B,F
208C:  BNZ   20DE
208E:  MOVF   x6C,F
2090:  BNZ   20DE
2092:  MOVF   x80,F
2094:  BNZ   20DE
2096:  DECFSZ x7E,W
2098:  BRA    20DE
209A:  MOVF   x7F,F
209C:  BNZ   20DE
....................    lcd_gotoxy(8,3); 
209E:  MOVLW  08
20A0:  MOVLB  1
20A2:  MOVWF  x93
20A4:  MOVLW  03
20A6:  MOVWF  x94
20A8:  MOVLB  0
20AA:  CALL   0842
....................    lcd_putc(" "); 
20AE:  MOVLW  70
20B0:  MOVWF  FF6
20B2:  MOVLW  03
20B4:  MOVWF  FF7
20B6:  CALL   0A18
....................    if(entra_temp2==4){ 
20BA:  MOVF   x82,W
20BC:  SUBLW  04
20BE:  BNZ   20CE
....................       des2=0; 
20C0:  CLRF   x99
....................       edo2=5; 
20C2:  MOVLW  05
20C4:  MOVWF  x7D
....................       entra2=0; 
20C6:  CLRF   x7E
....................       entra_act2=1;} 
20C8:  MOVLW  01
20CA:  MOVWF  x7C
20CC:  BRA    20DC
....................    else{ 
....................       des2=0; 
20CE:  CLRF   x99
....................       edo2=6; 
20D0:  MOVLW  06
20D2:  MOVWF  x7D
....................       entra2=0; 
20D4:  CLRF   x7E
....................       edoa2=0; 
20D6:  CLRF   x80
....................       entra_act2=1;} 
20D8:  MOVLW  01
20DA:  MOVWF  x7C
.................... } 
20DC:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==1)&&(sale2==0)){//entraba y se regresa 
20DE:  MOVF   x7C,F
20E0:  BNZ   2122
20E2:  MOVF   x6B,F
20E4:  BNZ   2122
20E6:  MOVF   x6C,F
20E8:  BNZ   2122
20EA:  DECFSZ x80,W
20EC:  BRA    2122
20EE:  DECFSZ x7E,W
20F0:  BRA    2122
20F2:  MOVF   x7F,F
20F4:  BNZ   2122
....................    lcd_gotoxy(8,3); 
20F6:  MOVLW  08
20F8:  MOVLB  1
20FA:  MOVWF  x93
20FC:  MOVLW  03
20FE:  MOVWF  x94
2100:  MOVLB  0
2102:  CALL   0842
....................    lcd_putc(" "); 
2106:  MOVLW  72
2108:  MOVWF  FF6
210A:  MOVLW  03
210C:  MOVWF  FF7
210E:  CALL   0A18
....................    des2=0; 
2112:  CLRF   x99
....................    edo2=6; 
2114:  MOVLW  06
2116:  MOVWF  x7D
....................    entra2=0; 
2118:  CLRF   x7E
....................    edoa2=0; 
211A:  CLRF   x80
....................    entra_act2=1;} 
211C:  MOVLW  01
211E:  MOVWF  x7C
2120:  BRA    2284
.................... ///// 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==1)&&(sale2==0)){ 
2122:  MOVF   x7C,F
2124:  BNZ   2142
2126:  DECFSZ x6B,W
2128:  BRA    2142
212A:  MOVF   x6C,F
212C:  BNZ   2142
212E:  DECFSZ x7E,W
2130:  BRA    2142
2132:  MOVF   x7F,F
2134:  BNZ   2142
....................    edo2=2; 
2136:  MOVLW  02
2138:  MOVWF  x7D
....................    edoa2=1; 
213A:  MOVLW  01
213C:  MOVWF  x80
....................    entra_act2=1;}//checar prioridad 
213E:  MOVWF  x7C
2140:  BRA    2284
.................... //////sentido inverso/// 
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
2142:  MOVF   x7C,F
2144:  BNZ   218C
2146:  MOVF   x6B,F
2148:  BNZ   218C
214A:  DECFSZ x6C,W
214C:  BRA    218C
214E:  MOVF   x7E,F
2150:  BNZ   218C
2152:  MOVF   x7F,F
2154:  BNZ   218C
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2156:  MOVF   5B,F
2158:  BNZ   2160
215A:  MOVF   5C,F
215C:  BTFSC  FD8.2
215E:  RCALL  1B40
....................    lcd_gotoxy(8,3); 
2160:  MOVLW  08
2162:  MOVLB  1
2164:  MOVWF  x93
2166:  MOVLW  03
2168:  MOVWF  x94
216A:  MOVLB  0
216C:  CALL   0842
....................    lcd_putc(0x7E);//flecha del sentido 
2170:  MOVLW  7E
2172:  MOVLB  1
2174:  MOVWF  x92
2176:  MOVLB  0
2178:  CALL   0894
....................    des2=1; 
217C:  MOVLW  01
217E:  MOVWF  x99
....................    edo2=7; 
2180:  MOVLW  07
2182:  MOVWF  x7D
....................    sale2=1; 
2184:  MOVLW  01
2186:  MOVWF  x7F
....................    entra_act2=1;} 
2188:  MOVWF  x7C
218A:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 1 
218C:  MOVF   x7C,F
218E:  BNZ   21AC
2190:  MOVF   x6B,F
2192:  BNZ   21AC
2194:  DECFSZ x6C,W
2196:  BRA    21AC
2198:  MOVF   x7E,F
219A:  BNZ   21AC
219C:  DECFSZ x7F,W
219E:  BRA    21AC
....................    edo2=8; 
21A0:  MOVLW  08
21A2:  MOVWF  x7D
....................    edoa2=1; 
21A4:  MOVLW  01
21A6:  MOVWF  x80
....................    entra_act2=1;} 
21A8:  MOVWF  x7C
21AA:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 2 
21AC:  MOVF   x7C,F
21AE:  BNZ   21CC
21B0:  DECFSZ x6B,W
21B2:  BRA    21CC
21B4:  DECFSZ x6C,W
21B6:  BRA    21CC
21B8:  MOVF   x7E,F
21BA:  BNZ   21CC
21BC:  DECFSZ x7F,W
21BE:  BRA    21CC
....................    edo2=9; 
21C0:  MOVLW  09
21C2:  MOVWF  x7D
....................    edoa2=0; 
21C4:  CLRF   x80
....................    entra_act2=1;} 
21C6:  MOVLW  01
21C8:  MOVWF  x7C
21CA:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==1)){//CASI TERMINA DE SALIR 
21CC:  MOVF   x7C,F
21CE:  BNZ   21EA
21D0:  DECFSZ x6B,W
21D2:  BRA    21EA
21D4:  MOVF   x6C,F
21D6:  BNZ   21EA
21D8:  MOVF   x7E,F
21DA:  BNZ   21EA
21DC:  DECFSZ x7F,W
21DE:  BRA    21EA
....................    edo2=10; 
21E0:  MOVLW  0A
21E2:  MOVWF  x7D
....................    entra_act2=1;} 
21E4:  MOVLW  01
21E6:  MOVWF  x7C
21E8:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==0)&&(sale2==1)){//PERSONA A SALIDO POR ENTRADA 
21EA:  MOVF   x7C,F
21EC:  BNZ   2242
21EE:  MOVF   x6B,F
21F0:  BNZ   2242
21F2:  MOVF   x6C,F
21F4:  BNZ   2242
21F6:  MOVF   x80,F
21F8:  BNZ   2242
21FA:  MOVF   x7E,F
21FC:  BNZ   2242
21FE:  DECFSZ x7F,W
2200:  BRA    2242
....................    lcd_gotoxy(8,3); 
2202:  MOVLW  08
2204:  MOVLB  1
2206:  MOVWF  x93
2208:  MOVLW  03
220A:  MOVWF  x94
220C:  MOVLB  0
220E:  CALL   0842
....................    lcd_putc(" "); 
2212:  MOVLW  74
2214:  MOVWF  FF6
2216:  MOVLW  03
2218:  MOVWF  FF7
221A:  CALL   0A18
....................    if(entra_temp2==10){ 
221E:  MOVF   x82,W
2220:  SUBLW  0A
2222:  BNZ   2232
....................       des2=0; 
2224:  CLRF   x99
....................       edo2=11; 
2226:  MOVLW  0B
2228:  MOVWF  x7D
....................       sale2=0; 
222A:  CLRF   x7F
....................       entra_act2=1;} 
222C:  MOVLW  01
222E:  MOVWF  x7C
2230:  BRA    2240
....................    else{ 
....................       des2=0; 
2232:  CLRF   x99
....................       edo2=12; 
2234:  MOVLW  0C
2236:  MOVWF  x7D
....................       sale2=0; 
2238:  CLRF   x7F
....................       edoa2=0; 
223A:  CLRF   x80
....................       entra_act2=1;} 
223C:  MOVLW  01
223E:  MOVWF  x7C
.................... } 
2240:  BRA    2284
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==0)&&(sale2==1)){//SALIA y se regresa 
2242:  MOVF   x7C,F
2244:  BNZ   2284
2246:  MOVF   x6B,F
2248:  BNZ   2284
224A:  MOVF   x6C,F
224C:  BNZ   2284
224E:  DECFSZ x80,W
2250:  BRA    2284
2252:  MOVF   x7E,F
2254:  BNZ   2284
2256:  DECFSZ x7F,W
2258:  BRA    2284
....................    lcd_gotoxy(8,3); 
225A:  MOVLW  08
225C:  MOVLB  1
225E:  MOVWF  x93
2260:  MOVLW  03
2262:  MOVWF  x94
2264:  MOVLB  0
2266:  CALL   0842
....................    lcd_putc(" "); 
226A:  MOVLW  76
226C:  MOVWF  FF6
226E:  MOVLW  03
2270:  MOVWF  FF7
2272:  CALL   0A18
....................    des2=0; 
2276:  CLRF   x99
....................    edo2=12; 
2278:  MOVLW  0C
227A:  MOVWF  x7D
....................    sale2=0; 
227C:  CLRF   x7F
....................    edoa2=0; 
227E:  CLRF   x80
....................    entra_act2=1;} 
2280:  MOVLW  01
2282:  MOVWF  x7C
2284:  RETURN 0
.................... } 
....................  
.................... void sensando3(){//Define estados para la maquina de estados del par 3 
.................... /////normal/////// 
.................... if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==0)){//LLEGA PERSONA EN ENTRADA1 
*
2308:  MOVF   x83,F
230A:  BNZ   2350
230C:  DECFSZ x6D,W
230E:  BRA    2350
2310:  MOVF   x6E,F
2312:  BNZ   2350
2314:  MOVF   x85,F
2316:  BNZ   2350
2318:  MOVF   x86,F
231A:  BNZ   2350
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
231C:  MOVF   5B,F
231E:  BNZ   2326
2320:  MOVF   5C,F
2322:  BTFSC  FD8.2
2324:  RCALL  1B40
....................    lcd_gotoxy(8,4); 
2326:  MOVLW  08
2328:  MOVLB  1
232A:  MOVWF  x93
232C:  MOVLW  04
232E:  MOVWF  x94
2330:  MOVLB  0
2332:  CALL   0842
....................    lcd_putc(0x7F); 
2336:  MOVLW  7F
2338:  MOVLB  1
233A:  MOVWF  x92
233C:  MOVLB  0
233E:  CALL   0894
....................    des3=1; 
2342:  MOVLW  01
2344:  MOVWF  x9A
....................    edo3=1; 
2346:  MOVWF  x84
....................    entra3=1; 
2348:  MOVWF  x85
....................    edoa3=1; 
234A:  MOVWF  x87
....................    entra_act3=1;} 
234C:  MOVWF  x83
234E:  BRA    258E
.................... ///prioridad 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA ENTRANDO 
2350:  MOVF   x83,F
2352:  BNZ   2370
2354:  DECFSZ x6D,W
2356:  BRA    2370
2358:  DECFSZ x6E,W
235A:  BRA    2370
235C:  DECFSZ x85,W
235E:  BRA    2370
2360:  MOVF   x86,F
2362:  BNZ   2370
....................    edo3=3; 
2364:  MOVLW  03
2366:  MOVWF  x84
....................    edoa3=0; 
2368:  CLRF   x87
....................    entra_act3=1;} 
236A:  MOVLW  01
236C:  MOVWF  x83
236E:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA CASI TERMINA DE ENTRAR 
2370:  MOVF   x83,F
2372:  BNZ   238E
2374:  MOVF   x6D,F
2376:  BNZ   238E
2378:  DECFSZ x6E,W
237A:  BRA    238E
237C:  DECFSZ x85,W
237E:  BRA    238E
2380:  MOVF   x86,F
2382:  BNZ   238E
....................    edo3=4; 
2384:  MOVLW  04
2386:  MOVWF  x84
....................    entra_act3=1;} 
2388:  MOVLW  01
238A:  MOVWF  x83
238C:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==1)&&(sale3==0)){//PERSONA A ENTRADO 
238E:  MOVF   x83,F
2390:  BNZ   23E6
2392:  MOVF   x6D,F
2394:  BNZ   23E6
2396:  MOVF   x6E,F
2398:  BNZ   23E6
239A:  MOVF   x87,F
239C:  BNZ   23E6
239E:  DECFSZ x85,W
23A0:  BRA    23E6
23A2:  MOVF   x86,F
23A4:  BNZ   23E6
....................    lcd_gotoxy(8,4); 
23A6:  MOVLW  08
23A8:  MOVLB  1
23AA:  MOVWF  x93
23AC:  MOVLW  04
23AE:  MOVWF  x94
23B0:  MOVLB  0
23B2:  CALL   0842
....................    lcd_putc(" "); 
23B6:  MOVLW  78
23B8:  MOVWF  FF6
23BA:  MOVLW  03
23BC:  MOVWF  FF7
23BE:  CALL   0A18
....................    if(entra_temp3==4){ 
23C2:  MOVF   x89,W
23C4:  SUBLW  04
23C6:  BNZ   23D6
....................       des3=0; 
23C8:  CLRF   x9A
....................       edo3=5; 
23CA:  MOVLW  05
23CC:  MOVWF  x84
....................       entra3=0; 
23CE:  CLRF   x85
....................       entra_act3=1;} 
23D0:  MOVLW  01
23D2:  MOVWF  x83
23D4:  BRA    23E4
....................    else{ 
....................       des3=0; 
23D6:  CLRF   x9A
....................       edo3=6; 
23D8:  MOVLW  06
23DA:  MOVWF  x84
....................       entra3=0; 
23DC:  CLRF   x85
....................       edoa3=0; 
23DE:  CLRF   x87
....................       entra_act3=1;} 
23E0:  MOVLW  01
23E2:  MOVWF  x83
.................... } 
23E4:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==1)&&(sale3==0)){//entraba y se regresa 
23E6:  MOVF   x83,F
23E8:  BNZ   242A
23EA:  MOVF   x6D,F
23EC:  BNZ   242A
23EE:  MOVF   x6E,F
23F0:  BNZ   242A
23F2:  DECFSZ x87,W
23F4:  BRA    242A
23F6:  DECFSZ x85,W
23F8:  BRA    242A
23FA:  MOVF   x86,F
23FC:  BNZ   242A
....................    lcd_gotoxy(8,4); 
23FE:  MOVLW  08
2400:  MOVLB  1
2402:  MOVWF  x93
2404:  MOVLW  04
2406:  MOVWF  x94
2408:  MOVLB  0
240A:  CALL   0842
....................    lcd_putc(" "); 
240E:  MOVLW  7A
2410:  MOVWF  FF6
2412:  MOVLW  03
2414:  MOVWF  FF7
2416:  CALL   0A18
....................    des3=0; 
241A:  CLRF   x9A
....................    edo3=6; 
241C:  MOVLW  06
241E:  MOVWF  x84
....................    entra3=0; 
2420:  CLRF   x85
....................    edoa3=0; 
2422:  CLRF   x87
....................    entra_act3=1;} 
2424:  MOVLW  01
2426:  MOVWF  x83
2428:  BRA    258E
.................... ///// 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==1)&&(sale3==0)){ 
242A:  MOVF   x83,F
242C:  BNZ   244A
242E:  DECFSZ x6D,W
2430:  BRA    244A
2432:  MOVF   x6E,F
2434:  BNZ   244A
2436:  DECFSZ x85,W
2438:  BRA    244A
243A:  MOVF   x86,F
243C:  BNZ   244A
....................    //sentidos(); 
....................    edo3=2; 
243E:  MOVLW  02
2440:  MOVWF  x84
....................    edoa3=1; 
2442:  MOVLW  01
2444:  MOVWF  x87
....................    entra_act3=1;}//checar prioridad 
2446:  MOVWF  x83
2448:  BRA    258E
.................... //////sentido inverso/// 
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
244A:  MOVF   x83,F
244C:  BNZ   2496
244E:  MOVF   x6D,F
2450:  BNZ   2496
2452:  DECFSZ x6E,W
2454:  BRA    2496
2456:  MOVF   x85,F
2458:  BNZ   2496
245A:  MOVF   x86,F
245C:  BNZ   2496
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
245E:  MOVF   5B,F
2460:  BNZ   246A
2462:  MOVF   5C,F
2464:  BTFSC  FD8.2
2466:  CALL   1B40
....................    lcd_gotoxy(8,4); 
246A:  MOVLW  08
246C:  MOVLB  1
246E:  MOVWF  x93
2470:  MOVLW  04
2472:  MOVWF  x94
2474:  MOVLB  0
2476:  CALL   0842
....................    lcd_putc(0x7E);//flecha del sentido 
247A:  MOVLW  7E
247C:  MOVLB  1
247E:  MOVWF  x92
2480:  MOVLB  0
2482:  CALL   0894
....................    des3=1; 
2486:  MOVLW  01
2488:  MOVWF  x9A
....................    edo3=7; 
248A:  MOVLW  07
248C:  MOVWF  x84
....................    sale3=1; 
248E:  MOVLW  01
2490:  MOVWF  x86
....................    entra_act3=1;} 
2492:  MOVWF  x83
2494:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 1 
2496:  MOVF   x83,F
2498:  BNZ   24B6
249A:  MOVF   x6D,F
249C:  BNZ   24B6
249E:  DECFSZ x6E,W
24A0:  BRA    24B6
24A2:  MOVF   x85,F
24A4:  BNZ   24B6
24A6:  DECFSZ x86,W
24A8:  BRA    24B6
....................    edo3=8; 
24AA:  MOVLW  08
24AC:  MOVWF  x84
....................    edoa3=1; 
24AE:  MOVLW  01
24B0:  MOVWF  x87
....................    entra_act3=1;} 
24B2:  MOVWF  x83
24B4:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 2 
24B6:  MOVF   x83,F
24B8:  BNZ   24D6
24BA:  DECFSZ x6D,W
24BC:  BRA    24D6
24BE:  DECFSZ x6E,W
24C0:  BRA    24D6
24C2:  MOVF   x85,F
24C4:  BNZ   24D6
24C6:  DECFSZ x86,W
24C8:  BRA    24D6
....................    edo3=9; 
24CA:  MOVLW  09
24CC:  MOVWF  x84
....................    edoa3=0; 
24CE:  CLRF   x87
....................    entra_act3=1;} 
24D0:  MOVLW  01
24D2:  MOVWF  x83
24D4:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==1)){//CASI TERMINA DE SALIR 
24D6:  MOVF   x83,F
24D8:  BNZ   24F4
24DA:  DECFSZ x6D,W
24DC:  BRA    24F4
24DE:  MOVF   x6E,F
24E0:  BNZ   24F4
24E2:  MOVF   x85,F
24E4:  BNZ   24F4
24E6:  DECFSZ x86,W
24E8:  BRA    24F4
....................    edo3=10; 
24EA:  MOVLW  0A
24EC:  MOVWF  x84
....................    entra_act3=1;} 
24EE:  MOVLW  01
24F0:  MOVWF  x83
24F2:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==0)&&(sale3==1)){//PERSONA A SALIDO POR ENTRADA 
24F4:  MOVF   x83,F
24F6:  BNZ   254C
24F8:  MOVF   x6D,F
24FA:  BNZ   254C
24FC:  MOVF   x6E,F
24FE:  BNZ   254C
2500:  MOVF   x87,F
2502:  BNZ   254C
2504:  MOVF   x85,F
2506:  BNZ   254C
2508:  DECFSZ x86,W
250A:  BRA    254C
....................    lcd_gotoxy(8,4); 
250C:  MOVLW  08
250E:  MOVLB  1
2510:  MOVWF  x93
2512:  MOVLW  04
2514:  MOVWF  x94
2516:  MOVLB  0
2518:  CALL   0842
....................    lcd_putc(" "); 
251C:  MOVLW  7C
251E:  MOVWF  FF6
2520:  MOVLW  03
2522:  MOVWF  FF7
2524:  CALL   0A18
....................    if(entra_temp3==10){ 
2528:  MOVF   x89,W
252A:  SUBLW  0A
252C:  BNZ   253C
....................       des3=0; 
252E:  CLRF   x9A
....................       edo3=11; 
2530:  MOVLW  0B
2532:  MOVWF  x84
....................       sale3=0; 
2534:  CLRF   x86
....................       entra_act3=1;} 
2536:  MOVLW  01
2538:  MOVWF  x83
253A:  BRA    254A
....................    else{ 
....................       des3=0; 
253C:  CLRF   x9A
....................       edo3=12; 
253E:  MOVLW  0C
2540:  MOVWF  x84
....................       sale3=0; 
2542:  CLRF   x86
....................       edoa3=0; 
2544:  CLRF   x87
....................       entra_act3=1;} 
2546:  MOVLW  01
2548:  MOVWF  x83
.................... } 
254A:  BRA    258E
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==0)&&(sale3==1)){//SALIA y se regresa 
254C:  MOVF   x83,F
254E:  BNZ   258E
2550:  MOVF   x6D,F
2552:  BNZ   258E
2554:  MOVF   x6E,F
2556:  BNZ   258E
2558:  DECFSZ x87,W
255A:  BRA    258E
255C:  MOVF   x85,F
255E:  BNZ   258E
2560:  DECFSZ x86,W
2562:  BRA    258E
....................    lcd_gotoxy(8,4); 
2564:  MOVLW  08
2566:  MOVLB  1
2568:  MOVWF  x93
256A:  MOVLW  04
256C:  MOVWF  x94
256E:  MOVLB  0
2570:  CALL   0842
....................    lcd_putc(" "); 
2574:  MOVLW  7E
2576:  MOVWF  FF6
2578:  MOVLW  03
257A:  MOVWF  FF7
257C:  CALL   0A18
....................    des3=0; 
2580:  CLRF   x9A
....................    edo3=12; 
2582:  MOVLW  0C
2584:  MOVWF  x84
....................    sale3=0; 
2586:  CLRF   x86
....................    edoa3=0; 
2588:  CLRF   x87
....................    entra_act3=1;} 
258A:  MOVLW  01
258C:  MOVWF  x83
258E:  RETURN 0
.................... } 
....................  
.................... void sensores(){//Detecta estado (bloqueado o libre) de los sensores 
.................... //sensor1 
.................... ent1=input(entrada01); 
*
2612:  BSF    F93.4
2614:  CLRF   55
2616:  BTFSC  F81.4
2618:  INCF   55,F
.................... if(ent1==1){ 
261A:  DECFSZ 55,W
261C:  BRA    2636
....................    sub_cta1=0; 
261E:  CLRF   5E
2620:  CLRF   5D
....................    detec1=0; 
2622:  CLRF   x69
....................    bloq_p1=0;//deshabilita bloqueo par1 
2624:  CLRF   x9B
....................    tim_p1=0; 
2626:  CLRF   xA2
2628:  CLRF   xA1
....................    if(en_b1) {//pregunta si esta sonando el par1 
262A:  MOVF   x9E,F
262C:  BZ    2634
....................       output_low(salida01);//apaga alarma bloqueo 
262E:  BCF    F94.3
2630:  BCF    F8B.3
....................       en_b1=0; 
2632:  CLRF   x9E
....................    } 
.................... } 
2634:  BRA    2690
.................... else { 
....................    if(sub_cta1>=s_cta) detec1=1;//revisa si se interumpio la luz en (5ms*4) 
2636:  MOVF   5E,F
2638:  BNZ   2640
263A:  MOVF   5D,W
263C:  SUBLW  04
263E:  BC    2644
2640:  MOVLW  01
2642:  MOVWF  x69
....................    if(sub_d1!=detec1) {//si, cambia de estado el sensor 
2644:  MOVF   x69,W
2646:  SUBWF  x6F,W
2648:  BZ    2690
....................       sub_d1=detec1; 
264A:  MOVFF  69,6F
....................       enable1=1; 
264E:  MOVLW  01
2650:  MOVWF  x7A
....................       lcd_gotoxy(5,2); 
2652:  MOVLW  05
2654:  MOVLB  1
2656:  MOVWF  x93
2658:  MOVLW  02
265A:  MOVWF  x94
265C:  MOVLB  0
265E:  CALL   0842
....................       printf(lcd_putc,"1:%d",sub_d1); 
2662:  MOVLW  31
2664:  MOVLB  1
2666:  MOVWF  x92
2668:  MOVLB  0
266A:  CALL   0894
266E:  MOVLW  3A
2670:  MOVLB  1
2672:  MOVWF  x92
2674:  MOVLB  0
2676:  CALL   0894
267A:  MOVFF  6F,189
267E:  MOVLW  18
2680:  MOVLB  1
2682:  MOVWF  x8A
2684:  MOVLB  0
2686:  CALL   10DA
....................       sensando1(); 
268A:  CALL   1B8A
....................       contando1(); 
268E:  RCALL  1F7E
....................    } 
.................... } 
.................... //sensor2 
.................... ent2=input(entrada02); 
2690:  BSF    F95.4
2692:  CLRF   56
2694:  BTFSC  F83.4
2696:  INCF   56,F
.................... if(ent2==1){ 
2698:  DECFSZ 56,W
269A:  BRA    26B8
....................    output_high(salida02);// 
269C:  BCF    F94.4
269E:  BSF    F8B.4
....................    sub_cta2=0; 
26A0:  CLRF   x60
26A2:  CLRF   5F
....................    detec2=0; 
26A4:  CLRF   x6A
....................    bloq_p1=0;//deshabilita bloqueo 
26A6:  CLRF   x9B
....................    tim_p1=0; 
26A8:  CLRF   xA2
26AA:  CLRF   xA1
....................    if(en_b1) { 
26AC:  MOVF   x9E,F
26AE:  BZ    26B6
....................       output_low(salida01);//apaga alarma bloqueo 
26B0:  BCF    F94.3
26B2:  BCF    F8B.3
....................       en_b1=0; 
26B4:  CLRF   x9E
....................    } 
.................... } 
26B6:  BRA    2720
.................... else { 
....................    output_low(salida02); 
26B8:  BCF    F94.4
26BA:  BCF    F8B.4
....................    if(sub_cta2>=s_cta) detec2=1; 
26BC:  MOVF   x60,F
26BE:  BNZ   26C6
26C0:  MOVF   5F,W
26C2:  SUBLW  04
26C4:  BC    26CA
26C6:  MOVLW  01
26C8:  MOVWF  x6A
....................    if(sub_d2!=detec2) { 
26CA:  MOVF   x6A,W
26CC:  SUBWF  x70,W
26CE:  BZ    2720
....................       sub_d2=detec2; 
26D0:  MOVFF  6A,70
....................       enable1=1; 
26D4:  MOVLW  01
26D6:  MOVWF  x7A
....................       lcd_gotoxy(1,2); 
26D8:  MOVLB  1
26DA:  MOVWF  x93
26DC:  MOVLW  02
26DE:  MOVWF  x94
26E0:  MOVLB  0
26E2:  CALL   0842
....................       printf(lcd_putc,"2:%d ",sub_d2); 
26E6:  MOVLW  32
26E8:  MOVLB  1
26EA:  MOVWF  x92
26EC:  MOVLB  0
26EE:  CALL   0894
26F2:  MOVLW  3A
26F4:  MOVLB  1
26F6:  MOVWF  x92
26F8:  MOVLB  0
26FA:  CALL   0894
26FE:  MOVFF  70,189
2702:  MOVLW  18
2704:  MOVLB  1
2706:  MOVWF  x8A
2708:  MOVLB  0
270A:  CALL   10DA
270E:  MOVLW  20
2710:  MOVLB  1
2712:  MOVWF  x92
2714:  MOVLB  0
2716:  CALL   0894
....................       sensando1(); 
271A:  CALL   1B8A
....................       contando1(); 
271E:  RCALL  1F7E
....................    } 
.................... } 
.................... //sensor3 
.................... ent3=input(entrada03); 
2720:  BSF    F93.2
2722:  CLRF   57
2724:  BTFSC  F81.2
2726:  INCF   57,F
.................... if(ent3==1){ 
2728:  DECFSZ 57,W
272A:  BRA    2744
....................    sub_cta3=0; 
272C:  CLRF   x62
272E:  CLRF   x61
....................    detec3=0; 
2730:  CLRF   x6B
....................    bloq_p2=0;//deshabilita bloqueo 
2732:  CLRF   x9C
....................    tim_p2=0; 
2734:  CLRF   xA4
2736:  CLRF   xA3
....................    if(en_b2) { 
2738:  MOVF   x9F,F
273A:  BZ    2742
....................       output_low(salida01);//apaga alarma bloqueo 
273C:  BCF    F94.3
273E:  BCF    F8B.3
....................       en_b2=0; 
2740:  CLRF   x9F
....................    } 
.................... } 
2742:  BRA    279C
.................... else { 
....................    if(sub_cta3>=s_cta) detec3=1; 
2744:  MOVF   x62,F
2746:  BNZ   274E
2748:  MOVF   x61,W
274A:  SUBLW  04
274C:  BC    2752
274E:  MOVLW  01
2750:  MOVWF  x6B
....................    if(sub_d3!=detec3) { 
2752:  MOVF   x6B,W
2754:  SUBWF  x71,W
2756:  BZ    279C
....................       sub_d3=detec3; 
2758:  MOVFF  6B,71
....................       enable2=1; 
275C:  MOVLW  01
275E:  MOVWF  x81
....................       lcd_gotoxy(5,3); 
2760:  MOVLW  05
2762:  MOVLB  1
2764:  MOVWF  x93
2766:  MOVLW  03
2768:  MOVWF  x94
276A:  MOVLB  0
276C:  CALL   0842
....................       printf(lcd_putc,"3:%d",sub_d3); 
2770:  MOVLW  33
2772:  MOVLB  1
2774:  MOVWF  x92
2776:  MOVLB  0
2778:  CALL   0894
277C:  MOVLW  3A
277E:  MOVLB  1
2780:  MOVWF  x92
2782:  MOVLB  0
2784:  CALL   0894
2788:  MOVFF  71,189
278C:  MOVLW  18
278E:  MOVLB  1
2790:  MOVWF  x8A
2792:  MOVLB  0
2794:  CALL   10DA
....................       sensando2(); 
2798:  RCALL  2000
....................       contando2(); 
279A:  RCALL  2286
....................    } 
.................... } 
.................... //sensor4 
.................... ent4=input(entrada04); 
279C:  BSF    F93.3
279E:  CLRF   58
27A0:  BTFSC  F81.3
27A2:  INCF   58,F
.................... if(ent4==1){ 
27A4:  DECFSZ 58,W
27A6:  BRA    27C4
....................    output_high(salida02);// 
27A8:  BCF    F94.4
27AA:  BSF    F8B.4
....................    sub_cta4=0; 
27AC:  CLRF   x64
27AE:  CLRF   x63
....................    detec4=0; 
27B0:  CLRF   x6C
....................    bloq_p2=0;//deshabilita bloqueo 
27B2:  CLRF   x9C
....................    tim_p2=0; 
27B4:  CLRF   xA4
27B6:  CLRF   xA3
....................    if(en_b2) { 
27B8:  MOVF   x9F,F
27BA:  BZ    27C2
....................       output_low(salida01);//apaga alarma bloqueo 
27BC:  BCF    F94.3
27BE:  BCF    F8B.3
....................       en_b2=0; 
27C0:  CLRF   x9F
....................    } 
.................... } 
27C2:  BRA    282C
.................... else { 
....................     output_low(salida02); 
27C4:  BCF    F94.4
27C6:  BCF    F8B.4
....................     if(sub_cta4>=s_cta) detec4=1; 
27C8:  MOVF   x64,F
27CA:  BNZ   27D2
27CC:  MOVF   x63,W
27CE:  SUBLW  04
27D0:  BC    27D6
27D2:  MOVLW  01
27D4:  MOVWF  x6C
....................     if(sub_d4!=detec4) { 
27D6:  MOVF   x6C,W
27D8:  SUBWF  x72,W
27DA:  BZ    282C
....................       sub_d4=detec4; 
27DC:  MOVFF  6C,72
....................       enable2=1; 
27E0:  MOVLW  01
27E2:  MOVWF  x81
....................       lcd_gotoxy(1,3); 
27E4:  MOVLB  1
27E6:  MOVWF  x93
27E8:  MOVLW  03
27EA:  MOVWF  x94
27EC:  MOVLB  0
27EE:  CALL   0842
....................       printf(lcd_putc,"4:%d ",sub_d4); 
27F2:  MOVLW  34
27F4:  MOVLB  1
27F6:  MOVWF  x92
27F8:  MOVLB  0
27FA:  CALL   0894
27FE:  MOVLW  3A
2800:  MOVLB  1
2802:  MOVWF  x92
2804:  MOVLB  0
2806:  CALL   0894
280A:  MOVFF  72,189
280E:  MOVLW  18
2810:  MOVLB  1
2812:  MOVWF  x8A
2814:  MOVLB  0
2816:  CALL   10DA
281A:  MOVLW  20
281C:  MOVLB  1
281E:  MOVWF  x92
2820:  MOVLB  0
2822:  CALL   0894
....................       sensando2(); 
2826:  CALL   2000
....................       contando2(); 
282A:  RCALL  2286
....................    } 
.................... } 
.................... //sensor5 
.................... ent5=input(entrada05); 
282C:  BSF    F93.0
282E:  CLRF   59
2830:  BTFSC  F81.0
2832:  INCF   59,F
.................... if(ent5==1){ 
2834:  DECFSZ 59,W
2836:  BRA    2850
....................    sub_cta5=0; 
2838:  CLRF   x66
283A:  CLRF   x65
....................    detec5=0; 
283C:  CLRF   x6D
....................    bloq_p3=0;//deshabilita bloqueo 
283E:  CLRF   x9D
....................    tim_p3=0; 
2840:  CLRF   xA6
2842:  CLRF   xA5
....................    if(en_b3) { 
2844:  MOVF   xA0,F
2846:  BZ    284E
....................       output_low(salida01);//apaga alarma bloqueo 
2848:  BCF    F94.3
284A:  BCF    F8B.3
....................       en_b3=0; 
284C:  CLRF   xA0
....................    } 
.................... } 
284E:  BRA    28A8
.................... else { 
....................     if(sub_cta5>=s_cta) detec5=1; 
2850:  MOVF   x66,F
2852:  BNZ   285A
2854:  MOVF   x65,W
2856:  SUBLW  04
2858:  BC    285E
285A:  MOVLW  01
285C:  MOVWF  x6D
....................     if(sub_d5!=detec5) { 
285E:  MOVF   x6D,W
2860:  SUBWF  x73,W
2862:  BZ    28A8
....................       sub_d5=detec5; 
2864:  MOVFF  6D,73
....................       enable3=1; 
2868:  MOVLW  01
286A:  MOVWF  x88
....................       lcd_gotoxy(5,4); 
286C:  MOVLW  05
286E:  MOVLB  1
2870:  MOVWF  x93
2872:  MOVLW  04
2874:  MOVWF  x94
2876:  MOVLB  0
2878:  CALL   0842
....................       printf(lcd_putc,"5:%d",sub_d5); 
287C:  MOVLW  35
287E:  MOVLB  1
2880:  MOVWF  x92
2882:  MOVLB  0
2884:  CALL   0894
2888:  MOVLW  3A
288A:  MOVLB  1
288C:  MOVWF  x92
288E:  MOVLB  0
2890:  CALL   0894
2894:  MOVFF  73,189
2898:  MOVLW  18
289A:  MOVLB  1
289C:  MOVWF  x8A
289E:  MOVLB  0
28A0:  CALL   10DA
....................       sensando3(); 
28A4:  RCALL  2308
....................       contando3(); 
28A6:  RCALL  2590
....................    } 
.................... } 
.................... //sensor6 
.................... ent6=input(entrada06); 
28A8:  BSF    F93.1
28AA:  CLRF   5A
28AC:  BTFSC  F81.1
28AE:  INCF   5A,F
.................... if(ent6==1){ 
28B0:  DECFSZ 5A,W
28B2:  BRA    28D0
....................    output_high(salida02);// 
28B4:  BCF    F94.4
28B6:  BSF    F8B.4
....................    sub_cta6=0; 
28B8:  CLRF   x68
28BA:  CLRF   x67
....................    detec6=0; 
28BC:  CLRF   x6E
....................    bloq_p3=0;//deshabilita bloqueo 
28BE:  CLRF   x9D
....................    tim_p3=0; 
28C0:  CLRF   xA6
28C2:  CLRF   xA5
....................    if(en_b3) { 
28C4:  MOVF   xA0,F
28C6:  BZ    28CE
....................       output_low(salida01);//apaga alarma bloqueo 
28C8:  BCF    F94.3
28CA:  BCF    F8B.3
....................       en_b3=0; 
28CC:  CLRF   xA0
....................    } 
.................... } 
28CE:  BRA    2936
.................... else { 
....................    output_low(salida02);// 
28D0:  BCF    F94.4
28D2:  BCF    F8B.4
....................    if(sub_cta6>=s_cta)   detec6=1; 
28D4:  MOVF   x68,F
28D6:  BNZ   28DE
28D8:  MOVF   x67,W
28DA:  SUBLW  04
28DC:  BC    28E2
28DE:  MOVLW  01
28E0:  MOVWF  x6E
....................    if(sub_d6!=detec6) { 
28E2:  MOVF   x6E,W
28E4:  SUBWF  x74,W
28E6:  BZ    2936
....................       sub_d6=detec6; 
28E8:  MOVFF  6E,74
....................       enable3=1; 
28EC:  MOVLW  01
28EE:  MOVWF  x88
....................       lcd_gotoxy(1,4); 
28F0:  MOVLB  1
28F2:  MOVWF  x93
28F4:  MOVLW  04
28F6:  MOVWF  x94
28F8:  MOVLB  0
28FA:  CALL   0842
....................       printf(lcd_putc,"6:%d ",sub_d6); 
28FE:  MOVLW  36
2900:  MOVLB  1
2902:  MOVWF  x92
2904:  MOVLB  0
2906:  CALL   0894
290A:  MOVLW  3A
290C:  MOVLB  1
290E:  MOVWF  x92
2910:  MOVLB  0
2912:  CALL   0894
2916:  MOVFF  74,189
291A:  MOVLW  18
291C:  MOVLB  1
291E:  MOVWF  x8A
2920:  MOVLB  0
2922:  CALL   10DA
2926:  MOVLW  20
2928:  MOVLB  1
292A:  MOVWF  x92
292C:  MOVLB  0
292E:  CALL   0894
....................       sensando3(); 
2932:  RCALL  2308
....................       contando3(); 
2934:  RCALL  2590
....................    } 
.................... } 
.................... ////////////////////////// 
.................... if( (detec1==1)&&(detec2==1)&&(bloq_p1==0) ){ 
2936:  DECFSZ x69,W
2938:  BRA    294A
293A:  DECFSZ x6A,W
293C:  BRA    294A
293E:  MOVF   x9B,F
2940:  BNZ   294A
....................          bloq_p1=1; 
2942:  MOVLW  01
2944:  MOVWF  x9B
....................          tim_p1=0; 
2946:  CLRF   xA2
2948:  CLRF   xA1
....................       } 
.................... if( (detec3==1)&&(detec4==1)&&(bloq_p2==0) ){ 
294A:  DECFSZ x6B,W
294C:  BRA    295E
294E:  DECFSZ x6C,W
2950:  BRA    295E
2952:  MOVF   x9C,F
2954:  BNZ   295E
....................          bloq_p2=1; 
2956:  MOVLW  01
2958:  MOVWF  x9C
....................          tim_p2=0; 
295A:  CLRF   xA4
295C:  CLRF   xA3
....................       } 
.................... if( (detec5==1)&&(detec6==1)&&(bloq_p3==0) ){ 
295E:  DECFSZ x6D,W
2960:  BRA    2972
2962:  DECFSZ x6E,W
2964:  BRA    2972
2966:  MOVF   x9D,F
2968:  BNZ   2972
....................          bloq_p3=1; 
296A:  MOVLW  01
296C:  MOVWF  x9D
....................          tim_p3=0; 
296E:  CLRF   xA6
2970:  CLRF   xA5
....................       } 
2972:  GOTO   31AE (RETURN)
.................... }//end sensores 
....................  
.................... void sentidos(){//Define si la persona esta entrando o saliendo 
....................  if( (!sen_ent)&&(!sen_sal) ){ 
*
1B40:  MOVF   5B,F
1B42:  BNZ   1B88
1B44:  MOVF   5C,F
1B46:  BNZ   1B88
....................    if ( ( (detec1==1)&&(detec3==1) )|| ( (detec1==1)&&(detec5==1) )|| ( (detec3==1)&&(detec5==1) ) ) { 
1B48:  DECFSZ x69,W
1B4A:  BRA    1B52
1B4C:  DECFSZ x6B,W
1B4E:  BRA    1B52
1B50:  BRA    1B64
1B52:  DECFSZ x69,W
1B54:  BRA    1B5C
1B56:  DECFSZ x6D,W
1B58:  BRA    1B5C
1B5A:  BRA    1B64
1B5C:  DECFSZ x6B,W
1B5E:  BRA    1B68
1B60:  DECFSZ x6D,W
1B62:  BRA    1B68
....................       sen_ent=1; 
1B64:  MOVLW  01
1B66:  MOVWF  5B
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Sub"); 
....................    } 
....................    if ( ( (detec2==1)&&(detec4==1) )|| ( (detec2==1)&&(detec6==1) )|| ( (detec4==1)&&(detec6==1) ) ) { 
1B68:  DECFSZ x6A,W
1B6A:  BRA    1B72
1B6C:  DECFSZ x6C,W
1B6E:  BRA    1B72
1B70:  BRA    1B84
1B72:  DECFSZ x6A,W
1B74:  BRA    1B7C
1B76:  DECFSZ x6E,W
1B78:  BRA    1B7C
1B7A:  BRA    1B84
1B7C:  DECFSZ x6C,W
1B7E:  BRA    1B88
1B80:  DECFSZ x6E,W
1B82:  BRA    1B88
....................       sen_sal=1; 
1B84:  MOVLW  01
1B86:  MOVWF  5C
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Baj"); 
....................    } 
....................  } 
1B88:  RETURN 0
.................... } 
....................  
.................... void rd_eeprom(){//Revisa si cadena recibida es un instruccion 
....................    a=b=0; 
*
0EE2:  CLRF   49
0EE4:  CLRF   48
0EE6:  MOVFF  48,44
....................    n=word_size;// 
0EEA:  CLRF   4B
0EEC:  MOVLW  0A
0EEE:  MOVWF  4A
....................    //i=0; 
....................    //i=2; 
....................    while ((b <=data_set)&&(a==0)){//NUMERO TOTAL DE INSTRUCCIONES 
0EF0:  MOVF   49,F
0EF2:  BNZ   0F88
0EF4:  MOVF   48,W
0EF6:  SUBLW  09
0EF8:  BNC   0F88
0EFA:  MOVF   44,F
0EFC:  BNZ   0F88
....................        i=0; 
0EFE:  CLRF   41
....................        b++; 
0F00:  INCF   48,F
0F02:  BTFSC  FD8.2
0F04:  INCF   49,F
....................        while (i < word_size) {//word_size=10 
0F06:  MOVF   41,W
0F08:  SUBLW  09
0F0A:  BNC   0F7C
....................            memory[i] = read_eeprom(n+i); 
0F0C:  CLRF   03
0F0E:  MOVF   41,W
0F10:  ADDLW  79
0F12:  MOVWF  FE9
0F14:  MOVLW  01
0F16:  ADDWFC 03,W
0F18:  MOVWF  FEA
0F1A:  MOVF   41,W
0F1C:  ADDWF  4A,W
0F1E:  MOVLB  1
0F20:  MOVWF  x8B
0F22:  MOVLW  00
0F24:  ADDWFC 4B,W
0F26:  MOVWF  x8C
0F28:  MOVFF  FF2,18D
0F2C:  BCF    FF2.7
0F2E:  MOVFF  18B,FA9
0F32:  BCF    FA6.6
0F34:  BCF    FA6.7
0F36:  BSF    FA6.0
0F38:  MOVF   FA8,W
0F3A:  BTFSC  x8D.7
0F3C:  BSF    FF2.7
0F3E:  MOVWF  FEF
....................             
....................            if (memory[i] != XX[i]) 
0F40:  CLRF   03
0F42:  MOVF   41,W
0F44:  ADDLW  79
0F46:  MOVWF  FE9
0F48:  MOVLW  01
0F4A:  ADDWFC 03,W
0F4C:  MOVWF  FEA
0F4E:  MOVFF  FEF,189
0F52:  CLRF   03
0F54:  MOVF   41,W
0F56:  ADDLW  51
0F58:  MOVWF  FE9
0F5A:  MOVLW  01
0F5C:  ADDWFC 03,W
0F5E:  MOVWF  FEA
0F60:  MOVF   FEF,W
0F62:  SUBWF  x89,W
0F64:  BZ    0F6C
....................                break; 
0F66:  MOVLB  0
0F68:  BRA    0F7C
0F6A:  MOVLB  1
....................            i++; 
0F6C:  INCF   41,F
....................            if (i==word_size) a=1; 
0F6E:  MOVF   41,W
0F70:  SUBLW  0A
0F72:  BNZ   0F78
0F74:  MOVLW  01
0F76:  MOVWF  44
0F78:  MOVLB  0
0F7A:  BRA    0F06
....................        } 
....................        //fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
0F7C:  MOVLW  0A
0F7E:  ADDWF  4A,F
0F80:  MOVLW  00
0F82:  ADDWFC 4B,F
....................        restart_wdt(); 
0F84:  CLRWDT
0F86:  BRA    0EF0
....................    } 
0F88:  GOTO   2DE6 (RETURN)
.................... } 
....................  
.................... void rd_eeprom_inicio(){// 
....................    a=b=0; 
....................    n=word_size;// 
....................     
....................    while (b <=data_set){//NUMERO TOTAL DE INSTRUCCIONES 
....................        i=0; 
....................        b++; 
....................        while (i < word_size) {//word_size=10 
....................            memory[i] = read_eeprom(n+i); 
....................            i++; 
....................            if (i==word_size) a=1; 
....................        } 
....................        fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
....................        //restart_wdt(); 
....................    } 
.................... } 
....................  
.................... /* 
.................... void llaves(){//Graba las instrucciones de control en eeprom 
.................... int tem; 
.................... ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
....................       switch (tem) { 
....................         case 1:{for (i=0;i<word_size;++i)  texto[i]=texto1[i]; 
....................               break;} 
....................         case 2:{for (i=0;i<word_size;++i)  texto[i]=texto2[i]; 
....................               break;} 
....................         case 3:{for (i=0;i<word_size;++i)  texto[i]=texto3[i]; 
....................               break;} 
....................         case 4:{for (i=0;i<word_size;++i)  texto[i]=texto4[i]; 
....................               break;} 
....................         case 5:{for (i=0;i<word_size;++i)  texto[i]=texto5[i]; 
....................               break;} 
....................         case 6:{for (i=0;i<word_size;++i)  texto[i]=texto6[i]; 
....................               break;} 
....................         case 7:{for (i=0;i<word_size;++i)  texto[i]=texto7[i]; 
....................               break;} 
....................         case 8:{for (i=0;i<word_size;++i)  texto[i]=texto8[i]; 
....................               break;} 
....................         case 9:{for (i=0;i<word_size;++i)  texto[i]=texto9[i]; 
....................               break;} 
....................       } 
....................       a=i=0; 
....................       while (i < word_size) {  //word_size=8 
....................               memory[i] = read_eeprom((tem*word_size)+i); 
....................               fprintf(monitor,"tx[]:%s",texto); 
....................               if (memory[i] != texto[i]){ 
....................              // fprintf(monitor,"es diferente."); 
....................               break; 
....................               } 
....................               i++; 
....................               if (i==word_size){ 
....................              // fprintf(monitor,"a=1"); 
....................               a=1; 
....................               } 
....................       } 
....................       if (a==0){ 
....................          i=0; 
....................          fprintf(monitor,"e."); 
....................         // fprintf(monitor,"texto[]:%s",texto); 
....................          while (texto[i] != 0x00){ 
....................             write_eeprom(i+(tem*word_size),texto[i]); 
....................             i++; 
....................          } 
....................       } 
....................    }//end for 
.................... } 
.................... */ 
....................  
.................... void lcd_cuentas(){//Escribe las cuenta en LCD  
....................     lcd_gotoxy(1,1); 
*
0A38:  MOVLW  01
0A3A:  MOVLB  1
0A3C:  MOVWF  x93
0A3E:  MOVWF  x94
0A40:  MOVLB  0
0A42:  RCALL  0842
....................     if(master) { 
0A44:  MOVF   45,F
0A46:  BTFSC  FD8.2
0A48:  BRA    0B68
....................        printf(lcd_putc,"1 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0A4A:  MOVLW  31
0A4C:  MOVLB  1
0A4E:  MOVWF  x92
0A50:  MOVLB  0
0A52:  RCALL  0894
0A54:  MOVLW  20
0A56:  MOVLB  1
0A58:  MOVWF  x92
0A5A:  MOVLB  0
0A5C:  RCALL  0894
0A5E:  MOVFF  14B,192
0A62:  RCALL  0894
0A64:  MOVFF  14C,192
0A68:  RCALL  0894
0A6A:  MOVFF  14D,192
0A6E:  RCALL  0894
0A70:  MOVFF  14E,192
0A74:  RCALL  0894
0A76:  MOVFF  14F,192
0A7A:  RCALL  0894
0A7C:  MOVLW  20
0A7E:  MOVLB  1
0A80:  MOVWF  x92
0A82:  MOVLB  0
0A84:  RCALL  0894
....................        lcd_gotoxy(14,1); 
0A86:  MOVLW  0E
0A88:  MOVLB  1
0A8A:  MOVWF  x93
0A8C:  MOVLW  01
0A8E:  MOVWF  x94
0A90:  MOVLB  0
0A92:  RCALL  0842
....................        printf(lcd_putc,"S1:%Ld ",entraront); 
0A94:  MOVLW  8C
0A96:  MOVWF  FF6
0A98:  MOVLW  03
0A9A:  MOVWF  FF7
0A9C:  MOVLW  03
0A9E:  MOVLB  1
0AA0:  MOVWF  x89
0AA2:  MOVLB  0
0AA4:  RCALL  08F4
0AA6:  MOVLW  10
0AA8:  MOVWF  FE9
0AAA:  MOVFF  8B,18A
0AAE:  MOVFF  8A,189
0AB2:  RCALL  091C
0AB4:  MOVLW  20
0AB6:  MOVLB  1
0AB8:  MOVWF  x92
0ABA:  MOVLB  0
0ABC:  RCALL  0894
....................        lcd_gotoxy(14,2); 
0ABE:  MOVLW  0E
0AC0:  MOVLB  1
0AC2:  MOVWF  x93
0AC4:  MOVLW  02
0AC6:  MOVWF  x94
0AC8:  MOVLB  0
0ACA:  RCALL  0842
....................        printf(lcd_putc,"B1:%Ld ",salieront); 
0ACC:  MOVLW  94
0ACE:  MOVWF  FF6
0AD0:  MOVLW  03
0AD2:  MOVWF  FF7
0AD4:  MOVLW  03
0AD6:  MOVLB  1
0AD8:  MOVWF  x89
0ADA:  MOVLB  0
0ADC:  RCALL  08F4
0ADE:  MOVLW  10
0AE0:  MOVWF  FE9
0AE2:  MOVFF  8D,18A
0AE6:  MOVFF  8C,189
0AEA:  RCALL  091C
0AEC:  MOVLW  20
0AEE:  MOVLB  1
0AF0:  MOVWF  x92
0AF2:  MOVLB  0
0AF4:  RCALL  0894
....................        lcd_gotoxy(14,3); 
0AF6:  MOVLW  0E
0AF8:  MOVLB  1
0AFA:  MOVWF  x93
0AFC:  MOVLW  03
0AFE:  MOVWF  x94
0B00:  MOVLB  0
0B02:  RCALL  0842
....................        printf(lcd_putc,"S2:%Ld ",sub_atras); 
0B04:  MOVLW  9C
0B06:  MOVWF  FF6
0B08:  MOVLW  03
0B0A:  MOVWF  FF7
0B0C:  MOVLW  03
0B0E:  MOVLB  1
0B10:  MOVWF  x89
0B12:  MOVLB  0
0B14:  RCALL  08F4
0B16:  MOVLW  10
0B18:  MOVWF  FE9
0B1A:  MOVFF  35,18A
0B1E:  MOVFF  34,189
0B22:  RCALL  091C
0B24:  MOVLW  20
0B26:  MOVLB  1
0B28:  MOVWF  x92
0B2A:  MOVLB  0
0B2C:  RCALL  0894
....................        lcd_gotoxy(14,4); 
0B2E:  MOVLW  0E
0B30:  MOVLB  1
0B32:  MOVWF  x93
0B34:  MOVLW  04
0B36:  MOVWF  x94
0B38:  MOVLB  0
0B3A:  RCALL  0842
....................        printf(lcd_putc,"B2:%Ld ",baj_atras); 
0B3C:  MOVLW  A4
0B3E:  MOVWF  FF6
0B40:  MOVLW  03
0B42:  MOVWF  FF7
0B44:  MOVLW  03
0B46:  MOVLB  1
0B48:  MOVWF  x89
0B4A:  MOVLB  0
0B4C:  RCALL  08F4
0B4E:  MOVLW  10
0B50:  MOVWF  FE9
0B52:  MOVFF  37,18A
0B56:  MOVFF  36,189
0B5A:  RCALL  091C
0B5C:  MOVLW  20
0B5E:  MOVLB  1
0B60:  MOVWF  x92
0B62:  MOVLB  0
0B64:  RCALL  0894
....................     } 
0B66:  BRA    0C44
....................     else{ 
....................        printf(lcd_putc,"2 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0B68:  MOVLW  32
0B6A:  MOVLB  1
0B6C:  MOVWF  x92
0B6E:  MOVLB  0
0B70:  RCALL  0894
0B72:  MOVLW  20
0B74:  MOVLB  1
0B76:  MOVWF  x92
0B78:  MOVLB  0
0B7A:  RCALL  0894
0B7C:  MOVFF  14B,192
0B80:  RCALL  0894
0B82:  MOVFF  14C,192
0B86:  RCALL  0894
0B88:  MOVFF  14D,192
0B8C:  RCALL  0894
0B8E:  MOVFF  14E,192
0B92:  RCALL  0894
0B94:  MOVFF  14F,192
0B98:  RCALL  0894
0B9A:  MOVLW  20
0B9C:  MOVLB  1
0B9E:  MOVWF  x92
0BA0:  MOVLB  0
0BA2:  RCALL  0894
....................        lcd_gotoxy(14,1); 
0BA4:  MOVLW  0E
0BA6:  MOVLB  1
0BA8:  MOVWF  x93
0BAA:  MOVLW  01
0BAC:  MOVWF  x94
0BAE:  MOVLB  0
0BB0:  RCALL  0842
....................        lcd_putc("S1:    "); 
0BB2:  MOVLW  AC
0BB4:  MOVWF  FF6
0BB6:  MOVLW  03
0BB8:  MOVWF  FF7
0BBA:  RCALL  0A18
....................        lcd_gotoxy(14,2); 
0BBC:  MOVLW  0E
0BBE:  MOVLB  1
0BC0:  MOVWF  x93
0BC2:  MOVLW  02
0BC4:  MOVWF  x94
0BC6:  MOVLB  0
0BC8:  RCALL  0842
....................        lcd_putc("B1:    "); 
0BCA:  MOVLW  B4
0BCC:  MOVWF  FF6
0BCE:  MOVLW  03
0BD0:  MOVWF  FF7
0BD2:  RCALL  0A18
....................        lcd_gotoxy(14,3); 
0BD4:  MOVLW  0E
0BD6:  MOVLB  1
0BD8:  MOVWF  x93
0BDA:  MOVLW  03
0BDC:  MOVWF  x94
0BDE:  MOVLB  0
0BE0:  RCALL  0842
....................        printf(lcd_putc,"S2:%Ld ",entraront); 
0BE2:  MOVLW  BC
0BE4:  MOVWF  FF6
0BE6:  MOVLW  03
0BE8:  MOVWF  FF7
0BEA:  MOVLW  03
0BEC:  MOVLB  1
0BEE:  MOVWF  x89
0BF0:  MOVLB  0
0BF2:  RCALL  08F4
0BF4:  MOVLW  10
0BF6:  MOVWF  FE9
0BF8:  MOVFF  8B,18A
0BFC:  MOVFF  8A,189
0C00:  RCALL  091C
0C02:  MOVLW  20
0C04:  MOVLB  1
0C06:  MOVWF  x92
0C08:  MOVLB  0
0C0A:  RCALL  0894
....................        lcd_gotoxy(14,4); 
0C0C:  MOVLW  0E
0C0E:  MOVLB  1
0C10:  MOVWF  x93
0C12:  MOVLW  04
0C14:  MOVWF  x94
0C16:  MOVLB  0
0C18:  RCALL  0842
....................        printf(lcd_putc,"B2:%Ld ",salieront); 
0C1A:  MOVLW  C4
0C1C:  MOVWF  FF6
0C1E:  MOVLW  03
0C20:  MOVWF  FF7
0C22:  MOVLW  03
0C24:  MOVLB  1
0C26:  MOVWF  x89
0C28:  MOVLB  0
0C2A:  RCALL  08F4
0C2C:  MOVLW  10
0C2E:  MOVWF  FE9
0C30:  MOVFF  8D,18A
0C34:  MOVFF  8C,189
0C38:  RCALL  091C
0C3A:  MOVLW  20
0C3C:  MOVLB  1
0C3E:  MOVWF  x92
0C40:  MOVLB  0
0C42:  RCALL  0894
....................     } 
0C44:  RETURN 0
....................      
.................... } 
....................  
.................... void write_ent(){//Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0C84:  BCF    FF2.6
0C86:  BCF    FF2.7
0C88:  BTFSC  FF2.7
0C8A:  BRA    0C86
....................    write_ext_eeprom(2,entraront);//parte baja 
0C8C:  MOVLB  1
0C8E:  CLRF   x8E
0C90:  MOVLW  02
0C92:  MOVWF  x8D
0C94:  MOVFF  8A,18F
0C98:  MOVLB  0
0C9A:  RCALL  0588
....................    write_ext_eeprom(1,(entraront>>8) );//parte alta 
0C9C:  MOVFF  8B,189
0CA0:  MOVLB  1
0CA2:  CLRF   x8A
0CA4:  CLRF   x8E
0CA6:  MOVLW  01
0CA8:  MOVWF  x8D
0CAA:  MOVFF  8B,18F
0CAE:  MOVLB  0
0CB0:  RCALL  0588
....................    enable_interrupts(GLOBAL); 
0CB2:  MOVLW  C0
0CB4:  IORWF  FF2,F
....................    finsuma(); 
0CB6:  RCALL  0C46
0CB8:  RETURN 0
.................... } 
....................  
.................... void write_sal(){//Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0CBA:  BCF    FF2.6
0CBC:  BCF    FF2.7
0CBE:  BTFSC  FF2.7
0CC0:  BRA    0CBC
....................    write_ext_eeprom(4,salieront);//parte baja 
0CC2:  MOVLB  1
0CC4:  CLRF   x8E
0CC6:  MOVLW  04
0CC8:  MOVWF  x8D
0CCA:  MOVFF  8C,18F
0CCE:  MOVLB  0
0CD0:  RCALL  0588
....................    write_ext_eeprom(3,(salieront>>8) );//parte alta 
0CD2:  MOVFF  8D,189
0CD6:  MOVLB  1
0CD8:  CLRF   x8A
0CDA:  CLRF   x8E
0CDC:  MOVLW  03
0CDE:  MOVWF  x8D
0CE0:  MOVFF  8D,18F
0CE4:  MOVLB  0
0CE6:  RCALL  0588
....................    enable_interrupts(GLOBAL); 
0CE8:  MOVLW  C0
0CEA:  IORWF  FF2,F
....................    finsuma(); 
0CEC:  RCALL  0C46
0CEE:  RETURN 0
.................... } 
....................  
.................... void entraron_total(){//Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D5C:  BCF    FF2.6
0D5E:  BCF    FF2.7
0D60:  BTFSC  FF2.7
0D62:  BRA    0D5E
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0D64:  MOVLB  1
0D66:  CLRF   x89
0D68:  CLRF   x8A
0D6A:  CLRF   x8C
0D6C:  CLRF   x8B
....................     
....................    reg_h=read_ext_eeprom(1); 
0D6E:  CLRF   x8E
0D70:  MOVLW  01
0D72:  MOVWF  x8D
0D74:  MOVLB  0
0D76:  RCALL  0748
0D78:  MOVFF  01,189
....................    reg_l=read_ext_eeprom(2); 
0D7C:  MOVLB  1
0D7E:  CLRF   x8E
0D80:  MOVLW  02
0D82:  MOVWF  x8D
0D84:  MOVLB  0
0D86:  RCALL  0748
0D88:  MOVFF  01,18A
....................    total=reg_h; 
0D8C:  MOVLB  1
0D8E:  CLRF   x8C
0D90:  MOVFF  189,18B
....................    total=(total<<8)|reg_l; 
0D94:  MOVFF  18B,18E
0D98:  CLRF   x8D
0D9A:  MOVF   x8D,W
0D9C:  IORWF  x8A,W
0D9E:  MOVWF  x8B
0DA0:  MOVFF  18E,18C
....................    entraront=total; 
0DA4:  MOVFF  18C,8B
0DA8:  MOVFF  18B,8A
....................    enable_interrupts(GLOBAL); 
0DAC:  MOVLW  C0
0DAE:  IORWF  FF2,F
0DB0:  MOVLB  0
0DB2:  GOTO   2BC8 (RETURN)
.................... } 
....................  
.................... void salieron_total(){//Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0DB6:  BCF    FF2.6
0DB8:  BCF    FF2.7
0DBA:  BTFSC  FF2.7
0DBC:  BRA    0DB8
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0DBE:  MOVLB  1
0DC0:  CLRF   x89
0DC2:  CLRF   x8A
0DC4:  CLRF   x8C
0DC6:  CLRF   x8B
....................     
....................    reg_h=read_ext_eeprom(3); 
0DC8:  CLRF   x8E
0DCA:  MOVLW  03
0DCC:  MOVWF  x8D
0DCE:  MOVLB  0
0DD0:  RCALL  0748
0DD2:  MOVFF  01,189
....................    reg_l=read_ext_eeprom(4); 
0DD6:  MOVLB  1
0DD8:  CLRF   x8E
0DDA:  MOVLW  04
0DDC:  MOVWF  x8D
0DDE:  MOVLB  0
0DE0:  RCALL  0748
0DE2:  MOVFF  01,18A
....................    total=reg_h; 
0DE6:  MOVLB  1
0DE8:  CLRF   x8C
0DEA:  MOVFF  189,18B
....................    total=(total<<8)|reg_l; 
0DEE:  MOVFF  18B,18E
0DF2:  CLRF   x8D
0DF4:  MOVF   x8D,W
0DF6:  IORWF  x8A,W
0DF8:  MOVWF  x8B
0DFA:  MOVFF  18E,18C
....................    salieront=total; 
0DFE:  MOVFF  18C,8D
0E02:  MOVFF  18B,8C
....................    enable_interrupts(GLOBAL); 
0E06:  MOVLW  C0
0E08:  IORWF  FF2,F
0E0A:  MOVLB  0
0E0C:  GOTO   2BCC (RETURN)
.................... } 
....................  
.................... void graba_conta2(){//Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
068E:  BCF    FF2.6
0690:  BCF    FF2.7
0692:  BTFSC  FF2.7
0694:  BRA    0690
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
0696:  MOVLB  1
0698:  CLRF   x89
069A:  CLRF   x8A
069C:  CLRF   x8C
069E:  CLRF   x8B
....................    totalc=0; 
06A0:  CLRF   x8C
06A2:  CLRF   x8B
....................    reg_lc=0; 
06A4:  CLRF   x8A
....................    reg_hc=0; 
06A6:  CLRF   x89
....................     
....................    totalc=salian; 
06A8:  MOVFF  3D,18C
06AC:  MOVFF  3C,18B
....................    reg_lc=totalc; 
06B0:  MOVFF  18B,18A
....................    reg_hc=totalc>>8; 
06B4:  MOVFF  18C,189
....................    write_ext_eeprom(20,reg_hc); 
06B8:  CLRF   x8E
06BA:  MOVLW  14
06BC:  MOVWF  x8D
06BE:  MOVFF  189,18F
06C2:  MOVLB  0
06C4:  RCALL  0588
....................    write_ext_eeprom(21,reg_lc); 
06C6:  MOVLB  1
06C8:  CLRF   x8E
06CA:  MOVLW  15
06CC:  MOVWF  x8D
06CE:  MOVFF  18A,18F
06D2:  MOVLB  0
06D4:  RCALL  0588
....................    enable_interrupts(GLOBAL); 
06D6:  MOVLW  C0
06D8:  IORWF  FF2,F
06DA:  RETURN 0
.................... } 
....................  
.................... void leer_conta2(){//Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
07F0:  BCF    FF2.6
07F2:  BCF    FF2.7
07F4:  BTFSC  FF2.7
07F6:  BRA    07F2
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
07F8:  MOVLB  1
07FA:  CLRF   x89
07FC:  CLRF   x8A
07FE:  CLRF   x8C
0800:  CLRF   x8B
....................     
....................    reg_hc=read_ext_eeprom(20); 
0802:  CLRF   x8E
0804:  MOVLW  14
0806:  MOVWF  x8D
0808:  MOVLB  0
080A:  RCALL  0748
080C:  MOVFF  01,189
....................    reg_lc=read_ext_eeprom(21); 
0810:  MOVLB  1
0812:  CLRF   x8E
0814:  MOVLW  15
0816:  MOVWF  x8D
0818:  MOVLB  0
081A:  RCALL  0748
081C:  MOVFF  01,18A
....................    totalc=reg_hc; 
0820:  MOVLB  1
0822:  CLRF   x8C
0824:  MOVFF  189,18B
....................    totalc=totalc<<8; 
0828:  MOVFF  18B,18C
082C:  CLRF   x8B
....................    totalc=totalc|reg_lc; 
082E:  MOVF   x8A,W
0830:  IORWF  x8B,F
....................    salian=totalc; 
0832:  MOVFF  18C,3D
0836:  MOVFF  18B,3C
....................    enable_interrupts(GLOBAL); 
083A:  MOVLW  C0
083C:  IORWF  FF2,F
083E:  MOVLB  0
0840:  RETURN 0
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) { 
*
0E32:  MOVF   FD0,W
0E34:  ANDLW  0F
0E36:  BTFSS  FD0.4
0E38:  MOVLW  00
0E3A:  BSF    FD0.0
0E3C:  BSF    FD0.1
0E3E:  BSF    FD0.4
0E40:  BSF    FD8.3
0E42:  BSF    FD8.4
0E44:  XORLW  07
0E46:  BZ    0E56
0E48:  XORLW  08
0E4A:  BZ    0E58
0E4C:  XORLW  01
0E4E:  BZ    0E64
0E50:  XORLW  02
0E52:  BZ    0E66
0E54:  BRA    0E66
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          break;} 
0E56:  BRA    0E66
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          fprintf(monitor,"SERIALTEST\r\n"); 
0E58:  MOVLW  CC
0E5A:  MOVWF  FF6
0E5C:  MOVLW  03
0E5E:  MOVWF  FF7
0E60:  RCALL  0E10
....................          //fprintf(monitor,"0\r"); 
....................          break;} 
0E62:  BRA    0E66
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          break; 
0E64:  BRA    0E66
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          break; 
....................       }//END MODO 
....................    } 
0E66:  GOTO   2CAA (RETURN)
.................... } 
....................  
....................  
.................... int evaluar_string(char *command[]){ 
*
1006:  MOVLB  1
1008:  CLRF   x8B
....................   // fprintf(monitor,"<"); 
....................   // fprintf(monitor,"%s",command); 
....................   // fprintf(monitor,">"); 
....................    int conteo_command=0; 
....................    int iresult; 
....................    while(conteo_command<=10){ 
100A:  MOVF   x8B,W
100C:  SUBLW  0A
100E:  BNC   1056
....................    //lcd_gotoxy(9,4); 
....................    //printf(lcd_putc,"%c%c%c",command[0],command[1],command[8]);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................    iresult=strcoll(textosearch[conteo_command],command); 
1010:  CLRF   03
1012:  MOVFF  18B,02
1016:  BCF    FD8.0
1018:  RLCF   02,F
101A:  RLCF   03,F
101C:  MOVF   02,W
101E:  ADDLW  B1
1020:  MOVWF  FE9
1022:  MOVLW  00
1024:  ADDWFC 03,W
1026:  MOVWF  FEA
1028:  MOVFF  FEC,18E
102C:  MOVF   FED,F
102E:  MOVFF  FEF,18D
1032:  MOVFF  18E,190
1036:  MOVFF  18D,18F
103A:  MOVFF  18A,192
103E:  MOVFF  189,191
1042:  MOVLB  0
1044:  BRA    0F8C
1046:  MOVFF  01,18C
....................   // fprintf(monitor,"%d",iresult); 
....................   // fprintf(monitor,"%s",textosearch[conteo_command]); 
....................    if(iresult==0){ 
104A:  MOVLB  1
104C:  MOVF   x8C,F
104E:  BNZ   1052
....................   // fprintf(monitor,"Encontrado"); 
....................    //return (conteo_command); 
....................    break; 
1050:  BRA    1056
....................    } 
....................    //if(conteo_command==5){ 
....................       
....................  
....................    //} 
....................    
....................    conteo_command++; 
1052:  INCF   x8B,F
1054:  BRA    100A
....................    } 
....................       if(XX[1]=='A' && XX[2]=='S' && XX[3]=='A' && XX[4]=='J' && XX[5]=='E' && XX[6]=='R' && XX[7]=='O' && XX[8]=='S') 
1056:  MOVF   x52,W
1058:  SUBLW  41
105A:  BNZ   10A4
105C:  MOVF   x53,W
105E:  SUBLW  53
1060:  BNZ   10A4
1062:  MOVF   x54,W
1064:  SUBLW  41
1066:  BNZ   10A4
1068:  MOVF   x55,W
106A:  SUBLW  4A
106C:  BNZ   10A4
106E:  MOVF   x56,W
1070:  SUBLW  45
1072:  BNZ   10A4
1074:  MOVF   x57,W
1076:  SUBLW  52
1078:  BNZ   10A4
107A:  MOVF   x58,W
107C:  SUBLW  4F
107E:  BNZ   10A4
1080:  MOVF   x59,W
1082:  SUBLW  53
1084:  BNZ   10A4
....................       { 
....................          conteo_command = 5; 
1086:  MOVLW  05
1088:  MOVWF  x8B
....................          lcd_gotoxy(9,2); 
108A:  MOVLW  09
108C:  MOVWF  x93
108E:  MOVLW  02
1090:  MOVWF  x94
1092:  MOVLB  0
1094:  CALL   0842
....................          printf(lcd_putc,"C=5"); 
1098:  MOVLW  DA
109A:  MOVWF  FF6
109C:  MOVLW  03
109E:  MOVWF  FF7
10A0:  RCALL  0A18
10A2:  MOVLB  1
....................       } 
....................      
....................    return conteo_command; 
10A4:  MOVFF  18B,01
10A8:  MOVLB  0
10AA:  GOTO   2DF6 (RETURN)
....................  
....................    } 
....................     

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
