CCS PCH C Compiler, Version 5.025, 24934               06-may.-22 11:16

               Filename:   D:\PROYECTOS\TRANSPORTE\ENCAPSULADO NUEVO\Contadores_V5.02\MASTER\CONTADOR_V5.lst

               ROM used:   13972 bytes (43%)
                           Largest free fragment is 18792
               RAM used:   460 (30%) at main() level
                           486 (32%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2E4C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0214
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00EE
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   01A2
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... //2021/05/13 *V5.01 Se recalcula frecuencia de IR 
.................... //2020/03/31 *V4.A1 Se agrega etiqueta para identificar por LCD si hay comunicacion entre los postes 
.................... //2020/02/28 *V04.A Se modifica codigo para evitar que postes cuenten solos 
.................... //2019/12/09 Se modifica la forma de contar con sensores bloqueados 
.................... //2019/11/19 Se modifica codigo para detectar una recepcion serial de dato poste posterior erronea, asi como identificar error de conexion tambien, 
.................... //           Se quita funcion de boton silenciador que nunca se uso 
.................... //2019/11/14 Se modifica la escucha de la cuenta del poste secundario, se cambia limite a 20 para dato posterior recibido. 
.................... //D01.2 2019/03/28 Se agrega cambios para confirmar reset a nuevo GSM y enter al final de envio de cuenta 
.................... //                 Se discriminan los primneros 2 caracteres de validacion serial 
.................... // ultima modificacion; 
.................... /* 
.................... VER.  FECHA 
.................... D02.6 2019/12/09 Cambia la forma de contar 
.................... - Poste de datos esta identificado como 1, el esclavo como 2 
.................... */ 
....................  
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 28,0C
00D8:  DATA 01,06
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 3A,2F
00EC:  DATA 00,00
*
026E:  DATA 42,4F
0270:  DATA 52,52
0272:  DATA 41,52
0274:  DATA 5F,41
0276:  DATA 4C,4C
0278:  DATA 0D,00
027A:  DATA 0C,42
027C:  DATA 4F,52
027E:  DATA 52,41
0280:  DATA 52,5F
0282:  DATA 41,4C
0284:  DATA 4C,00
0286:  DATA 42,4F
0288:  DATA 52,52
028A:  DATA 41,52
028C:  DATA 5F,41
028E:  DATA 4C,4C
0290:  DATA 0D,00
0292:  DATA 52,45
0294:  DATA 53,45
0296:  DATA 54,5F
0298:  DATA 4F,4B
029A:  DATA 0D,0A
029C:  DATA 00,00
029E:  DATA 42,4F
02A0:  DATA 52,52
02A2:  DATA 41,52
02A4:  DATA 5F,41
02A6:  DATA 4C,4C
02A8:  DATA 0D,00
02AA:  DATA 43,32
02AC:  DATA 4F,4B
02AE:  DATA 00,00
02B0:  DATA 43,31
02B2:  DATA 4F,4B
02B4:  DATA 00,00
02B6:  DATA 53,45
02B8:  DATA 52,49
02BA:  DATA 41,4C
02BC:  DATA 5F,54
02BE:  DATA 4F,4B
02C0:  DATA 0D,00
02C2:  DATA 43,32
02C4:  DATA 4F,4B
02C6:  DATA 00,00
02C8:  DATA 53,75
02CA:  DATA 62,32
02CC:  DATA 00,00
02CE:  DATA 63,3D
02D0:  DATA 30,00
02D2:  DATA 20,20
02D4:  DATA 20,20
02D6:  DATA 00,00
02D8:  DATA 20,20
02DA:  DATA 20,20
02DC:  DATA 00,00
02DE:  DATA 20,20
02E0:  DATA 20,20
02E2:  DATA 00,00
02E4:  DATA 42,4C
02E6:  DATA 00,00
02E8:  DATA 42,4C
02EA:  DATA 00,00
02EC:  DATA 42,4C
02EE:  DATA 00,00
02F0:  DATA 20,20
02F2:  DATA 00,00
02F4:  DATA 53,4F
02F6:  DATA 4C,49
02F8:  DATA 43,49
02FA:  DATA 54,41
02FC:  DATA 44,4F
02FE:  DATA 0D,00
0300:  DATA 50,41
0302:  DATA 53,41
0304:  DATA 4A,45
0306:  DATA 52,4F
0308:  DATA 53,3A
030A:  DATA 0D,00
030C:  DATA 53,32
030E:  DATA 3A,25
0310:  DATA 4C,64
0312:  DATA 20,00
0314:  DATA 42,32
0316:  DATA 3A,25
0318:  DATA 4C,64
031A:  DATA 20,00
031C:  DATA 41,43
031E:  DATA 43,2B
0320:  DATA 30,31
0322:  DATA 3A,25
0324:  DATA 30,34
0326:  DATA 4C,75
0328:  DATA 2C,25
032A:  DATA 30,34
032C:  DATA 4C,75
032E:  DATA 2C,25
0330:  DATA 30,34
0332:  DATA 4C,75
0334:  DATA 2C,25
0336:  DATA 30,33
0338:  DATA 4C,75
033A:  DATA 2C,25
033C:  DATA 30,33
033E:  DATA 4C,75
0340:  DATA 2C,25
0342:  DATA 30,32
0344:  DATA 75,2C
0346:  DATA 0D,0A
0348:  DATA 00,00
034A:  DATA 41,43
034C:  DATA 43,2B
034E:  DATA 30,31
0350:  DATA 3A,25
0352:  DATA 30,34
0354:  DATA 4C,75
0356:  DATA 2C,25
0358:  DATA 30,34
035A:  DATA 4C,75
035C:  DATA 2C,44
035E:  DATA 45,53
0360:  DATA 43,2C
0362:  DATA 25,30
0364:  DATA 33,4C
0366:  DATA 75,2C
0368:  DATA 30,30
036A:  DATA 30,2C
036C:  DATA 25,30
036E:  DATA 32,75
0370:  DATA 2C,0D
0372:  DATA 0A,00
0374:  DATA 44,45
0376:  DATA 53,43
0378:  DATA 00,00
037A:  DATA 0C,00
037C:  DATA 20,00
037E:  DATA 20,00
0380:  DATA 20,00
0382:  DATA 20,00
0384:  DATA 20,00
0386:  DATA 20,00
0388:  DATA 20,00
038A:  DATA 20,00
038C:  DATA 20,00
038E:  DATA 20,00
0390:  DATA 20,00
0392:  DATA 20,00
0394:  DATA 6D,65
0396:  DATA 6D,6F
0398:  DATA 72,79
039A:  DATA 3A,25
039C:  DATA 73,0D
039E:  DATA 00,00
03A0:  DATA 53,31
03A2:  DATA 3A,25
03A4:  DATA 4C,64
03A6:  DATA 20,00
03A8:  DATA 42,31
03AA:  DATA 3A,25
03AC:  DATA 4C,64
03AE:  DATA 20,00
03B0:  DATA 53,32
03B2:  DATA 3A,25
03B4:  DATA 4C,64
03B6:  DATA 20,00
03B8:  DATA 42,32
03BA:  DATA 3A,25
03BC:  DATA 4C,64
03BE:  DATA 20,00
03C0:  DATA 53,31
03C2:  DATA 3A,20
03C4:  DATA 20,20
03C6:  DATA 20,00
03C8:  DATA 42,31
03CA:  DATA 3A,20
03CC:  DATA 20,20
03CE:  DATA 20,00
03D0:  DATA 53,32
03D2:  DATA 3A,25
03D4:  DATA 4C,64
03D6:  DATA 20,00
03D8:  DATA 42,32
03DA:  DATA 3A,25
03DC:  DATA 4C,64
03DE:  DATA 20,00
03E0:  DATA 53,45
03E2:  DATA 52,49
03E4:  DATA 41,4C
03E6:  DATA 54,45
03E8:  DATA 53,54
03EA:  DATA 0D,0A
03EC:  DATA 00,00
*
0904:  TBLRD*+
0906:  MOVFF  FF6,1CE
090A:  MOVFF  FF7,1CF
090E:  MOVFF  FF5,1D6
0912:  RCALL  08A4
0914:  MOVFF  1CE,FF6
0918:  MOVFF  1CF,FF7
091C:  MOVLB  1
091E:  DECFSZ xCD,F
0920:  BRA    0924
0922:  BRA    0928
0924:  MOVLB  0
0926:  BRA    0904
0928:  MOVLB  0
092A:  RETURN 0
092C:  MOVFF  FEA,1D5
0930:  MOVFF  FE9,1D4
0934:  MOVLB  1
0936:  BTFSS  xCE.7
0938:  BRA    094A
093A:  BSF    xD4.7
093C:  BTFSS  xD4.4
093E:  INCF   xD4,F
0940:  COMF   xCD,F
0942:  COMF   xCE,F
0944:  INCF   xCD,F
0946:  BTFSC  FD8.2
0948:  INCF   xCE,F
094A:  SWAPF  xCE,W
094C:  IORLW  F0
094E:  MOVWF  xD0
0950:  ADDWF  xD0,F
0952:  ADDLW  E2
0954:  MOVWF  xD1
0956:  ADDLW  32
0958:  MOVWF  xD3
095A:  MOVF   xCE,W
095C:  ANDLW  0F
095E:  ADDWF  xD1,F
0960:  ADDWF  xD1,F
0962:  ADDWF  xD3,F
0964:  ADDLW  E9
0966:  MOVWF  xD2
0968:  ADDWF  xD2,F
096A:  ADDWF  xD2,F
096C:  SWAPF  xCD,W
096E:  ANDLW  0F
0970:  ADDWF  xD2,F
0972:  ADDWF  xD3,F
0974:  RLCF   xD2,F
0976:  RLCF   xD3,F
0978:  COMF   xD3,F
097A:  RLCF   xD3,F
097C:  MOVF   xCD,W
097E:  ANDLW  0F
0980:  ADDWF  xD3,F
0982:  RLCF   xD0,F
0984:  MOVLW  07
0986:  MOVWF  xCF
0988:  MOVLW  0A
098A:  DECF   xD2,F
098C:  ADDWF  xD3,F
098E:  BNC   098A
0990:  DECF   xD1,F
0992:  ADDWF  xD2,F
0994:  BNC   0990
0996:  DECF   xD0,F
0998:  ADDWF  xD1,F
099A:  BNC   0996
099C:  DECF   xCF,F
099E:  ADDWF  xD0,F
09A0:  BNC   099C
09A2:  MOVLW  01
09A4:  MOVWF  FEA
09A6:  MOVLW  CF
09A8:  MOVWF  FE9
09AA:  MOVLW  07
09AC:  ANDWF  xD4,W
09AE:  BCF    xD4.6
09B0:  MOVF   FED,F
09B2:  ANDWF  xD4,W
09B4:  BNZ   09C4
09B6:  BTFSC  xD4.4
09B8:  MOVF   FEE,F
09BA:  BTFSC  xD4.4
09BC:  BRA    09C4
09BE:  MOVLW  20
09C0:  MOVWF  00
09C2:  BRA    0A04
09C4:  ADDWF  FE9,F
09C6:  MOVLW  00
09C8:  ADDWFC FEA,F
09CA:  MOVF   FE9,W
09CC:  SUBLW  D3
09CE:  BNZ   09D6
09D0:  DECFSZ FEA,W
09D2:  BRA    09D6
09D4:  BSF    xD4.6
09D6:  MOVF   FEF,W
09D8:  MOVWF  00
09DA:  BNZ   09EC
09DC:  BTFSC  xD4.6
09DE:  BRA    09EC
09E0:  BTFSC  xD4.4
09E2:  BRA    0A1E
09E4:  BTFSC  xD4.3
09E6:  BRA    09EC
09E8:  MOVLW  20
09EA:  BRA    0A02
09EC:  BTFSS  xD4.7
09EE:  BRA    09FC
09F0:  MOVLW  2D
09F2:  MOVWF  00
09F4:  MOVF   FED,W
09F6:  BCF    xD4.6
09F8:  BCF    xD4.7
09FA:  BRA    0A04
09FC:  BSF    xD4.3
09FE:  BCF    xD4.4
0A00:  MOVLW  30
0A02:  ADDWF  00,F
0A04:  MOVFF  FEA,1CE
0A08:  MOVFF  FE9,1CD
0A0C:  MOVFF  00,1D6
0A10:  MOVLB  0
0A12:  RCALL  08A4
0A14:  MOVFF  1CE,FEA
0A18:  MOVFF  1CD,FE9
0A1C:  MOVLB  1
0A1E:  MOVF   FEE,W
0A20:  BTFSS  xD4.6
0A22:  BRA    09CA
0A24:  MOVLB  0
0A26:  RETURN 0
0A28:  TBLRD*+
0A2A:  MOVF   FF5,F
0A2C:  BZ    0A46
0A2E:  MOVFF  FF6,1CC
0A32:  MOVFF  FF7,1CD
0A36:  MOVFF  FF5,1D6
0A3A:  RCALL  08A4
0A3C:  MOVFF  1CC,FF6
0A40:  MOVFF  1CD,FF7
0A44:  BRA    0A28
0A46:  RETURN 0
*
0E20:  TBLRD*+
0E22:  MOVF   FF5,F
0E24:  BZ    0E40
0E26:  MOVFF  FF6,1CE
0E2A:  MOVFF  FF7,1CF
0E2E:  MOVF   FF5,W
0E30:  BTFSS  F9E.4
0E32:  BRA    0E30
0E34:  MOVWF  FAD
0E36:  MOVFF  1CE,FF6
0E3A:  MOVFF  1CF,FF7
0E3E:  BRA    0E20
0E40:  RETURN 0
*
10A4:  MOVLB  1
10A6:  MOVF   xD3,W
10A8:  CLRF   01
10AA:  SUBWF  xD2,W
10AC:  BC    10B4
10AE:  MOVFF  1D2,00
10B2:  BRA    10CC
10B4:  CLRF   00
10B6:  MOVLW  08
10B8:  MOVWF  xD4
10BA:  RLCF   xD2,F
10BC:  RLCF   00,F
10BE:  MOVF   xD3,W
10C0:  SUBWF  00,W
10C2:  BTFSC  FD8.0
10C4:  MOVWF  00
10C6:  RLCF   01,F
10C8:  DECFSZ xD4,F
10CA:  BRA    10BA
10CC:  MOVLB  0
10CE:  RETURN 0
10D0:  MOVLW  20
10D2:  MOVLB  1
10D4:  BTFSS  xCD.4
10D6:  MOVLW  30
10D8:  MOVWF  xCE
10DA:  MOVFF  1CC,00
10DE:  BTFSS  xCC.7
10E0:  BRA    10F2
10E2:  COMF   00,F
10E4:  INCF   00,F
10E6:  MOVFF  00,1CC
10EA:  MOVLW  2D
10EC:  MOVWF  xCE
10EE:  BSF    xCD.7
10F0:  BSF    xCD.0
10F2:  MOVF   01,W
10F4:  MOVFF  1CC,1D2
10F8:  MOVLW  64
10FA:  MOVWF  xD3
10FC:  MOVLB  0
10FE:  RCALL  10A4
1100:  MOVFF  00,1CC
1104:  MOVLW  30
1106:  ADDWF  01,W
1108:  MOVLB  1
110A:  MOVWF  xCF
110C:  MOVFF  1CC,1D2
1110:  MOVLW  0A
1112:  MOVWF  xD3
1114:  MOVLB  0
1116:  RCALL  10A4
1118:  MOVLW  30
111A:  ADDWF  00,W
111C:  MOVLB  1
111E:  MOVWF  xD1
1120:  MOVLW  30
1122:  ADDWF  01,W
1124:  MOVWF  xD0
1126:  MOVFF  1CE,00
112A:  MOVLW  30
112C:  SUBWF  xCF,W
112E:  BZ    1138
1130:  BSF    xCD.1
1132:  BTFSC  xCD.7
1134:  BSF    xCD.2
1136:  BRA    115C
1138:  MOVFF  1CE,1CF
113C:  MOVLW  20
113E:  MOVWF  xCE
1140:  MOVLW  30
1142:  SUBWF  xD0,W
1144:  BZ    114E
1146:  BSF    xCD.0
1148:  BTFSC  xCD.7
114A:  BSF    xCD.1
114C:  BRA    115C
114E:  BTFSS  FD8.2
1150:  BSF    xCD.0
1152:  BNZ   115C
1154:  MOVFF  1CF,1D0
1158:  MOVLW  20
115A:  MOVWF  xCF
115C:  BTFSC  xCD.2
115E:  BRA    116A
1160:  BTFSC  xCD.1
1162:  BRA    1174
1164:  BTFSC  xCD.0
1166:  BRA    117E
1168:  BRA    1188
116A:  MOVFF  1CE,1D6
116E:  MOVLB  0
1170:  CALL   08A4
1174:  MOVFF  1CF,1D6
1178:  MOVLB  0
117A:  CALL   08A4
117E:  MOVFF  1D0,1D6
1182:  MOVLB  0
1184:  CALL   08A4
1188:  MOVFF  1D1,1D6
118C:  MOVLB  0
118E:  CALL   08A4
1192:  RETURN 0
*
11FA:  TBLRD*+
11FC:  MOVF   FF5,F
11FE:  BZ    1218
1200:  MOVFF  FF6,1CC
1204:  MOVFF  FF7,1CD
1208:  MOVFF  FF5,1D5
120C:  RCALL  11AC
120E:  MOVFF  1CC,FF6
1212:  MOVFF  1CD,FF7
1216:  BRA    11FA
1218:  GOTO   3350 (RETURN)
*
1272:  TSTFSZ 01
1274:  BRA    127C
1276:  TSTFSZ 02
1278:  BRA    127E
127A:  BRA    128A
127C:  INCF   02,F
127E:  MOVFF  00,FEE
1282:  DECFSZ 01,F
1284:  BRA    127E
1286:  DECFSZ 02,F
1288:  BRA    127E
128A:  RETURN 0
*
1910:  TBLRD*+
1912:  MOVFF  FF6,1CD
1916:  MOVFF  FF7,1CE
191A:  MOVFF  FF5,1D5
191E:  RCALL  11AC
1920:  MOVFF  1CD,FF6
1924:  MOVFF  1CE,FF7
1928:  MOVLB  1
192A:  DECFSZ xCC,F
192C:  BRA    1930
192E:  BRA    1934
1930:  MOVLB  0
1932:  BRA    1910
1934:  MOVLB  0
1936:  RETURN 0
1938:  MOVFF  FEA,1D4
193C:  MOVFF  FE9,1D3
1940:  MOVLB  1
1942:  SWAPF  xCD,W
1944:  IORLW  F0
1946:  MOVWF  xCF
1948:  ADDWF  xCF,F
194A:  ADDLW  E2
194C:  MOVWF  xD0
194E:  ADDLW  32
1950:  MOVWF  xD2
1952:  MOVF   xCD,W
1954:  ANDLW  0F
1956:  ADDWF  xD0,F
1958:  ADDWF  xD0,F
195A:  ADDWF  xD2,F
195C:  ADDLW  E9
195E:  MOVWF  xD1
1960:  ADDWF  xD1,F
1962:  ADDWF  xD1,F
1964:  SWAPF  xCC,W
1966:  ANDLW  0F
1968:  ADDWF  xD1,F
196A:  ADDWF  xD2,F
196C:  RLCF   xD1,F
196E:  RLCF   xD2,F
1970:  COMF   xD2,F
1972:  RLCF   xD2,F
1974:  MOVF   xCC,W
1976:  ANDLW  0F
1978:  ADDWF  xD2,F
197A:  RLCF   xCF,F
197C:  MOVLW  07
197E:  MOVWF  xCE
1980:  MOVLW  0A
1982:  DECF   xD1,F
1984:  ADDWF  xD2,F
1986:  BNC   1982
1988:  DECF   xD0,F
198A:  ADDWF  xD1,F
198C:  BNC   1988
198E:  DECF   xCF,F
1990:  ADDWF  xD0,F
1992:  BNC   198E
1994:  DECF   xCE,F
1996:  ADDWF  xCF,F
1998:  BNC   1994
199A:  MOVLW  01
199C:  MOVWF  FEA
199E:  MOVLW  CE
19A0:  MOVWF  FE9
19A2:  MOVLW  07
19A4:  ANDWF  xD3,W
19A6:  BCF    xD3.6
19A8:  ADDWF  FE9,F
19AA:  MOVLW  00
19AC:  ADDWFC FEA,F
19AE:  MOVF   FE9,W
19B0:  SUBLW  D2
19B2:  BNZ   19BA
19B4:  DECFSZ FEA,W
19B6:  BRA    19BA
19B8:  BSF    xD3.6
19BA:  MOVF   FEF,W
19BC:  MOVWF  00
19BE:  BNZ   19D0
19C0:  BTFSC  xD3.6
19C2:  BRA    19D0
19C4:  BTFSC  xD3.4
19C6:  BRA    19F4
19C8:  BTFSC  xD3.3
19CA:  BRA    19D0
19CC:  MOVLW  20
19CE:  BRA    19D6
19D0:  BSF    xD3.3
19D2:  BCF    xD3.4
19D4:  MOVLW  30
19D6:  ADDWF  00,F
19D8:  MOVFF  FEA,1CD
19DC:  MOVFF  FE9,1CC
19E0:  MOVFF  00,1D5
19E4:  MOVLB  0
19E6:  CALL   11AC
19EA:  MOVFF  1CD,FEA
19EE:  MOVFF  1CC,FE9
19F2:  MOVLB  1
19F4:  MOVF   FEE,W
19F6:  BTFSS  xD3.6
19F8:  BRA    19AE
19FA:  MOVLB  0
19FC:  RETURN 0
19FE:  MOVF   01,W
1A00:  MOVFF  1CC,1D2
1A04:  MOVLW  64
1A06:  MOVLB  1
1A08:  MOVWF  xD3
1A0A:  MOVLB  0
1A0C:  CALL   10A4
1A10:  MOVFF  00,1CC
1A14:  MOVF   01,W
1A16:  MOVLW  30
1A18:  BNZ   1A2A
1A1A:  MOVLB  1
1A1C:  BTFSS  xCD.1
1A1E:  BRA    1A40
1A20:  BTFSC  xCD.3
1A22:  BRA    1A40
1A24:  BTFSC  xCD.4
1A26:  MOVLW  20
1A28:  BRA    1A32
1A2A:  MOVLB  1
1A2C:  BCF    xCD.3
1A2E:  BCF    xCD.4
1A30:  BSF    xCD.0
1A32:  ADDWF  01,F
1A34:  MOVFF  01,1D5
1A38:  MOVLB  0
1A3A:  CALL   11AC
1A3E:  MOVLB  1
1A40:  MOVFF  1CC,1D2
1A44:  MOVLW  0A
1A46:  MOVWF  xD3
1A48:  MOVLB  0
1A4A:  CALL   10A4
1A4E:  MOVFF  00,1CC
1A52:  MOVF   01,W
1A54:  MOVLW  30
1A56:  BNZ   1A68
1A58:  MOVLB  1
1A5A:  BTFSC  xCD.3
1A5C:  BRA    1A74
1A5E:  BTFSS  xCD.0
1A60:  BRA    1A74
1A62:  BTFSC  xCD.4
1A64:  MOVLW  20
1A66:  MOVLB  0
1A68:  ADDWF  01,F
1A6A:  MOVFF  01,1D5
1A6E:  CALL   11AC
1A72:  MOVLB  1
1A74:  MOVLW  30
1A76:  ADDWF  xCC,F
1A78:  MOVFF  1CC,1D5
1A7C:  MOVLB  0
1A7E:  CALL   11AC
1A82:  RETURN 0
*
24A4:  ADDWF  FE8,W
24A6:  CLRF   FF7
24A8:  RLCF   FF7,F
24AA:  ADDLW  BF
24AC:  MOVWF  FF6
24AE:  MOVLW  24
24B0:  ADDWFC FF7,F
24B2:  TBLRD*-
24B4:  MOVF   FF5,W
24B6:  MOVWF  FFA
24B8:  TBLRD*
24BA:  MOVF   FF5,W
24BC:  MOVWF  FF9
24BE:  DATA 74,24
24C0:  DATA 9E,24
24C2:  DATA 9E,24
24C4:  DATA 9E,24
24C6:  DATA 76,24
24C8:  DATA 86,24
24CA:  DATA 8A,24
24CC:  DATA 9E,24
24CE:  DATA 9E,24
24D0:  DATA 9E,24
24D2:  DATA 8C,24
24D4:  DATA 9C,24
*
27AC:  ADDWF  FE8,W
27AE:  CLRF   FF7
27B0:  RLCF   FF7,F
27B2:  ADDLW  C7
27B4:  MOVWF  FF6
27B6:  MOVLW  27
27B8:  ADDWFC FF7,F
27BA:  TBLRD*-
27BC:  MOVF   FF5,W
27BE:  MOVWF  FFA
27C0:  TBLRD*
27C2:  MOVF   FF5,W
27C4:  MOVWF  FF9
27C6:  DATA 7C,27
27C8:  DATA A6,27
27CA:  DATA A6,27
27CC:  DATA A6,27
27CE:  DATA 7E,27
27D0:  DATA 8E,27
27D2:  DATA 92,27
27D4:  DATA A6,27
27D6:  DATA A6,27
27D8:  DATA A6,27
27DA:  DATA 94,27
27DC:  DATA A4,27
*
2AB6:  ADDWF  FE8,W
2AB8:  CLRF   FF7
2ABA:  RLCF   FF7,F
2ABC:  ADDLW  D1
2ABE:  MOVWF  FF6
2AC0:  MOVLW  2A
2AC2:  ADDWFC FF7,F
2AC4:  TBLRD*-
2AC6:  MOVF   FF5,W
2AC8:  MOVWF  FFA
2ACA:  TBLRD*
2ACC:  MOVF   FF5,W
2ACE:  MOVWF  FF9
2AD0:  DATA 86,2A
2AD2:  DATA B0,2A
2AD4:  DATA B0,2A
2AD6:  DATA B0,2A
2AD8:  DATA 88,2A
2ADA:  DATA 98,2A
2ADC:  DATA 9C,2A
2ADE:  DATA B0,2A
2AE0:  DATA B0,2A
2AE2:  DATA B0,2A
2AE4:  DATA 9E,2A
2AE6:  DATA AE,2A
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0F9C:  MOVLB  1
0F9E:  MOVFF  1D2,FE9
0FA2:  MOVFF  1D3,FEA
0FA6:  MOVFF  FEF,1D6
0FAA:  MOVFF  1D5,03
0FAE:  MOVFF  1D4,FE9
0FB2:  MOVFF  1D5,FEA
0FB6:  MOVF   FEF,W
0FB8:  SUBWF  xD6,W
0FBA:  BNZ   0FE6
....................       if (*s1 == '\0') 
0FBC:  MOVFF  1D3,03
0FC0:  MOVFF  1D2,FE9
0FC4:  MOVFF  03,FEA
0FC8:  MOVF   FEF,F
0FCA:  BNZ   0FD2
....................          return(0); 
0FCC:  MOVLW  00
0FCE:  MOVWF  01
0FD0:  BRA    1010
0FD2:  MOVFF  1D3,03
0FD6:  MOVF   xD2,W
0FD8:  INCF   xD2,F
0FDA:  BTFSC  FD8.2
0FDC:  INCF   xD3,F
0FDE:  INCF   xD4,F
0FE0:  BTFSC  FD8.2
0FE2:  INCF   xD5,F
0FE4:  BRA    0F9E
....................    return((*s1 < *s2) ? -1: 1); 
0FE6:  MOVFF  1D3,03
0FEA:  MOVFF  1D2,FE9
0FEE:  MOVFF  1D3,FEA
0FF2:  MOVFF  FEF,1D6
0FF6:  MOVFF  1D5,03
0FFA:  MOVFF  1D4,FE9
0FFE:  MOVFF  1D5,FEA
1002:  MOVF   FEF,W
1004:  SUBWF  xD6,W
1006:  BC    100C
1008:  MOVLW  FF
100A:  BRA    100E
100C:  MOVLW  01
100E:  MOVWF  01
1010:  MOVLB  0
1012:  GOTO   1056 (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
131C:  MOVFF  1D6,1DA
1320:  MOVFF  1D5,1D9
1324:  MOVFF  1DA,03
1328:  MOVLB  1
132A:  MOVFF  1D9,FE9
132E:  MOVFF  1DA,FEA
1332:  MOVF   FEF,F
1334:  BZ    138A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
1336:  MOVFF  1D8,1DC
133A:  MOVFF  1D7,1DB
133E:  MOVFF  1DC,03
1342:  MOVFF  1DB,FE9
1346:  MOVFF  1DC,FEA
134A:  MOVF   FEF,F
134C:  BZ    137E
....................          if (*sc1 == *sc2) 
134E:  MOVFF  1D9,FE9
1352:  MOVFF  1DA,FEA
1356:  MOVFF  FEF,1DD
135A:  MOVFF  1DC,03
135E:  MOVFF  1DB,FE9
1362:  MOVFF  1DC,FEA
1366:  MOVF   FEF,W
1368:  SUBWF  xDD,W
136A:  BNZ   1376
....................             return(sc1); 
136C:  MOVFF  1D9,01
1370:  MOVFF  1DA,02
1374:  BRA    1390
1376:  INCF   xDB,F
1378:  BTFSC  FD8.2
137A:  INCF   xDC,F
137C:  BRA    133E
137E:  INCF   xD9,F
1380:  BTFSC  FD8.2
1382:  INCF   xDA,F
1384:  MOVLB  0
1386:  BRA    1324
1388:  MOVLB  1
....................    return(0); 
138A:  MOVLW  00
138C:  MOVWF  01
138E:  MOVWF  02
1390:  MOVLB  0
1392:  GOTO   1408 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
128C:  MOVFF  1D6,1DA
1290:  MOVFF  1D5,1D9
1294:  MOVFF  1DA,03
1298:  MOVLB  1
129A:  MOVFF  1D9,FE9
129E:  MOVFF  1DA,FEA
12A2:  MOVF   FEF,F
12A4:  BZ    1306
....................       for (sc2 = s2; ; sc2++) 
12A6:  MOVFF  1D8,1DC
12AA:  MOVFF  1D7,1DB
....................     if (*sc2 == '\0') 
12AE:  MOVFF  1DC,03
12B2:  MOVFF  1DB,FE9
12B6:  MOVFF  1DC,FEA
12BA:  MOVF   FEF,F
12BC:  BNZ   12D2
....................        return(sc1 - s1); 
12BE:  MOVF   xD5,W
12C0:  SUBWF  xD9,W
12C2:  MOVWF  00
12C4:  MOVF   xD6,W
12C6:  SUBWFB xDA,W
12C8:  MOVWF  03
12CA:  MOVFF  00,01
12CE:  BRA    1316
12D0:  BRA    12F2
....................          else if (*sc1 == *sc2) 
12D2:  MOVFF  1D9,FE9
12D6:  MOVFF  1DA,FEA
12DA:  MOVFF  FEF,1DD
12DE:  MOVFF  1DC,03
12E2:  MOVFF  1DB,FE9
12E6:  MOVFF  1DC,FEA
12EA:  MOVF   FEF,W
12EC:  SUBWF  xDD,W
12EE:  BNZ   12F2
....................             break; 
12F0:  BRA    12FA
12F2:  INCF   xDB,F
12F4:  BTFSC  FD8.2
12F6:  INCF   xDC,F
12F8:  BRA    12AE
12FA:  INCF   xD9,F
12FC:  BTFSC  FD8.2
12FE:  INCF   xDA,F
1300:  MOVLB  0
1302:  BRA    1294
1304:  MOVLB  1
....................    return(sc1 - s1); 
1306:  MOVF   xD5,W
1308:  SUBWF  xD9,W
130A:  MOVWF  00
130C:  MOVF   xD6,W
130E:  SUBWFB xDA,W
1310:  MOVWF  03
1312:  MOVFF  00,01
1316:  MOVLB  0
1318:  GOTO   13C6 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
1396:  MOVLB  1
1398:  MOVF   xCD,W
139A:  IORWF  xCE,W
139C:  BZ    13A6
139E:  MOVFF  1CE,03
13A2:  MOVF   xCD,W
13A4:  BRA    13AC
13A6:  MOVFF  1A,03
13AA:  MOVF   19,W
13AC:  MOVWF  xD1
13AE:  MOVFF  03,1D2
....................    beg += strspn(beg, s2); 
13B2:  MOVFF  1D2,1D6
13B6:  MOVFF  1D1,1D5
13BA:  MOVFF  1D0,1D8
13BE:  MOVFF  1CF,1D7
13C2:  MOVLB  0
13C4:  BRA    128C
13C6:  MOVF   01,W
13C8:  MOVLB  1
13CA:  ADDWF  xD1,F
13CC:  MOVLW  00
13CE:  ADDWFC xD2,F
....................    if (*beg == '\0') 
13D0:  MOVFF  1D2,03
13D4:  MOVFF  1D1,FE9
13D8:  MOVFF  1D2,FEA
13DC:  MOVF   FEF,F
13DE:  BNZ   13F4
....................    { 
....................       *save = ' '; 
13E0:  MOVFF  19,FE9
13E4:  MOVFF  1A,FEA
13E8:  MOVLW  20
13EA:  MOVWF  FEF
....................       return(0); 
13EC:  MOVLW  00
13EE:  MOVWF  01
13F0:  MOVWF  02
13F2:  BRA    1442
....................    } 
....................    end = strpbrk(beg, s2); 
13F4:  MOVFF  1D2,1D6
13F8:  MOVFF  1D1,1D5
13FC:  MOVFF  1D0,1D8
1400:  MOVFF  1CF,1D7
1404:  MOVLB  0
1406:  BRA    131C
1408:  MOVFF  02,1D4
140C:  MOVFF  01,1D3
....................    if (*end != '\0') 
1410:  MOVFF  1D4,03
1414:  MOVLB  1
1416:  MOVFF  1D3,FE9
141A:  MOVFF  1D4,FEA
141E:  MOVF   FEF,F
1420:  BZ    1432
....................    { 
....................       *end = '\0'; 
1422:  MOVFF  1D3,FE9
1426:  MOVFF  1D4,FEA
142A:  CLRF   FEF
....................       end++; 
142C:  INCF   xD3,F
142E:  BTFSC  FD8.2
1430:  INCF   xD4,F
....................    } 
....................    save = end; 
1432:  MOVFF  1D4,1A
1436:  MOVFF  1D3,19
....................    return(beg); 
143A:  MOVFF  1D1,01
143E:  MOVFF  1D2,02
1442:  MOVLB  0
1444:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
1446:  MOVLB  1
1448:  CLRF   xD5
....................    sign = 0; 
144A:  CLRF   xD3
....................    base = 10; 
144C:  MOVLW  0A
144E:  MOVWF  xD4
....................    result = 0; 
1450:  CLRF   xD2
1452:  CLRF   xD1
1454:  CLRF   xD0
1456:  CLRF   xCF
....................  
....................    if (!s) 
1458:  MOVF   xCD,W
145A:  IORWF  xCE,W
145C:  BNZ   1468
....................       return 0; 
145E:  CLRF   00
1460:  CLRF   01
1462:  CLRF   02
1464:  CLRF   03
1466:  BRA    16D6
....................    c = s[index++]; 
1468:  MOVF   xD5,W
146A:  INCF   xD5,F
146C:  ADDWF  xCD,W
146E:  MOVWF  FE9
1470:  MOVLW  00
1472:  ADDWFC xCE,W
1474:  MOVWF  FEA
1476:  MOVFF  FEF,1D6
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
147A:  MOVF   xD6,W
147C:  SUBLW  2D
147E:  BNZ   1498
....................    { 
....................       sign = 1;         // Set the sign to negative 
1480:  MOVLW  01
1482:  MOVWF  xD3
....................       c = s[index++]; 
1484:  MOVF   xD5,W
1486:  INCF   xD5,F
1488:  ADDWF  xCD,W
148A:  MOVWF  FE9
148C:  MOVLW  00
148E:  ADDWFC xCE,W
1490:  MOVWF  FEA
1492:  MOVFF  FEF,1D6
....................    } 
1496:  BRA    14B0
....................    else if (c == '+') 
1498:  MOVF   xD6,W
149A:  SUBLW  2B
149C:  BNZ   14B0
....................    { 
....................       c = s[index++]; 
149E:  MOVF   xD5,W
14A0:  INCF   xD5,F
14A2:  ADDWF  xCD,W
14A4:  MOVWF  FE9
14A6:  MOVLW  00
14A8:  ADDWFC xCE,W
14AA:  MOVWF  FEA
14AC:  MOVFF  FEF,1D6
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
14B0:  MOVF   xD6,W
14B2:  SUBLW  2F
14B4:  BTFSC  FD8.0
14B6:  BRA    16A6
14B8:  MOVF   xD6,W
14BA:  SUBLW  39
14BC:  BTFSS  FD8.0
14BE:  BRA    16A6
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
14C0:  MOVF   xD6,W
14C2:  SUBLW  30
14C4:  BNZ   1502
14C6:  MOVF   xD5,W
14C8:  ADDWF  xCD,W
14CA:  MOVWF  FE9
14CC:  MOVLW  00
14CE:  ADDWFC xCE,W
14D0:  MOVWF  FEA
14D2:  MOVF   FEF,W
14D4:  SUBLW  78
14D6:  BZ    14EA
14D8:  MOVF   xD5,W
14DA:  ADDWF  xCD,W
14DC:  MOVWF  FE9
14DE:  MOVLW  00
14E0:  ADDWFC xCE,W
14E2:  MOVWF  FEA
14E4:  MOVF   FEF,W
14E6:  SUBLW  58
14E8:  BNZ   1502
....................       { 
....................          base = 16; 
14EA:  MOVLW  10
14EC:  MOVWF  xD4
....................          index++; 
14EE:  INCF   xD5,F
....................          c = s[index++]; 
14F0:  MOVF   xD5,W
14F2:  INCF   xD5,F
14F4:  ADDWF  xCD,W
14F6:  MOVWF  FE9
14F8:  MOVLW  00
14FA:  ADDWFC xCE,W
14FC:  MOVWF  FEA
14FE:  MOVFF  FEF,1D6
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1502:  MOVF   xD4,W
1504:  SUBLW  0A
1506:  BNZ   158E
....................       { 
....................          while (c >= '0' && c <= '9') { 
1508:  MOVF   xD6,W
150A:  SUBLW  2F
150C:  BC    158C
150E:  MOVF   xD6,W
1510:  SUBLW  39
1512:  BNC   158C
....................             result = (result << 1) + (result << 3);  // result *= 10; 
1514:  BCF    FD8.0
1516:  RLCF   xCF,W
1518:  MOVWF  xD8
151A:  RLCF   xD0,W
151C:  MOVWF  xD9
151E:  RLCF   xD1,W
1520:  MOVWF  xDA
1522:  RLCF   xD2,W
1524:  MOVWF  xDB
1526:  RLCF   xCF,W
1528:  MOVWF  00
152A:  RLCF   xD0,W
152C:  MOVWF  01
152E:  RLCF   xD1,W
1530:  MOVWF  02
1532:  RLCF   xD2,W
1534:  MOVWF  03
1536:  RLCF   00,F
1538:  RLCF   01,F
153A:  RLCF   02,F
153C:  RLCF   03,F
153E:  RLCF   00,F
1540:  RLCF   01,F
1542:  RLCF   02,F
1544:  RLCF   03,F
1546:  MOVLW  F8
1548:  ANDWF  00,F
154A:  MOVF   xD8,W
154C:  ADDWF  00,F
154E:  MOVF   xD9,W
1550:  ADDWFC 01,F
1552:  MOVF   xDA,W
1554:  ADDWFC 02,F
1556:  MOVF   xDB,W
1558:  ADDWFC 03,F
155A:  MOVFF  03,1D2
155E:  MOVFF  02,1D1
1562:  MOVFF  01,1D0
1566:  MOVFF  00,1CF
....................             result += (c - '0'); 
156A:  MOVLW  30
156C:  SUBWF  xD6,W
156E:  ADDWF  xCF,F
1570:  MOVLW  00
1572:  ADDWFC xD0,F
1574:  ADDWFC xD1,F
1576:  ADDWFC xD2,F
....................             c = s[index++]; 
1578:  MOVF   xD5,W
157A:  INCF   xD5,F
157C:  ADDWF  xCD,W
157E:  MOVWF  FE9
1580:  MOVLW  00
1582:  ADDWFC xCE,W
1584:  MOVWF  FEA
1586:  MOVFF  FEF,1D6
158A:  BRA    1508
....................          } 
....................       } 
158C:  BRA    16A6
....................       else if (base == 16)    // The number is a hexa number 
158E:  MOVF   xD4,W
1590:  SUBLW  10
1592:  BTFSS  FD8.2
1594:  BRA    16A6
....................       { 
....................          c = toupper(c); 
1596:  MOVF   xD6,W
1598:  SUBLW  60
159A:  BC    15A8
159C:  MOVF   xD6,W
159E:  SUBLW  7A
15A0:  BNC   15A8
15A2:  MOVF   xD6,W
15A4:  ANDLW  DF
15A6:  BRA    15AA
15A8:  MOVF   xD6,W
15AA:  MOVWF  xD6
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
15AC:  MOVF   xD6,W
15AE:  SUBLW  2F
15B0:  BC    15B8
15B2:  MOVF   xD6,W
15B4:  SUBLW  39
15B6:  BC    15C6
15B8:  MOVF   xD6,W
15BA:  SUBLW  40
15BC:  BTFSC  FD8.0
15BE:  BRA    16A6
15C0:  MOVF   xD6,W
15C2:  SUBLW  46
15C4:  BNC   16A6
....................          { 
....................             if (c >= '0' && c <= '9') 
15C6:  MOVF   xD6,W
15C8:  SUBLW  2F
15CA:  BC    1628
15CC:  MOVF   xD6,W
15CE:  SUBLW  39
15D0:  BNC   1628
....................                result = (result << 4) + (c - '0'); 
15D2:  RLCF   xCF,W
15D4:  MOVWF  xD8
15D6:  RLCF   xD0,W
15D8:  MOVWF  xD9
15DA:  RLCF   xD1,W
15DC:  MOVWF  xDA
15DE:  RLCF   xD2,W
15E0:  MOVWF  xDB
15E2:  RLCF   xD8,F
15E4:  RLCF   xD9,F
15E6:  RLCF   xDA,F
15E8:  RLCF   xDB,F
15EA:  RLCF   xD8,F
15EC:  RLCF   xD9,F
15EE:  RLCF   xDA,F
15F0:  RLCF   xDB,F
15F2:  RLCF   xD8,F
15F4:  RLCF   xD9,F
15F6:  RLCF   xDA,F
15F8:  RLCF   xDB,F
15FA:  MOVLW  F0
15FC:  ANDWF  xD8,F
15FE:  MOVLW  30
1600:  SUBWF  xD6,W
1602:  ADDWF  xD8,W
1604:  MOVWF  00
1606:  MOVLW  00
1608:  ADDWFC xD9,W
160A:  MOVWF  01
160C:  MOVLW  00
160E:  ADDWFC xDA,W
1610:  MOVWF  02
1612:  MOVLW  00
1614:  ADDWFC xDB,W
1616:  MOVWF  03
1618:  MOVWF  xD2
161A:  MOVFF  02,1D1
161E:  MOVFF  01,1D0
1622:  MOVFF  00,1CF
1626:  BRA    167C
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1628:  RLCF   xCF,W
162A:  MOVWF  xD8
162C:  RLCF   xD0,W
162E:  MOVWF  xD9
1630:  RLCF   xD1,W
1632:  MOVWF  xDA
1634:  RLCF   xD2,W
1636:  MOVWF  xDB
1638:  RLCF   xD8,F
163A:  RLCF   xD9,F
163C:  RLCF   xDA,F
163E:  RLCF   xDB,F
1640:  RLCF   xD8,F
1642:  RLCF   xD9,F
1644:  RLCF   xDA,F
1646:  RLCF   xDB,F
1648:  RLCF   xD8,F
164A:  RLCF   xD9,F
164C:  RLCF   xDA,F
164E:  RLCF   xDB,F
1650:  MOVLW  F0
1652:  ANDWF  xD8,F
1654:  MOVLW  41
1656:  SUBWF  xD6,W
1658:  ADDLW  0A
165A:  ADDWF  xD8,W
165C:  MOVWF  00
165E:  MOVLW  00
1660:  ADDWFC xD9,W
1662:  MOVWF  01
1664:  MOVLW  00
1666:  ADDWFC xDA,W
1668:  MOVWF  02
166A:  MOVLW  00
166C:  ADDWFC xDB,W
166E:  MOVWF  xD2
1670:  MOVFF  02,1D1
1674:  MOVFF  01,1D0
1678:  MOVFF  00,1CF
....................  
....................             c = s[index++];c = toupper(c); 
167C:  MOVF   xD5,W
167E:  INCF   xD5,F
1680:  ADDWF  xCD,W
1682:  MOVWF  FE9
1684:  MOVLW  00
1686:  ADDWFC xCE,W
1688:  MOVWF  FEA
168A:  MOVFF  FEF,1D6
168E:  MOVF   xD6,W
1690:  SUBLW  60
1692:  BC    16A0
1694:  MOVF   xD6,W
1696:  SUBLW  7A
1698:  BNC   16A0
169A:  MOVF   xD6,W
169C:  ANDLW  DF
169E:  BRA    16A2
16A0:  MOVF   xD6,W
16A2:  MOVWF  xD6
16A4:  BRA    15AC
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
16A6:  MOVF   xD4,W
16A8:  SUBLW  0A
16AA:  BNZ   16C6
16AC:  DECFSZ xD3,W
16AE:  BRA    16C6
....................       result = -result; 
16B0:  COMF   xCF,F
16B2:  COMF   xD0,F
16B4:  COMF   xD1,F
16B6:  COMF   xD2,F
16B8:  INCF   xCF,F
16BA:  BTFSC  FD8.2
16BC:  INCF   xD0,F
16BE:  BTFSC  FD8.2
16C0:  INCF   xD1,F
16C2:  BTFSC  FD8.2
16C4:  INCF   xD2,F
....................  
....................    return(result); 
16C6:  MOVFF  1CF,00
16CA:  MOVFF  1D0,01
16CE:  MOVFF  1D1,02
16D2:  MOVFF  1D2,03
16D6:  MOVLB  0
16D8:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=20000000) 
*
01B6:  MOVLW  03
01B8:  MOVLB  1
01BA:  SUBWF  xE5,F
01BC:  BNC   01D2
01BE:  MOVLW  01
01C0:  MOVWF  FEA
01C2:  MOVLW  E5
01C4:  MOVWF  FE9
01C6:  MOVF   FEF,W
01C8:  BZ    01D2
01CA:  BRA    01CE
01CC:  BRA    01CE
01CE:  DECFSZ FEF,F
01D0:  BRA    01CC
01D2:  MOVLB  0
01D4:  GOTO   01EA (RETURN)
*
03EE:  MOVLW  01
03F0:  MOVWF  FEA
03F2:  MOVLW  D7
03F4:  MOVWF  FE9
03F6:  MOVF   FEF,W
03F8:  BZ    0414
03FA:  MOVLW  06
03FC:  MOVWF  01
03FE:  CLRF   00
0400:  DECFSZ 00,F
0402:  BRA    0400
0404:  DECFSZ 01,F
0406:  BRA    03FE
0408:  MOVLW  7B
040A:  MOVWF  00
040C:  DECFSZ 00,F
040E:  BRA    040C
0410:  DECFSZ FEF,F
0412:  BRA    03FA
0414:  RETURN 0
.................... #use rs232(uart1, baud=9600,TIMEOUT=10,stream=monitor)//pic to pic 
*
01D8:  MOVLW  20
01DA:  MOVLB  1
01DC:  MOVWF  xE3
01DE:  MOVLW  02
01E0:  MOVWF  xE4
01E2:  MOVLW  9B
01E4:  MOVWF  xE5
01E6:  MOVLB  0
01E8:  BRA    01B6
01EA:  MOVLB  1
01EC:  DECFSZ xE4,F
01EE:  BRA    01E2
01F0:  DECFSZ xE3,F
01F2:  BRA    01FA
01F4:  CLRF   1F
01F6:  CLRF   01
01F8:  BRA    020E
01FA:  BTFSS  F9E.5
01FC:  BRA    01DE
01FE:  MOVF   FAB,W
0200:  MOVWF  1F
0202:  MOVF   FAE,W
0204:  MOVWF  01
0206:  BTFSS  1F.1
0208:  BRA    020E
020A:  BCF    FAB.4
020C:  BSF    FAB.4
020E:  MOVLB  0
0210:  GOTO   023C (RETURN)
.................... #use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
*
0E7A:  MOVLW  10
0E7C:  MOVLB  1
0E7E:  MOVWF  xCD
0E80:  MOVLW  01
0E82:  MOVWF  xCC
0E84:  BSF    20.6
0E86:  BSF    F94.1
0E88:  MOVLW  10
0E8A:  MOVWF  00
0E8C:  DECFSZ 00,F
0E8E:  BRA    0E8C
0E90:  NOP   
0E92:  DECFSZ xCC,F
0E94:  BRA    0EA0
0E96:  DECFSZ xCD,F
0E98:  BRA    0EA0
0E9A:  CLRF   20
0E9C:  CLRF   01
0E9E:  BRA    0EE8
0EA0:  BTFSC  F82.1
0EA2:  BRA    0E88
0EA4:  MOVLW  08
0EA6:  MOVWF  00
0EA8:  CLRF   xCE
0EAA:  MOVFF  FF2,1CF
0EAE:  BCF    FF2.7
0EB0:  BSF    00.7
0EB2:  BRA    0ED0
0EB4:  BCF    00.7
0EB6:  BRA    0ED0
0EB8:  BCF    FD8.0
0EBA:  BTFSC  F82.1
0EBC:  BSF    FD8.0
0EBE:  RRCF   xCE,F
0EC0:  BSF    00.6
0EC2:  BRA    0ED0
0EC4:  BCF    00.6
0EC6:  DECFSZ 00,F
0EC8:  BRA    0EB8
0ECA:  MOVF   xCE,W
0ECC:  MOVWF  01
0ECE:  BRA    0EE8
0ED0:  MOVLW  A7
0ED2:  BTFSC  00.7
0ED4:  MOVLW  2D
0ED6:  MOVWF  01
0ED8:  DECFSZ 01,F
0EDA:  BRA    0ED8
0EDC:  NOP   
0EDE:  BTFSC  00.7
0EE0:  BRA    0EB4
0EE2:  BTFSC  00.6
0EE4:  BRA    0EC4
0EE6:  BRA    0EB8
0EE8:  BTFSC  xCF.7
0EEA:  BSF    FF2.7
0EEC:  MOVLB  0
0EEE:  GOTO   323E (RETURN)
*
11AC:  MOVFF  FF2,03
11B0:  BCF    FF2.7
11B2:  BCF    F94.0
11B4:  BCF    F8B.0
11B6:  MOVLW  08
11B8:  MOVWF  01
11BA:  BRA    11BC
11BC:  NOP   
11BE:  BSF    01.7
11C0:  BRA    11E2
11C2:  BCF    01.7
11C4:  MOVLB  1
11C6:  RRCF   xD5,F
11C8:  MOVLB  0
11CA:  BTFSC  FD8.0
11CC:  BSF    F8B.0
11CE:  BTFSS  FD8.0
11D0:  BCF    F8B.0
11D2:  BSF    01.6
11D4:  BRA    11E2
11D6:  BCF    01.6
11D8:  DECFSZ 01,F
11DA:  BRA    11C4
11DC:  BRA    11DE
11DE:  NOP   
11E0:  BSF    F8B.0
11E2:  MOVLW  A7
11E4:  MOVWF  FE9
11E6:  DECFSZ FE9,F
11E8:  BRA    11E6
11EA:  BRA    11EC
11EC:  BTFSC  01.7
11EE:  BRA    11C2
11F0:  BTFSC  01.6
11F2:  BRA    11D6
11F4:  BTFSC  03.7
11F6:  BSF    FF2.7
11F8:  RETURN 0
.................... #fuses HS,NOLVP,PUT,PROTECT,NODEBUG,NOWDT,WDT4096//pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0416:  MOVLB  1
0418:  BTFSC  xDE.0
041A:  BRA    0420
041C:  BCF    F89.4
041E:  BRA    0422
0420:  BSF    F89.4
0422:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0424:  BTFSC  xDE.1
0426:  BRA    042C
0428:  BCF    F89.2
042A:  BRA    042E
042C:  BSF    F89.2
042E:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0430:  BTFSC  xDE.2
0432:  BRA    0438
0434:  BCF    F89.1
0436:  BRA    043A
0438:  BSF    F89.1
043A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
043C:  BTFSC  xDE.3
043E:  BRA    0444
0440:  BCF    F89.0
0442:  BRA    0446
0444:  BSF    F89.0
0446:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0448:  NOP   
....................  output_high(LCD_E);  
044A:  BCF    F92.3
044C:  BSF    F89.3
....................  delay_us(2);  
044E:  MOVLW  02
0450:  MOVWF  00
0452:  DECFSZ 00,F
0454:  BRA    0452
0456:  BRA    0458
0458:  NOP   
....................  output_low(LCD_E);  
045A:  BCF    F92.3
045C:  BCF    F89.3
045E:  MOVLB  0
0460:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0462:  BCF    F96.2
0464:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0466:  MOVLW  63
0468:  MOVWF  00
046A:  DECFSZ 00,F
046C:  BRA    046A
046E:  BRA    0470
.................... #endif  
....................  
.................... if(address)  
0470:  MOVLB  1
0472:  MOVF   xDB,F
0474:  BZ    047C
....................    output_high(LCD_RS);  
0476:  BCF    F96.2
0478:  BSF    F8D.2
047A:  BRA    0480
.................... else  
....................    output_low(LCD_RS);  
047C:  BCF    F96.2
047E:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0480:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0482:  BCF    F92.3
0484:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
0486:  SWAPF  xDC,W
0488:  MOVWF  xDD
048A:  MOVLW  0F
048C:  ANDWF  xDD,F
048E:  MOVFF  1DD,1DE
0492:  MOVLB  0
0494:  RCALL  0416
.................... lcd_send_nibble(n & 0xf);  
0496:  MOVLB  1
0498:  MOVF   xDC,W
049A:  ANDLW  0F
049C:  MOVWF  xDD
049E:  MOVWF  xDE
04A0:  MOVLB  0
04A2:  RCALL  0416
04A4:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
04A6:  MOVLW  01
04A8:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
04AA:  BCF    F96.2
04AC:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
04AE:  BCF    F92.3
04B0:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
04B2:  MOVLW  23
04B4:  MOVLB  1
04B6:  MOVWF  xD7
04B8:  MOVLB  0
04BA:  RCALL  03EE
....................  
....................    for(i=0 ;i < 3; i++)  
04BC:  MOVLB  1
04BE:  CLRF   xCC
04C0:  MOVF   xCC,W
04C2:  SUBLW  02
04C4:  BNC   04DE
....................    {  
....................       lcd_send_nibble(0x03);  
04C6:  MOVLW  03
04C8:  MOVWF  xDE
04CA:  MOVLB  0
04CC:  RCALL  0416
....................       delay_ms(5);  
04CE:  MOVLW  05
04D0:  MOVLB  1
04D2:  MOVWF  xD7
04D4:  MOVLB  0
04D6:  RCALL  03EE
04D8:  MOVLB  1
04DA:  INCF   xCC,F
04DC:  BRA    04C0
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04DE:  MOVLW  02
04E0:  MOVWF  xDE
04E2:  MOVLB  0
04E4:  RCALL  0416
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
04E6:  MOVLB  1
04E8:  CLRF   xCC
04EA:  MOVF   xCC,W
04EC:  SUBLW  03
04EE:  BNC   0514
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
04F0:  CLRF   03
04F2:  MOVF   xCC,W
04F4:  MOVLB  0
04F6:  RCALL  00C6
04F8:  MOVLB  1
04FA:  MOVWF  xCD
04FC:  CLRF   xDB
04FE:  MOVWF  xDC
0500:  MOVLB  0
0502:  RCALL  0462
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
0504:  MOVLW  05
0506:  MOVLB  1
0508:  MOVWF  xD7
050A:  MOVLB  0
050C:  RCALL  03EE
....................       #endif  
050E:  MOVLB  1
0510:  INCF   xCC,F
0512:  BRA    04EA
....................    }  
0514:  MOVLB  0
0516:  GOTO   300E (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
0852:  MOVLB  1
0854:  MOVF   xD8,W
0856:  XORLW  01
0858:  MOVLB  0
085A:  BZ    086A
085C:  XORLW  03
085E:  BZ    0870
0860:  XORLW  01
0862:  BZ    0878
0864:  XORLW  07
0866:  BZ    0880
0868:  BRA    088A
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
086A:  MOVLB  1
086C:  CLRF   xD9
....................      break;  
086E:  BRA    088E
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0870:  MOVLW  40
0872:  MOVLB  1
0874:  MOVWF  xD9
....................      break;  
0876:  BRA    088E
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0878:  MOVLW  14
087A:  MOVLB  1
087C:  MOVWF  xD9
....................      break;  
087E:  BRA    088E
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0880:  MOVLW  54
0882:  MOVLB  1
0884:  MOVWF  xD9
....................      break;  
0886:  BRA    088E
0888:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
088A:  MOVLB  1
088C:  CLRF   xD9
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
088E:  MOVLW  01
0890:  SUBWF  xD7,W
0892:  ADDWF  xD9,F
.................... lcd_send_byte(0, 0x80 | address);  
0894:  MOVF   xD9,W
0896:  IORLW  80
0898:  MOVWF  xDA
089A:  CLRF   xDB
089C:  MOVWF  xDC
089E:  MOVLB  0
08A0:  RCALL  0462
08A2:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
08A4:  MOVLB  1
08A6:  MOVF   xD6,W
08A8:  XORLW  0C
08AA:  MOVLB  0
08AC:  BZ    08B8
08AE:  XORLW  06
08B0:  BZ    08D4
08B2:  XORLW  02
08B4:  BZ    08E6
08B6:  BRA    08F4
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
08B8:  MOVLB  1
08BA:  CLRF   xDB
08BC:  MOVLW  01
08BE:  MOVWF  xDC
08C0:  MOVLB  0
08C2:  RCALL  0462
....................       lcd_line = 1;  
08C4:  MOVLW  01
08C6:  MOVWF  21
....................       delay_ms(2);  
08C8:  MOVLW  02
08CA:  MOVLB  1
08CC:  MOVWF  xD7
08CE:  MOVLB  0
08D0:  RCALL  03EE
....................       break;  
08D2:  BRA    0902
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08D4:  INCF   21,F
08D6:  MOVLW  01
08D8:  MOVLB  1
08DA:  MOVWF  xD7
08DC:  MOVFF  21,1D8
08E0:  MOVLB  0
08E2:  RCALL  0852
....................        break;  
08E4:  BRA    0902
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
08E6:  MOVLB  1
08E8:  CLRF   xDB
08EA:  MOVLW  10
08EC:  MOVWF  xDC
08EE:  MOVLB  0
08F0:  RCALL  0462
....................        break;  
08F2:  BRA    0902
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
08F4:  MOVLW  01
08F6:  MOVLB  1
08F8:  MOVWF  xDB
08FA:  MOVFF  1D6,1DC
08FE:  MOVLB  0
0900:  RCALL  0462
....................        break;  
....................    }  
0902:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0522:  MOVLW  08
0524:  MOVWF  01
0526:  MOVLW  05
0528:  MOVWF  00
052A:  DECFSZ 00,F
052C:  BRA    052A
052E:  BCF    F8C.7
0530:  BCF    F95.7
0532:  MOVLW  06
0534:  MOVWF  00
0536:  DECFSZ 00,F
0538:  BRA    0536
053A:  MOVLB  1
053C:  RLCF   xD6,F
053E:  BCF    F8C.6
0540:  BTFSC  FD8.0
0542:  BSF    F95.6
0544:  BTFSS  FD8.0
0546:  BCF    F95.6
0548:  BSF    F95.7
054A:  BTFSS  F83.7
054C:  BRA    054A
054E:  DECFSZ 01,F
0550:  BRA    0554
0552:  BRA    0558
0554:  MOVLB  0
0556:  BRA    0526
0558:  MOVLW  05
055A:  MOVWF  00
055C:  DECFSZ 00,F
055E:  BRA    055C
0560:  BCF    F8C.7
0562:  BCF    F95.7
0564:  NOP   
0566:  BSF    F95.6
0568:  MOVLW  06
056A:  MOVWF  00
056C:  DECFSZ 00,F
056E:  BRA    056C
0570:  MOVLW  06
0572:  MOVWF  00
0574:  DECFSZ 00,F
0576:  BRA    0574
0578:  BSF    F95.7
057A:  BTFSS  F83.7
057C:  BRA    057A
057E:  CLRF   01
0580:  MOVLW  06
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  BTFSC  F83.6
058A:  BSF    01.0
058C:  BCF    F8C.7
058E:  BCF    F95.7
0590:  BCF    F8C.6
0592:  BCF    F95.6
0594:  MOVLB  0
0596:  RETURN 0
*
06EC:  MOVLW  08
06EE:  MOVLB  1
06F0:  MOVWF  xD4
06F2:  MOVFF  00,1D5
06F6:  BSF    F95.6
06F8:  MOVLW  06
06FA:  MOVWF  00
06FC:  DECFSZ 00,F
06FE:  BRA    06FC
0700:  BSF    F95.7
0702:  BTFSS  F83.7
0704:  BRA    0702
0706:  BTFSC  F83.6
0708:  BSF    FD8.0
070A:  BTFSS  F83.6
070C:  BCF    FD8.0
070E:  RLCF   01,F
0710:  MOVLW  05
0712:  MOVWF  00
0714:  DECFSZ 00,F
0716:  BRA    0714
0718:  BCF    F95.7
071A:  BCF    F8C.7
071C:  DECFSZ xD4,F
071E:  BRA    06F6
0720:  BSF    F95.6
0722:  MOVLW  06
0724:  MOVWF  00
0726:  DECFSZ 00,F
0728:  BRA    0726
072A:  BCF    F8C.6
072C:  MOVF   xD5,W
072E:  BTFSS  FD8.2
0730:  BCF    F95.6
0732:  NOP   
0734:  BSF    F95.7
0736:  BTFSS  F83.7
0738:  BRA    0736
073A:  MOVLW  05
073C:  MOVWF  00
073E:  DECFSZ 00,F
0740:  BRA    073E
0742:  BCF    F8C.7
0744:  BCF    F95.7
0746:  MOVLW  06
0748:  MOVWF  00
074A:  DECFSZ 00,F
074C:  BRA    074A
074E:  BCF    F8C.6
0750:  BCF    F95.6
0752:  MOVLB  0
0754:  GOTO   07D2 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
051A:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
051C:  BSF    F95.6
051E:  GOTO   3012 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0598:  BSF    F95.6
059A:  MOVLW  05
059C:  MOVWF  00
059E:  DECFSZ 00,F
05A0:  BRA    059E
05A2:  BSF    F95.7
05A4:  MOVLW  06
05A6:  MOVWF  00
05A8:  DECFSZ 00,F
05AA:  BRA    05A8
05AC:  BCF    F8C.6
05AE:  BCF    F95.6
05B0:  MOVLW  05
05B2:  MOVWF  00
05B4:  DECFSZ 00,F
05B6:  BRA    05B4
05B8:  BCF    F8C.7
05BA:  BCF    F95.7
....................    i2c_write(0xa0); 
05BC:  MOVLW  A0
05BE:  MOVLB  1
05C0:  MOVWF  xD6
05C2:  MOVLB  0
05C4:  RCALL  0522
....................    i2c_write(address>>8); 
05C6:  MOVFF  1D1,1D4
05CA:  MOVLB  1
05CC:  CLRF   xD5
05CE:  MOVFF  1D1,1D6
05D2:  MOVLB  0
05D4:  RCALL  0522
....................    i2c_write(address); 
05D6:  MOVFF  1D0,1D6
05DA:  RCALL  0522
....................    i2c_write(data); 
05DC:  MOVFF  1D2,1D6
05E0:  RCALL  0522
....................    i2c_stop(); 
05E2:  BCF    F95.6
05E4:  NOP   
05E6:  BSF    F95.7
05E8:  BTFSS  F83.7
05EA:  BRA    05E8
05EC:  MOVLW  05
05EE:  MOVWF  00
05F0:  DECFSZ 00,F
05F2:  BRA    05F0
05F4:  BRA    05F6
05F6:  NOP   
05F8:  BSF    F95.6
05FA:  MOVLW  05
05FC:  MOVWF  00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
....................    i2c_start(); 
0602:  BSF    F95.6
0604:  MOVLW  05
0606:  MOVWF  00
0608:  DECFSZ 00,F
060A:  BRA    0608
060C:  BSF    F95.7
060E:  MOVLW  06
0610:  MOVWF  00
0612:  DECFSZ 00,F
0614:  BRA    0612
0616:  BCF    F8C.6
0618:  BCF    F95.6
061A:  MOVLW  05
061C:  MOVWF  00
061E:  DECFSZ 00,F
0620:  BRA    061E
0622:  BCF    F8C.7
0624:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0626:  MOVLW  A0
0628:  MOVLB  1
062A:  MOVWF  xD6
062C:  MOVLB  0
062E:  RCALL  0522
0630:  MOVF   01,W
0632:  MOVLB  1
0634:  BCF    xD3.0
0636:  BTFSC  01.0
0638:  BSF    xD3.0
....................    while(status==1) 
063A:  BTFSS  xD3.0
063C:  BRA    067A
....................    { 
....................    i2c_start(); 
063E:  BSF    F95.6
0640:  MOVLW  05
0642:  MOVWF  00
0644:  DECFSZ 00,F
0646:  BRA    0644
0648:  BSF    F95.7
064A:  MOVLW  06
064C:  MOVWF  00
064E:  DECFSZ 00,F
0650:  BRA    064E
0652:  BTFSS  F83.7
0654:  BRA    0652
0656:  BCF    F8C.6
0658:  BCF    F95.6
065A:  MOVLW  05
065C:  MOVWF  00
065E:  DECFSZ 00,F
0660:  BRA    065E
0662:  BCF    F8C.7
0664:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0666:  MOVLW  A0
0668:  MOVWF  xD6
066A:  MOVLB  0
066C:  RCALL  0522
066E:  MOVF   01,W
0670:  MOVLB  1
0672:  BCF    xD3.0
0674:  BTFSC  01.0
0676:  BSF    xD3.0
0678:  BRA    063A
....................    } 
....................    i2c_stop(); 
067A:  BCF    F95.6
067C:  NOP   
067E:  BSF    F95.7
0680:  BTFSS  F83.7
0682:  BRA    0680
0684:  MOVLW  05
0686:  MOVWF  00
0688:  DECFSZ 00,F
068A:  BRA    0688
068C:  BRA    068E
068E:  NOP   
0690:  BSF    F95.6
0692:  MOVLW  05
0694:  MOVWF  00
0696:  DECFSZ 00,F
0698:  BRA    0696
069A:  MOVLB  0
069C:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0758:  BSF    F95.6
075A:  MOVLW  05
075C:  MOVWF  00
075E:  DECFSZ 00,F
0760:  BRA    075E
0762:  BSF    F95.7
0764:  MOVLW  06
0766:  MOVWF  00
0768:  DECFSZ 00,F
076A:  BRA    0768
076C:  BCF    F8C.6
076E:  BCF    F95.6
0770:  MOVLW  05
0772:  MOVWF  00
0774:  DECFSZ 00,F
0776:  BRA    0774
0778:  BCF    F8C.7
077A:  BCF    F95.7
....................    i2c_write(0xa0); 
077C:  MOVLW  A0
077E:  MOVLB  1
0780:  MOVWF  xD6
0782:  MOVLB  0
0784:  RCALL  0522
....................    i2c_write(address>>8); 
0786:  MOVFF  1D1,1D3
078A:  MOVLB  1
078C:  CLRF   xD4
078E:  MOVFF  1D1,1D6
0792:  MOVLB  0
0794:  RCALL  0522
....................    i2c_write(address); 
0796:  MOVFF  1D0,1D6
079A:  RCALL  0522
....................    i2c_start(); 
079C:  BSF    F95.6
079E:  MOVLW  05
07A0:  MOVWF  00
07A2:  DECFSZ 00,F
07A4:  BRA    07A2
07A6:  BSF    F95.7
07A8:  MOVLW  06
07AA:  MOVWF  00
07AC:  DECFSZ 00,F
07AE:  BRA    07AC
07B0:  BTFSS  F83.7
07B2:  BRA    07B0
07B4:  BCF    F8C.6
07B6:  BCF    F95.6
07B8:  MOVLW  05
07BA:  MOVWF  00
07BC:  DECFSZ 00,F
07BE:  BRA    07BC
07C0:  BCF    F8C.7
07C2:  BCF    F95.7
....................    i2c_write(0xa1); 
07C4:  MOVLW  A1
07C6:  MOVLB  1
07C8:  MOVWF  xD6
07CA:  MOVLB  0
07CC:  RCALL  0522
....................    data=i2c_read(0); 
07CE:  CLRF   00
07D0:  BRA    06EC
07D2:  MOVFF  01,1D2
....................    i2c_stop(); 
07D6:  BCF    F95.6
07D8:  NOP   
07DA:  BSF    F95.7
07DC:  BTFSS  F83.7
07DE:  BRA    07DC
07E0:  MOVLW  05
07E2:  MOVWF  00
07E4:  DECFSZ 00,F
07E6:  BRA    07E4
07E8:  BRA    07EA
07EA:  NOP   
07EC:  BSF    F95.6
07EE:  MOVLW  05
07F0:  MOVWF  00
07F2:  DECFSZ 00,F
07F4:  BRA    07F2
....................    return(data); 
07F6:  MOVLB  1
07F8:  MOVFF  1D2,01
07FC:  MOVLB  0
07FE:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... //entradas 
.................... #define entrada01  PIN_B4////SENSOR 1              2  1 
.................... #define entrada02  PIN_D4////SENSOR 2              4  3 
.................... #define entrada03  PIN_B2////SENSOR 3              6  5 
.................... #define entrada04  PIN_B3////SENSOR 4 
.................... #define entrada05  PIN_B0////SENSOR 5 
.................... #define entrada06  PIN_B1////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3////REINICIAR CONTADOR 
.................... #define frente  PIN_D2///INDICADOR DE MAESTRO 
.................... #define B_silencio  PIN_D1///BOTON PARA SILENCIAR (eliminado) 
.................... //salidas 
.................... #define salida01  PIN_C3//Buzzer 
.................... #define salida02  PIN_C4//Indicador de Sensado 
.................... #define salida03  PIN_C5//Relay 
....................  
.................... #define HB PIN_E0 
.................... #define EN PIN_E1 
....................  
....................  
.................... const int s_cta=5;//numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;//Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error,transmitir;//variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1,sumas1;//Variables temporales de suma de entradas y salidas 
.................... int lim_b;//cuenta de sensores bloqueados 
.................... int fse1,fse2,fse3,fss1,fss2,fss3;//banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1,temporal2,tempo_tn,sub_atras,baj_atras;//variables temporales para hacer calculos. 
.................... int16 entran1,salen1;//variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian,time_clr;//variable temporal para guardar salidas 
.................... int ini,i,ii,j=0,a,master=0,flag_enviar,f_clr; 
.................... int16 b,n,cta_bloqueo,cta_enviar,total2_t;//,envia_ent,envia_sal; 
.................... int cta_bloq1=0,cta_bloq2=0,cta_bloq3=0;//variables para contar bloqueos por pares 
.................... int ent1=0,ent2=0,ent3=0,ent4=0,ent5=0,ent6=0;//variables de estado de sensores 
.................... int sen_ent=0,sen_sal=0;//variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1=0,sub_cta2=0,sub_cta3=0,sub_cta4=0,sub_cta5=0,sub_cta6=0;//variables para calculos de cuentas 
.................... int detec1,detec2,detec3,detec4,detec5,detec6;//variables para determinar el cambio de estado de los sensores 
.................... int sub_d1,sub_d2,sub_d3,sub_d4,sub_d5,sub_d6;//variables para determinar el cambio de estado de los sensores 
.................... int entra_act1=0,edo1=0,entra1=0,sale1=0,edoa1=0,enable1=0,entra_temp1=0;//variables para la maquina de estados de sensores par1 
.................... int entra_act2=0,edo2=0,entra2=0,sale2=0,edoa2=0,enable2=0,entra_temp2=0;//variables para la maquina de estados de sensores par2 
.................... int entra_act3=0,edo3=0,entra3=0,sale3=0,edoa3=0,enable3=0,entra_temp3=0;//variables para la maquina de estados de sensores par3 
.................... int16 entraront=0,salieront=0,pasaje=0,pasajet=0;//cuenta total de entradas y salidas 
.................... int16 tem_entraront=0,tem_salieront=0,temporal3;//cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1=0,des2=0,des3=0; 
.................... int bloq_p1,bloq_p2,bloq_p3,en_b1,en_b2,en_b3; 
.................... int16 tim_p1,tim_p2,tim_p3,segundoen,time_envio; 
.................... const int32 set_timer=59286;//10ms 
.................... const int16 time_bloqueo=500;//5seg. 100=1seg. 
.................... int clear_lcd1,time_lcd1; 
.................... int y=0; 
.................... int bandera_revision=0; 
.................... int16 cntbnd=0; 
....................    char term[3], *ptr; 
....................    char data1[14]; 
....................    char data2[10]; 
....................    char data3[10]; 
....................    char data4[10]; 
....................    char data5[10]; 
....................    int caso_valor=0; 
....................  
.................... /* 
.................... char texto1[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char texto2[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char texto3[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char texto4[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char texto5[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char texto6[]= "SERIALTEST"; // 
.................... char texto7[]= "SERIAL_TOK"; // 
.................... char texto8[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char texto9[]= "SINFUNCION"; // 
.................... char texto []= "          "; 
.................... char version[]="V5.01";//<---Version de codigo de contador 
....................  
....................  
.................... char grabar_historial_pic[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char leer_historial_pic[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char borrar_todo[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char solicitar[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char conteo_poste_trasero[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char prueba_serial[]= "SERIALTEST"; // 
.................... char serial_ok[]= "SERIAL_TOK"; // 
.................... char suben_poste_trasero[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char sin_funcion[]= "SINFUNCION"; // 
.................... char espacios []= "          "; 
.................... char version_firmware[]="V5.01";//<---Version de codigo de contador 
.................... */ 
.................... //char textosearch[] = {"GRABAR_DAT","LEERCUENTA","BORRAR_ALL","SOLICITADO","PASAJEROS:","SERIALTEST","SERIAL_TOK","SUBIENDOC2","SINFUNCION","          ","V5.01"}; 
.................... /* 
.................... char *textosearch[11] =    { "GRABAR_DAT\r", 
....................                              "LEERCUENTA\r", 
....................                              "BORRAR_ALL\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r", 
....................                              "V5.01     \r" 
....................                            }; 
.................... */ 
....................  
.................... char *textosearch[11] =    { "V5.01     \r", 
....................                              "BORRAR_ALL\r", 
....................                              "GRABAR_DAT\r",//GRABAR_DAT 
....................                              "LEERCUENTA\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r" 
....................                              
....................                            }; 
....................  
....................  
....................  
.................... char version[]="V5.02";//<---Version de codigo de contador 
....................  
....................  
.................... /////EEPROM/////////// 
.................... const int word_size =10;//TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set=9; 
.................... //char XX[word_size+19];// ARREGLO SERIAL 
.................... char XX[word_size+22];// ARREGLO SERIAL 
.................... char entran[5]; 
.................... char salen[5]; 
.................... char bloqueado[5]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[5]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... //void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
....................    time_clr++; 
*
00EE:  INCF   3E,F
00F0:  BTFSC  FD8.2
00F2:  INCF   3F,F
....................    segundoen++; 
00F4:  INCF   xA7,F
00F6:  BTFSC  FD8.2
00F8:  INCF   xA8,F
....................    if(segundoen>=100) { 
00FA:  MOVF   xA8,F
00FC:  BNZ   0104
00FE:  MOVF   xA7,W
0100:  SUBLW  63
0102:  BC    0110
....................       segundoen=0; 
0104:  CLRF   xA8
0106:  CLRF   xA7
....................       time_envio++; 
0108:  INCF   xA9,F
010A:  BTFSC  FD8.2
010C:  INCF   xAA,F
....................       time_lcd1++; 
010E:  INCF   xAC,F
....................    } 
.................... //****Se definen los estados de los sensores (deteccion)***// 
....................    //sensor1 
....................    ent1=input(entrada01); 
0110:  BSF    F93.4
0112:  CLRF   55
0114:  BTFSC  F81.4
0116:  INCF   55,F
....................    if(ent1==0) sub_cta1++;//ent1 =0 (no pulso) 
0118:  MOVF   55,F
011A:  BNZ   0122
011C:  INCF   5D,F
011E:  BTFSC  FD8.2
0120:  INCF   5E,F
....................    //sensor2 
....................    ent2=input(entrada02); 
0122:  BSF    F95.4
0124:  CLRF   56
0126:  BTFSC  F83.4
0128:  INCF   56,F
....................    if(ent2==0) sub_cta2++; 
012A:  MOVF   56,F
012C:  BNZ   0134
012E:  INCF   5F,F
0130:  BTFSC  FD8.2
0132:  INCF   x60,F
....................    //sensor3 
....................    ent3=input(entrada03); 
0134:  BSF    F93.2
0136:  CLRF   57
0138:  BTFSC  F81.2
013A:  INCF   57,F
....................    if(ent3==0) sub_cta3++; 
013C:  MOVF   57,F
013E:  BNZ   0146
0140:  INCF   x61,F
0142:  BTFSC  FD8.2
0144:  INCF   x62,F
....................    //sensor4 
....................    ent4=input(entrada04); 
0146:  BSF    F93.3
0148:  CLRF   58
014A:  BTFSC  F81.3
014C:  INCF   58,F
....................    if(ent4==0) sub_cta4++; 
014E:  MOVF   58,F
0150:  BNZ   0158
0152:  INCF   x63,F
0154:  BTFSC  FD8.2
0156:  INCF   x64,F
....................    //sensor5 
....................    ent5=input(entrada05); 
0158:  BSF    F93.0
015A:  CLRF   59
015C:  BTFSC  F81.0
015E:  INCF   59,F
....................    if(ent5==0) sub_cta5++; 
0160:  MOVF   59,F
0162:  BNZ   016A
0164:  INCF   x65,F
0166:  BTFSC  FD8.2
0168:  INCF   x66,F
....................    //sensor6 
....................    ent6=input(entrada06); 
016A:  BSF    F93.1
016C:  CLRF   5A
016E:  BTFSC  F81.1
0170:  INCF   5A,F
....................    if(ent6==0) sub_cta6++; 
0172:  MOVF   5A,F
0174:  BNZ   017C
0176:  INCF   x67,F
0178:  BTFSC  FD8.2
017A:  INCF   x68,F
.................... //****************************************// 
....................    tim_p1++; 
017C:  INCF   xA1,F
017E:  BTFSC  FD8.2
0180:  INCF   xA2,F
....................    tim_p2++; 
0182:  INCF   xA3,F
0184:  BTFSC  FD8.2
0186:  INCF   xA4,F
....................    tim_p3++; 
0188:  INCF   xA5,F
018A:  BTFSC  FD8.2
018C:  INCF   xA6,F
....................    cta_enviar++; 
018E:  INCF   4E,F
0190:  BTFSC  FD8.2
0192:  INCF   4F,F
.................... set_timer1(set_timer);// 10ms 
0194:  MOVLW  E7
0196:  MOVWF  FCF
0198:  MOVLW  96
019A:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
.................... /* 
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................    while (i <= size_s){ 
....................          XX[i] = fgetc(monitor);//se captura el dato del serial monitor(comunicacion entre pics) 
....................         i++; 
....................    } 
.................... j=1; 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
.................... */ 
....................  
.................... //----------------------------------------------------------------------------- 
....................  
019C:  BCF    F9E.0
019E:  GOTO   0078
.................... #int_TIMER3 
.................... void  TIMER3_isr(void)  
.................... { 
....................   // output_toggle(salida01);  
....................    cntbnd++; 
01A2:  INCF   xAF,F
01A4:  BTFSC  FD8.2
01A6:  INCF   xB0,F
....................     
....................   // if(cntbnd>=5000){ ///3  ORIGINAL 13889 
....................   // lcd_gotoxy(12,2); 
....................    //printf(lcd_putc,"%Ld",cntbnd); 
....................    //output_toggle(salida03); 
....................     
....................   // cntbnd=0; 
....................   // } 
....................    
....................    set_timer3(65036);  
01A8:  MOVLW  FE
01AA:  MOVWF  FB3
01AC:  MOVLW  0C
01AE:  MOVWF  FB2
....................     
.................... } 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
01B0:  BCF    FA1.1
01B2:  GOTO   0078
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... disable_interrupts(GLOBAL);//deshabilita interrupciones globales 
*
0214:  BCF    FF2.6
0216:  BCF    FF2.7
0218:  BTFSC  FF2.7
021A:  BRA    0216
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
021C:  CLRF   41
....................  
....................    while(i<=30){ 
021E:  MOVF   41,W
0220:  SUBLW  1E
0222:  BNC   0262
....................    XX[i] = fgetc(monitor); 
0224:  CLRF   03
0226:  MOVF   41,W
0228:  ADDLW  8D
022A:  MOVWF  FE9
022C:  MOVLW  01
022E:  ADDWFC 03,W
0230:  MOVWF  FEA
0232:  MOVFF  FEA,1E2
0236:  MOVFF  FE9,1E1
023A:  BRA    01D8
023C:  MOVFF  1E2,FEA
0240:  MOVFF  1E1,FE9
0244:  MOVFF  01,FEF
....................    i++; 
0248:  INCF   41,F
....................    if(XX[i]==13)break; 
024A:  CLRF   03
024C:  MOVF   41,W
024E:  ADDLW  8D
0250:  MOVWF  FE9
0252:  MOVLW  01
0254:  ADDWFC 03,W
0256:  MOVWF  FEA
0258:  MOVF   FEF,W
025A:  SUBLW  0D
025C:  BTFSC  FD8.2
025E:  BRA    0262
0260:  BRA    021E
....................    };//se captura el dato del serial monitor(comunicacion entre pics) 
....................     
....................     
....................   // XX[i]=fgetc(monitor); 
.................... j=1; 
0262:  MOVLW  01
0264:  MOVWF  43
.................... y=1; 
0266:  MOVWF  xAD
.................... //fprintf(monitor,"XX:%s",XX); 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
0268:  BCF    F9E.5
026A:  GOTO   0078
.................... #ZERO_RAM 
.................... void main(){ 
*
2E4C:  CLRF   FF8
2E4E:  BCF    FD0.7
2E50:  BSF    07.7
2E52:  MOVLW  FE
2E54:  MOVWF  00
2E56:  MOVLW  06
2E58:  MOVWF  01
2E5A:  MOVLW  02
2E5C:  MOVWF  FE9
2E5E:  MOVLW  00
2E60:  MOVWF  FEA
2E62:  CLRF   FEE
2E64:  DECFSZ 00,F
2E66:  BRA    2E62
2E68:  DECFSZ 01,F
2E6A:  BRA    2E62
2E6C:  CLRF   1F
2E6E:  BSF    FB8.3
2E70:  MOVLW  08
2E72:  MOVWF  FAF
2E74:  MOVLW  02
2E76:  MOVWF  FB0
2E78:  MOVLW  A6
2E7A:  MOVWF  FAC
2E7C:  MOVLW  90
2E7E:  MOVWF  FAB
2E80:  CLRF   20
2E82:  BCF    F94.0
2E84:  BSF    F8B.0
2E86:  CLRF   43
2E88:  CLRF   45
2E8A:  CLRF   52
2E8C:  CLRF   53
2E8E:  CLRF   54
2E90:  CLRF   55
2E92:  CLRF   56
2E94:  CLRF   57
2E96:  CLRF   58
2E98:  CLRF   59
2E9A:  CLRF   5A
2E9C:  CLRF   5B
2E9E:  CLRF   5C
2EA0:  CLRF   5E
2EA2:  CLRF   5D
2EA4:  CLRF   x60
2EA6:  CLRF   5F
2EA8:  CLRF   x62
2EAA:  CLRF   x61
2EAC:  CLRF   x64
2EAE:  CLRF   x63
2EB0:  CLRF   x66
2EB2:  CLRF   x65
2EB4:  CLRF   x68
2EB6:  CLRF   x67
2EB8:  CLRF   x75
2EBA:  CLRF   x76
2EBC:  CLRF   x77
2EBE:  CLRF   x78
2EC0:  CLRF   x79
2EC2:  CLRF   x7A
2EC4:  CLRF   x7B
2EC6:  CLRF   x7C
2EC8:  CLRF   x7D
2ECA:  CLRF   x7E
2ECC:  CLRF   x7F
2ECE:  CLRF   x80
2ED0:  CLRF   x81
2ED2:  CLRF   x82
2ED4:  CLRF   x83
2ED6:  CLRF   x84
2ED8:  CLRF   x85
2EDA:  CLRF   x86
2EDC:  CLRF   x87
2EDE:  CLRF   x88
2EE0:  CLRF   x89
2EE2:  CLRF   x8B
2EE4:  CLRF   x8A
2EE6:  CLRF   x8D
2EE8:  CLRF   x8C
2EEA:  CLRF   x8F
2EEC:  CLRF   x8E
2EEE:  CLRF   x91
2EF0:  CLRF   x90
2EF2:  CLRF   x93
2EF4:  CLRF   x92
2EF6:  CLRF   x95
2EF8:  CLRF   x94
2EFA:  CLRF   x98
2EFC:  CLRF   x99
2EFE:  CLRF   x9A
2F00:  CLRF   xAD
2F02:  CLRF   xAE
2F04:  CLRF   xB0
2F06:  CLRF   xAF
2F08:  CLRF   xEC
2F0A:  MOVF   FC1,W
2F0C:  ANDLW  C0
2F0E:  IORLW  0F
2F10:  MOVWF  FC1
2F12:  MOVLW  07
2F14:  MOVWF  FB4
2F16:  BRA    2FC2
2F18:  DATA 02,00
2F1A:  DATA 19,00
2F1C:  DATA 00,05
2F1E:  DATA 01,03
2F20:  DATA 56,35
2F22:  DATA 2E,30
2F24:  DATA 31,05
2F26:  DATA C0,20
2F28:  DATA 6E,80
2F2A:  DATA 0D,00
2F2C:  DATA 42,4F
2F2E:  DATA 52,52
2F30:  DATA 41,52
2F32:  DATA 5F,41
2F34:  DATA 4C,4C
2F36:  DATA 0D,00
2F38:  DATA 47,52
2F3A:  DATA 41,42
2F3C:  DATA 41,52
2F3E:  DATA 5F,44
2F40:  DATA 41,54
2F42:  DATA 0D,00
2F44:  DATA 4C,45
2F46:  DATA 45,52
2F48:  DATA 43,55
2F4A:  DATA 45,4E
2F4C:  DATA 54,41
2F4E:  DATA 0D,00
2F50:  DATA 53,4F
2F52:  DATA 4C,49
2F54:  DATA 43,49
2F56:  DATA 54,41
2F58:  DATA 44,4F
2F5A:  DATA 0D,00
2F5C:  DATA 50,41
2F5E:  DATA 53,41
2F60:  DATA 4A,45
2F62:  DATA 52,4F
2F64:  DATA 53,3A
2F66:  DATA 0D,00
2F68:  DATA 53,45
2F6A:  DATA 52,49
2F6C:  DATA 41,4C
2F6E:  DATA 54,45
2F70:  DATA 53,54
2F72:  DATA 0D,00
2F74:  DATA 53,45
2F76:  DATA 52,49
2F78:  DATA 41,4C
2F7A:  DATA 5F,54
2F7C:  DATA 4F,4B
2F7E:  DATA 0D,00
2F80:  DATA 53,55
2F82:  DATA 42,49
2F84:  DATA 45,4E
2F86:  DATA 44,4F
2F88:  DATA 43,32
2F8A:  DATA 0D,00
2F8C:  DATA 53,49
2F8E:  DATA 4E,46
2F90:  DATA 55,4E
2F92:  DATA 43,49
2F94:  DATA 4F,4E
2F96:  DATA 0D,00
2F98:  DATA 0A,C0
2F9A:  DATA 20,02
2F9C:  DATA 80,0D
2F9E:  DATA 00,16
2FA0:  DATA 00,ED
2FA2:  DATA 03,01
2FA4:  DATA 0F,01
2FA6:  DATA 1B,01
2FA8:  DATA 27,01
2FAA:  DATA 33,01
2FAC:  DATA 3F,01
2FAE:  DATA 4B,01
2FB0:  DATA 57,01
2FB2:  DATA 63,01
2FB4:  DATA 6F,01
2FB6:  DATA 7B,01
2FB8:  DATA 06,01
2FBA:  DATA 87,56
2FBC:  DATA 35,2E
2FBE:  DATA 30,32
2FC0:  DATA 00,00
2FC2:  MOVLW  00
2FC4:  MOVWF  FF8
2FC6:  MOVLW  2F
2FC8:  MOVWF  FF7
2FCA:  MOVLW  18
2FCC:  MOVWF  FF6
2FCE:  TBLRD*+
2FD0:  MOVF   FF5,W
2FD2:  MOVWF  00
2FD4:  XORLW  00
2FD6:  BZ    2FFE
2FD8:  TBLRD*+
2FDA:  MOVF   FF5,W
2FDC:  MOVWF  01
2FDE:  BTFSC  FE8.7
2FE0:  BRA    2FEC
2FE2:  ANDLW  0F
2FE4:  MOVWF  FEA
2FE6:  TBLRD*+
2FE8:  MOVFF  FF5,FE9
2FEC:  BTFSC  01.6
2FEE:  TBLRD*+
2FF0:  BTFSS  01.6
2FF2:  TBLRD*+
2FF4:  MOVFF  FF5,FEE
2FF8:  DCFSNZ 00,F
2FFA:  BRA    2FCE
2FFC:  BRA    2FF0
2FFE:  CLRF   FF8
.................... //Apaga entradas analogicas 
.................... setup_adc_ports(NO_ANALOGS); 
3000:  MOVF   FC1,W
3002:  ANDLW  C0
3004:  IORLW  0F
3006:  MOVWF  FC1
.................... setup_adc(ADC_OFF); 
3008:  BCF    FC2.0
.................... lcd_init();//inicia LCD 
300A:  GOTO   04A6
.................... init_ext_eeprom();//Inicia EEPROM 
300E:  GOTO   051A
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Configura timer1:Reloj interno, preescaler=8 
3012:  MOVLW  B5
3014:  MOVWF  FCD
.................... enable_interrupts(INT_TIMER1);//Habilito interrupcin particular del TIMER1 
3016:  BSF    F9D.0
.................... set_timer1(set_timer);//Setea cuenta para la interrupcion. 
3018:  MOVLW  E7
301A:  MOVWF  FCF
301C:  MOVLW  96
301E:  MOVWF  FCE
.................... disable_interrupts(INT_EXT);//desabilita interrupciones externas 
3020:  BCF    FF2.4
.................... enable_interrupts(GLOBAL);//habilita interrupciones globales 
3022:  MOVLW  C0
3024:  IORWF  FF2,F
.................... ///**************************************************************************/// 
.................... ////////Confuguracion de PWM//////// 
.................... output_low(PIN_C2);//CCP1 
3026:  BCF    F94.2
3028:  BCF    F8B.2
.................... setup_ccp1(CCP_PWM); 
302A:  BCF    F94.2
302C:  BCF    F8B.2
302E:  MOVLW  0C
3030:  MOVWF  FBD
.................... setup_timer_2(t2_div_By_1,131,1);//frecuencia 38khz 
3032:  MOVLW  00
3034:  IORLW  04
3036:  MOVWF  FCA
3038:  MOVLW  83
303A:  MOVWF  FCB
.................... //set_pwm1_duty(26);//(5%) alto 
.................... set_pwm1_duty(279);//(10%) Parte alta del ciclo  
303C:  MOVLW  45
303E:  MOVWF  FBE
3040:  MOVF   FBD,W
3042:  ANDLW  CF
3044:  IORLW  30
3046:  MOVWF  FBD
.................... //////////////////////////////////// 
.................... ini=read_eeprom(100);//Carga estado de inicio 
3048:  MOVFF  FF2,1CC
304C:  BCF    FF2.7
304E:  MOVLW  64
3050:  MOVWF  FA9
3052:  BCF    FA6.6
3054:  BCF    FA6.7
3056:  BSF    FA6.0
3058:  MOVF   FA8,W
305A:  MOVLB  1
305C:  BTFSC  xCC.7
305E:  BSF    FF2.7
3060:  MOVWF  40
.................... if(ini!=1){//Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
3062:  DECFSZ 40,W
3064:  BRA    3068
3066:  BRA    309A
....................    write_eeprom(100,1);//Graba inicio 
3068:  MOVF   FF2,W
306A:  MOVWF  00
306C:  BCF    FF2.7
306E:  MOVLW  64
3070:  MOVWF  FA9
3072:  MOVLW  01
3074:  MOVWF  FA8
3076:  BCF    FA6.6
3078:  BCF    FA6.7
307A:  BSF    FA6.2
307C:  MOVLB  F
307E:  MOVLW  55
3080:  MOVWF  FA7
3082:  MOVLW  AA
3084:  MOVWF  FA7
3086:  BSF    FA6.1
3088:  BTFSC  FA6.1
308A:  BRA    3088
308C:  BCF    FA6.2
308E:  MOVF   00,W
3090:  IORWF  FF2,F
....................    limpiar();//pone en 0 el registro de cuentas almacenadas. 
3092:  MOVLB  0
3094:  CALL   0D00
3098:  MOVLB  1
.................... } 
....................  
.................... //llaves();//Graba instrucciones de control en eeprom 
.................... ///////////////////////////////lee que tienen la memoria eeprom////////////////////////////////// 
.................... //rd_eeprom_inicio(); 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... entraron_total();//carga el total de entradas registradas 
309A:  MOVLB  0
309C:  GOTO   0D6C
.................... salieron_total();//carga el total de salidas registradas 
30A0:  GOTO   0DC6
.................... ent1=ent2=ent3=ent4=ent5=ent6=0;//inicia en 0 variables de estado de sensores 
30A4:  CLRF   5A
30A6:  MOVFF  5A,59
30AA:  MOVFF  59,58
30AE:  MOVFF  58,57
30B2:  MOVFF  57,56
30B6:  MOVFF  56,55
.................... tim_p1=tim_p2=tim_p3=0;//inicia en 0 las cuentas para detectar sensores bloqueados 
30BA:  CLRF   xA6
30BC:  CLRF   xA5
30BE:  MOVFF  A6,A4
30C2:  MOVFF  A5,A3
30C6:  MOVFF  A4,A2
30CA:  MOVFF  A3,A1
.................... en_b1=en_b2=en_b3=0;//bandera de pares bloqueados 
30CE:  CLRF   xA0
30D0:  MOVFF  A0,9F
30D4:  MOVFF  9F,9E
.................... time_envio=0;//inicia en 0 cuenta para transmitir datos 
30D8:  CLRF   xAA
30DA:  CLRF   xA9
.................... if(input(frente) ) {//revisa si es maestro (1) o escalvo (2) 
30DC:  BSF    F95.2
30DE:  BTFSS  F83.2
30E0:  BRA    30EC
....................    master=1; 
30E2:  MOVLW  01
30E4:  MOVWF  45
....................    size_s=29; 
30E6:  MOVLW  1D
30E8:  MOVWF  22
.................... } 
30EA:  BRA    30F2
.................... else { 
....................    master=0; 
30EC:  CLRF   45
....................    size_s=15; 
30EE:  MOVLW  0F
30F0:  MOVWF  22
.................... } 
.................... lcd_cuentas();//Escribe texto base en LCD 
30F2:  CALL   0A48
.................... cta_bloq1=read_ext_eeprom(9);//carga bloqueos acumulados en par1 
30F6:  MOVLB  1
30F8:  CLRF   xD1
30FA:  MOVLW  09
30FC:  MOVWF  xD0
30FE:  MOVLB  0
3100:  CALL   0758
3104:  MOVFF  01,52
.................... cta_bloq2=read_ext_eeprom(10);//carga bloqueos acumulados en par2 
3108:  MOVLB  1
310A:  CLRF   xD1
310C:  MOVLW  0A
310E:  MOVWF  xD0
3110:  MOVLB  0
3112:  CALL   0758
3116:  MOVFF  01,53
.................... cta_bloq3=read_ext_eeprom(11);//carga bloqueos acumulados en par3 
311A:  MOVLB  1
311C:  CLRF   xD1
311E:  MOVLW  0B
3120:  MOVWF  xD0
3122:  MOVLB  0
3124:  CALL   0758
3128:  MOVFF  01,54
.................... int tem_res; 
.................... tem_res=input(rst_cta);//inicializa variable de reset de cuenta fisico 
312C:  BSF    F95.3
312E:  MOVLB  1
3130:  CLRF   xCB
3132:  BTFSC  F83.3
3134:  INCF   xCB,F
.................... j=0; 
3136:  CLRF   43
.................... flag_enviar=0; 
3138:  CLRF   46
.................... salian=0; 
313A:  CLRF   3D
313C:  CLRF   3C
.................... enable_interrupts(INT_RDA);//habilita interrupcion serial 
313E:  BSF    F9D.5
.................... setup_wdt(WDT_ON);//habilita watch dog 
3140:  BSF    FD1.0
.................... sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
3142:  MOVLB  0
3144:  CLRF   x68
3146:  CLRF   x67
3148:  MOVFF  68,66
314C:  MOVFF  67,65
3150:  MOVFF  66,64
3154:  MOVFF  65,63
3158:  MOVFF  64,62
315C:  MOVFF  63,61
3160:  MOVFF  62,60
3164:  MOVFF  61,5F
3168:  MOVFF  60,5E
316C:  MOVFF  5F,5D
.................... tem_entraront=tem_salieront=0; 
3170:  CLRF   x95
3172:  CLRF   x94
3174:  MOVFF  95,93
3178:  MOVFF  94,92
.................... error=0; 
317C:  CLRF   23
.................... reset();//Revisa causa de inicio del pic 
317E:  GOTO   0E42
.................... transmitir=0; 
3182:  CLRF   24
.................... output_low(salida02); 
3184:  BCF    F94.4
3186:  BCF    F8B.4
.................... sub_atras=baj_atras=0; 
3188:  CLRF   37
318A:  CLRF   36
318C:  MOVFF  37,35
3190:  MOVFF  36,34
.................... clear_lcd1=0; 
3194:  CLRF   xAB
....................  
.................... output_low(HB); 
3196:  BCF    F96.0
3198:  BCF    F8D.0
.................... bandera_revision=1; 
319A:  MOVLW  01
319C:  MOVWF  xAE
.................... caso_valor=0; 
319E:  CLRF   xEC
....................  
.................... while(TRUE){ 
.................... ///////////////////////preuba comunicacion serial con poste trasero/////////////// 
....................  //fprintf(monitor,"SOLICITADO");//4 
....................  //delay_ms(100); 
....................  if(y==1){ 
31A0:  DECFSZ xAD,W
31A2:  BRA    31AA
....................   //fprintf(monitor,"XX=%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6]); 
....................   //fprintf(monitor,"XX=%s",XX); 
....................   enable_interrupts(GLOBAL);//habilita interrupciones globales 
31A4:  MOVLW  C0
31A6:  IORWF  FF2,F
....................   y=0; 
31A8:  CLRF   xAD
....................  } 
....................   
.................... ////////////////////////////////////////////////////////////////////////////////// 
....................    if(tem_res!=input(rst_cta) ){//BOTON DE RESET DE CUENTA 
31AA:  BSF    F95.3
31AC:  MOVLW  00
31AE:  BTFSC  F83.3
31B0:  MOVLW  01
31B2:  MOVLB  1
31B4:  SUBWF  xCB,W
31B6:  BZ    3200
....................       delay_ms(50); 
31B8:  MOVLW  32
31BA:  MOVWF  xD7
31BC:  MOVLB  0
31BE:  CALL   03EE
....................       if(tem_res!=input(rst_cta) ){ 
31C2:  BSF    F95.3
31C4:  MOVLW  00
31C6:  BTFSC  F83.3
31C8:  MOVLW  01
31CA:  MOVLB  1
31CC:  SUBWF  xCB,W
31CE:  BZ    3200
....................          tem_res=input(rst_cta); 
31D0:  BSF    F95.3
31D2:  CLRF   xCB
31D4:  BTFSC  F83.3
31D6:  INCF   xCB,F
....................          if( (master==1)&&(tem_res==0) ) { 
31D8:  DECFSZ 45,W
31DA:  BRA    3200
31DC:  MOVF   xCB,F
31DE:  BNZ   3200
....................             fprintf(monitor,"BORRAR_ALL\r"); 
31E0:  MOVLW  6E
31E2:  MOVWF  FF6
31E4:  MOVLW  02
31E6:  MOVWF  FF7
31E8:  MOVLB  0
31EA:  CALL   0E20
....................             printf(lcd_putc,"\fBORRAR_ALL"); 
31EE:  MOVLW  7A
31F0:  MOVWF  FF6
31F2:  MOVLW  02
31F4:  MOVWF  FF7
31F6:  CALL   0A28
....................             limpiar(); 
31FA:  CALL   0D00
31FE:  MOVLB  1
....................          } 
....................       } 
....................    } 
.................... //!    
.................... /* 
....................    if( kbhit(GPS) && master ){//escucha gsm 
....................        i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................        XX[i] = fgetc(GPS); 
....................        i++; 
....................        if( (XX[0]>=65)&&(XX[0]<=90) ){//validar no sea ruido 
....................           while (i <= word_size){ 
....................                 XX[i] = fgetc(GPS); 
....................                 i++; 
....................           } 
....................           if(XX[1]=='R') XX[0]='G'; 
....................           j=1; 
....................        }/// 
....................       // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................    }//end gps 
.................... //! 
.................... */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... if(input(EN) == 1  && bandera_revision == 1){ 
3200:  BSF    F96.1
3202:  BTFSS  F84.1
3204:  BRA    32B6
3206:  MOVLB  0
3208:  DECFSZ xAE,W
320A:  BRA    320E
320C:  BRA    3212
320E:  MOVLB  1
3210:  BRA    32B6
....................   output_high(HB); 
3212:  BCF    F96.0
3214:  BSF    F8D.0
....................   cntbnd=0;  
3216:  CLRF   xB0
3218:  CLRF   xAF
....................   bandera_revision=0; 
321A:  CLRF   xAE
....................   output_high(salida03); 
321C:  BCF    F94.5
321E:  BSF    F8B.5
....................   //lcd_gotoxy(12,1); 
....................    //printf(lcd_putc,"Recibi bandera"); 
....................   //while(kbhit(GPS) != 1); 
.................... // delay_ms(200); 
.................... while (kbhit(GPS)!=1 || cntbnd >= 200) 
3220:  MOVLW  00
3222:  BTFSS  F82.1
3224:  MOVLW  01
3226:  SUBLW  01
3228:  BNZ   3234
322A:  MOVF   xB0,F
322C:  BNZ   3234
322E:  MOVF   xAF,W
3230:  SUBLW  C7
3232:  BC    323A
.................... { 
....................   // lcd_gotoxy(12,2); 
....................   // printf(lcd_putc,"WT"); 
....................   bandera_revision=1; 
3234:  MOVLW  01
3236:  MOVWF  xAE
3238:  BRA    3220
.................... } 
....................   // lcd_gotoxy(12,3); 
....................   // printf(lcd_putc,"%x",fgetc(GPS)); 
....................   XX[0] = fgetc(GPS); 
323A:  GOTO   0E7A
323E:  MOVFF  01,18D
....................  // lcd_gotoxy(12,3); 
....................   //printf(lcd_putc,"%c",XX[0]); 
....................   if(XX[0]==63) 
3242:  MOVLB  1
3244:  MOVF   x8D,W
3246:  SUBLW  3F
3248:  BNZ   32B6
....................   { 
....................   output_low(salida03); 
324A:  BCF    F94.5
324C:  BCF    F8B.5
....................       j=1; 
324E:  MOVLW  01
3250:  MOVWF  43
....................       sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
3252:  MOVLB  0
3254:  CLRF   x68
3256:  CLRF   x67
3258:  MOVFF  68,66
325C:  MOVFF  67,65
3260:  MOVFF  66,64
3264:  MOVFF  65,63
3268:  MOVFF  64,62
326C:  MOVFF  63,61
3270:  MOVFF  62,60
3274:  MOVFF  61,5F
3278:  MOVFF  60,5E
327C:  MOVFF  5F,5D
....................       XX[0] = 'B'; 
3280:  MOVLW  42
3282:  MOVLB  1
3284:  MOVWF  x8D
....................       XX[1] = 'O'; 
3286:  MOVLW  4F
3288:  MOVWF  x8E
....................       XX[2] = 'R'; 
328A:  MOVLW  52
328C:  MOVWF  x8F
....................       XX[3] = 'R'; 
328E:  MOVWF  x90
....................       XX[4] = 'A'; 
3290:  MOVLW  41
3292:  MOVWF  x91
....................       XX[5] = 'R'; 
3294:  MOVLW  52
3296:  MOVWF  x92
....................       XX[6] = '_'; 
3298:  MOVLW  5F
329A:  MOVWF  x93
....................       XX[7] = 'A'; 
329C:  MOVLW  41
329E:  MOVWF  x94
....................       XX[8] = 'L'; 
32A0:  MOVLW  4C
32A2:  MOVWF  x95
....................       XX[9] = 'L'; 
32A4:  MOVWF  x96
....................       XX[10] = '\n'; 
32A6:  MOVLW  0A
32A8:  MOVWF  x97
....................       output_low(HB); 
32AA:  BCF    F96.0
32AC:  BCF    F8D.0
....................       bandera_revision=1; 
32AE:  MOVLW  01
32B0:  MOVLB  0
32B2:  MOVWF  xAE
32B4:  MOVLB  1
....................   } 
....................   
....................  /* 
....................    if( kbhit(GPS) && master ){//escucha gsm 
....................        //for (i=0;i<=10;++i){ 
....................       // lcd_gotoxy(12,3); 
....................        //printf(lcd_putc,"%c",fgetc(GPS)); 
....................         i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................         XX[i] = fgetc(GPS); 
....................          
....................        //i++; 
....................       // } 
....................        lcd_gotoxy(1,4); 
....................        printf(lcd_putc,"%c%c%c%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6],XX[7],XX[8],XX[9]); 
....................        if( (XX[0]>=65)&&(XX[0]<=90) ){//validar no sea ruido 
....................           while (i <= word_size){ 
....................                 XX[i] = fgetc(GPS); 
....................                 i++; 
....................           } 
....................           if(XX[1]=='R') XX[0]='G'; 
....................           j=1; 
....................        }/// 
....................        sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................    }//end gps 
....................    */ 
....................     
.................... } 
....................  //------------------------------------------------------------------------------  
....................  
....................    if(j==1){//Revisa si hubo datos por cualquiera de los 2 puertos seriales 
32B6:  DECFSZ 43,W
32B8:  BRA    3462
....................        
....................       // fprintf(monitor,"%s",XX);//4 
....................        
....................       rd_eeprom();//valida dato recibido para ver si es una palabra de control 
32BA:  MOVLB  0
32BC:  GOTO   0EF2
....................       //int caso_valor = evaluar_string("BORRAR_ALL\r"); 
....................       //fprintf(monitor,"XX:%s",XX); 
....................       caso_valor = evaluar_string(XX); 
32C0:  MOVLW  01
32C2:  MOVLB  1
32C4:  MOVWF  xCD
32C6:  MOVLW  8D
32C8:  MOVWF  xCC
32CA:  MOVLB  0
32CC:  GOTO   1016
32D0:  MOVFF  01,EC
....................       //int caso_valor; 
....................       //evaluar_string('B'); 
....................       //char textosearch[]= "PASAJEROS:"; 
....................      // fprintf(monitor,"compare = %s", strstr(XX,textosearch)); 
....................       //if((strstr(XX,textosearch))==0)b=5; 
....................       lcd_gotoxy(9,1); 
32D4:  MOVLW  09
32D6:  MOVLB  1
32D8:  MOVWF  xD7
32DA:  MOVLW  01
32DC:  MOVWF  xD8
32DE:  MOVLB  0
32E0:  CALL   0852
....................       //printf(lcd_putc,"%Ld ",b);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................       printf(lcd_putc,"%d ",caso_valor);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
32E4:  MOVFF  EC,1CC
32E8:  MOVLW  18
32EA:  MOVLB  1
32EC:  MOVWF  xCD
32EE:  MOVLB  0
32F0:  CALL   10D0
32F4:  MOVLW  20
32F6:  MOVLB  1
32F8:  MOVWF  xD6
32FA:  MOVLB  0
32FC:  CALL   08A4
....................  
....................        
....................       //switch (b) { 
....................       switch (caso_valor) { 
3300:  MOVF   xEC,W
3302:  XORLW  01
3304:  BZ    3324
3306:  XORLW  03
3308:  BZ    333A
330A:  XORLW  01
330C:  BZ    3340
330E:  XORLW  07
3310:  BZ    337E
3312:  XORLW  01
3314:  BZ    3384
3316:  XORLW  03
3318:  BZ    33AC
331A:  XORLW  01
331C:  BZ    33DC
331E:  XORLW  0F
3320:  BZ    3400
3322:  BRA    3424
....................           case 1: {//Se pone en 0 la cuenta 
....................                   limpiar(); 
3324:  CALL   0D00
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
3328:  DECFSZ 45,W
332A:  BRA    3338
332C:  MOVLW  86
332E:  MOVWF  FF6
3330:  MOVLW  02
3332:  MOVWF  FF7
3334:  CALL   0E20
....................                   break;} 
3338:  BRA    3440
....................           case 2: {//Se hace solicitud de cuenta del poste trasero 
....................                   solicitar(); 
333A:  CALL   1194
....................                   break;} 
333E:  BRA    3440
....................           case 3: {//Se pone en 0 la cuenta por peticion del GPRS 
....................                   if(master==1) fprintf(GPS,"RESET_OK\r\n");//confirma a gsm  
3340:  DECFSZ 45,W
3342:  BRA    3350
3344:  MOVLW  92
3346:  MOVWF  FF6
3348:  MOVLW  02
334A:  MOVWF  FF7
334C:  GOTO   11FA
....................                   delay_ms(1000); 
3350:  MOVLW  04
3352:  MOVLB  1
3354:  MOVWF  xCC
3356:  MOVLW  FA
3358:  MOVWF  xD7
335A:  MOVLB  0
335C:  CALL   03EE
3360:  MOVLB  1
3362:  DECFSZ xCC,F
3364:  BRA    3356
....................                   limpiar(); 
3366:  MOVLB  0
3368:  CALL   0D00
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
336C:  DECFSZ 45,W
336E:  BRA    337C
3370:  MOVLW  9E
3372:  MOVWF  FF6
3374:  MOVLW  02
3376:  MOVWF  FF7
3378:  CALL   0E20
....................                   break;} 
337C:  BRA    3440
....................           case 4: {//ver pasaje total de este acceso (contador atras) 
....................                   envio_master(); 
337E:  CALL   121C
....................                   break;} 
3382:  BRA    3440
....................           case 5: {//envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................                   flag_enviar=0; 
3384:  CLRF   46
....................                   enviop1(); 
3386:  GOTO   16DA
....................                   transmitir=1; 
338A:  MOVLW  01
338C:  MOVWF  24
....................                   lcd_gotoxy(9,4); 
338E:  MOVLW  09
3390:  MOVLB  1
3392:  MOVWF  xD7
3394:  MOVLW  04
3396:  MOVWF  xD8
3398:  MOVLB  0
339A:  CALL   0852
....................                   lcd_putc("C2OK"); 
339E:  MOVLW  AA
33A0:  MOVWF  FF6
33A2:  MOVLW  02
33A4:  MOVWF  FF7
33A6:  CALL   0A28
....................                    
....................                   break;} 
33AA:  BRA    3440
....................           case 6: {//TEST DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
33AC:  MOVLW  01
33AE:  MOVWF  xAB
....................                   time_lcd1=0; 
33B0:  CLRF   xAC
....................                   lcd_gotoxy(9,3); 
33B2:  MOVLW  09
33B4:  MOVLB  1
33B6:  MOVWF  xD7
33B8:  MOVLW  03
33BA:  MOVWF  xD8
33BC:  MOVLB  0
33BE:  CALL   0852
....................                   lcd_putc("C1OK"); 
33C2:  MOVLW  B0
33C4:  MOVWF  FF6
33C6:  MOVLW  02
33C8:  MOVWF  FF7
33CA:  CALL   0A28
....................                   fprintf(monitor,"SERIAL_TOK\r");// 
33CE:  MOVLW  B6
33D0:  MOVWF  FF6
33D2:  MOVLW  02
33D4:  MOVWF  FF7
33D6:  CALL   0E20
....................                   break;} 
33DA:  BRA    3440
....................           case 7: {//CONFIRMACION DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
33DC:  MOVLW  01
33DE:  MOVWF  xAB
....................                   time_lcd1=0; 
33E0:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
33E2:  MOVLW  09
33E4:  MOVLB  1
33E6:  MOVWF  xD7
33E8:  MOVLW  04
33EA:  MOVWF  xD8
33EC:  MOVLB  0
33EE:  CALL   0852
....................                   lcd_putc("C2OK"); 
33F2:  MOVLW  C2
33F4:  MOVWF  FF6
33F6:  MOVLW  02
33F8:  MOVWF  FF7
33FA:  CALL   0A28
....................                   break;} 
33FE:  BRA    3440
....................           case 8: {//Suben por atras 
....................                   clear_lcd1=1; 
3400:  MOVLW  01
3402:  MOVWF  xAB
....................                   time_lcd1=0; 
3404:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
3406:  MOVLW  09
3408:  MOVLB  1
340A:  MOVWF  xD7
340C:  MOVLW  04
340E:  MOVWF  xD8
3410:  MOVLB  0
3412:  CALL   0852
....................                   lcd_putc("Sub2"); 
3416:  MOVLW  C8
3418:  MOVWF  FF6
341A:  MOVLW  02
341C:  MOVWF  FF7
341E:  CALL   0A28
....................                   break;} 
3422:  BRA    3440
....................           default:{ 
....................                   lcd_gotoxy(9,2); 
3424:  MOVLW  09
3426:  MOVLB  1
3428:  MOVWF  xD7
342A:  MOVLW  02
342C:  MOVWF  xD8
342E:  MOVLB  0
3430:  CALL   0852
....................                   printf(lcd_putc,"c=0"); 
3434:  MOVLW  CE
3436:  MOVWF  FF6
3438:  MOVLW  02
343A:  MOVWF  FF7
343C:  CALL   0A28
....................                   } 
....................       }//end switch 
....................       caso_valor=0; 
3440:  CLRF   xEC
....................       //lcd_gotoxy(9,1); 
....................       //printf(lcd_putc,"%Ld ",b);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................       //printf(lcd_putc,"%d ",caso_valor);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................       //delay_ms(3000); 
....................       memset(XX, 0, sizeof(XX) ); 
3442:  MOVLW  01
3444:  MOVWF  FEA
3446:  MOVLW  8D
3448:  MOVWF  FE9
344A:  CLRF   00
344C:  CLRF   02
344E:  MOVLW  20
3450:  MOVWF  01
3452:  CALL   1272
....................       time_clr=0; 
3456:  CLRF   3F
3458:  CLRF   3E
....................       f_clr=1; 
345A:  MOVLW  01
345C:  MOVWF  47
....................       j=0; 
345E:  CLRF   43
3460:  MOVLB  1
....................    } 
....................    //if( (time_envio>=180)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................     if( (time_envio>=10)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
3462:  MOVLB  0
3464:  MOVF   xAA,F
3466:  BNZ   346E
3468:  MOVF   xA9,W
346A:  SUBLW  09
346C:  BC    3476
346E:  MOVF   45,F
3470:  BZ    3476
....................          solicitar(); 
3472:  CALL   1194
....................          
....................    } 
....................    if( (clear_lcd1)&&(time_lcd1>=10) ){//cronometro para limpiar notificaciones LCD 
3476:  MOVF   xAB,F
3478:  BZ    34D6
347A:  MOVF   xAC,W
347C:  SUBLW  09
347E:  BC    34D6
....................       clear_lcd1=0; 
3480:  CLRF   xAB
....................       lcd_gotoxy(9,1); 
3482:  MOVLW  09
3484:  MOVLB  1
3486:  MOVWF  xD7
3488:  MOVLW  01
348A:  MOVWF  xD8
348C:  MOVLB  0
348E:  CALL   0852
....................       lcd_putc("    "); 
3492:  MOVLW  D2
3494:  MOVWF  FF6
3496:  MOVLW  02
3498:  MOVWF  FF7
349A:  CALL   0A28
....................       lcd_gotoxy(9,3); 
349E:  MOVLW  09
34A0:  MOVLB  1
34A2:  MOVWF  xD7
34A4:  MOVLW  03
34A6:  MOVWF  xD8
34A8:  MOVLB  0
34AA:  CALL   0852
....................       lcd_putc("    "); 
34AE:  MOVLW  D8
34B0:  MOVWF  FF6
34B2:  MOVLW  02
34B4:  MOVWF  FF7
34B6:  CALL   0A28
....................       lcd_gotoxy(9,4); 
34BA:  MOVLW  09
34BC:  MOVLB  1
34BE:  MOVWF  xD7
34C0:  MOVLW  04
34C2:  MOVWF  xD8
34C4:  MOVLB  0
34C6:  CALL   0852
....................       lcd_putc("    "); 
34CA:  MOVLW  DE
34CC:  MOVWF  FF6
34CE:  MOVLW  02
34D0:  MOVWF  FF7
34D2:  CALL   0A28
....................    } 
....................     
....................    if( (flag_enviar)&&(cta_enviar>=2000)&&(master) ) envia2();//Si el poste esclavo no contesta enviar sin conexion 
34D6:  MOVF   46,F
34D8:  BZ    34F2
34DA:  MOVF   4F,W
34DC:  SUBLW  06
34DE:  BC    34F2
34E0:  XORLW  FF
34E2:  BNZ   34EA
34E4:  MOVF   4E,W
34E6:  SUBLW  CF
34E8:  BC    34F2
34EA:  MOVF   45,F
34EC:  BTFSS  FD8.2
34EE:  GOTO   1A84
....................    if(transmitir) envio();//cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
34F2:  MOVF   24,F
34F4:  BTFSC  FD8.2
34F6:  BRA    34FC
34F8:  GOTO   1C82
....................     
....................    if( (bloq_p1)&&(tim_p1>=time_bloqueo)&&(!en_b1) ) {//bloqueo de par 1 por ms de X segundos 
34FC:  MOVF   x9B,F
34FE:  BZ    356C
3500:  MOVF   xA2,W
3502:  SUBLW  00
3504:  BC    356C
3506:  XORLW  FF
3508:  BNZ   3510
350A:  MOVF   xA1,W
350C:  SUBLW  F3
350E:  BC    356C
3510:  MOVF   x9E,F
3512:  BNZ   356C
....................        bloq_p1=0;//bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
3514:  CLRF   x9B
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){//si no habia un bloqueo antes 
3516:  MOVF   x9E,F
3518:  BNZ   3568
351A:  MOVF   x9F,F
351C:  BNZ   3568
351E:  MOVF   xA0,F
3520:  BNZ   3568
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
3522:  MOVLW  0A
3524:  MOVLB  1
3526:  MOVWF  xD7
3528:  MOVLW  01
352A:  MOVWF  xD8
352C:  MOVLB  0
352E:  CALL   0852
....................             lcd_putc("BL"); 
3532:  MOVLW  E4
3534:  MOVWF  FF6
3536:  MOVLW  02
3538:  MOVWF  FF7
353A:  CALL   0A28
....................             cta_bloq1++; 
353E:  INCF   52,F
....................             write_ext_eeprom(9,cta_bloq1);//bloq1 
3540:  MOVLB  1
3542:  CLRF   xD1
3544:  MOVLW  09
3546:  MOVWF  xD0
3548:  MOVFF  52,1D2
354C:  MOVLB  0
354E:  CALL   0598
....................             if( (master==1)&&(j==0) ) solicitar(); 
3552:  DECFSZ 45,W
3554:  BRA    3560
3556:  MOVF   43,F
3558:  BNZ   3560
355A:  CALL   1194
355E:  BRA    3568
....................             else if(j==0) envio_master(); 
3560:  MOVF   43,F
3562:  BTFSC  FD8.2
3564:  CALL   121C
....................        } 
....................        en_b1=1;//bandera de bloqueo detectado en par 1 
3568:  MOVLW  01
356A:  MOVWF  x9E
....................    } 
....................    if( (bloq_p2)&&(tim_p2>=time_bloqueo)&&(!en_b2) ) {//bloqueo de par 2 por ms de X segundos 
356C:  MOVF   x9C,F
356E:  BZ    35DC
3570:  MOVF   xA4,W
3572:  SUBLW  00
3574:  BC    35DC
3576:  XORLW  FF
3578:  BNZ   3580
357A:  MOVF   xA3,W
357C:  SUBLW  F3
357E:  BC    35DC
3580:  MOVF   x9F,F
3582:  BNZ   35DC
....................        bloq_p2=0; 
3584:  CLRF   x9C
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3586:  MOVF   x9E,F
3588:  BNZ   35D8
358A:  MOVF   x9F,F
358C:  BNZ   35D8
358E:  MOVF   xA0,F
3590:  BNZ   35D8
....................            lcd_gotoxy(10,1);//cronometro para limpiar 
3592:  MOVLW  0A
3594:  MOVLB  1
3596:  MOVWF  xD7
3598:  MOVLW  01
359A:  MOVWF  xD8
359C:  MOVLB  0
359E:  CALL   0852
....................            lcd_putc("BL"); 
35A2:  MOVLW  E8
35A4:  MOVWF  FF6
35A6:  MOVLW  02
35A8:  MOVWF  FF7
35AA:  CALL   0A28
....................            cta_bloq2++; 
35AE:  INCF   53,F
....................            write_ext_eeprom(10,cta_bloq2);//bloq2 
35B0:  MOVLB  1
35B2:  CLRF   xD1
35B4:  MOVLW  0A
35B6:  MOVWF  xD0
35B8:  MOVFF  53,1D2
35BC:  MOVLB  0
35BE:  CALL   0598
....................            if( (master==1)&&(j==0) ) solicitar(); 
35C2:  DECFSZ 45,W
35C4:  BRA    35D0
35C6:  MOVF   43,F
35C8:  BNZ   35D0
35CA:  CALL   1194
35CE:  BRA    35D8
....................            else if(j==0) envio_master(); 
35D0:  MOVF   43,F
35D2:  BTFSC  FD8.2
35D4:  CALL   121C
....................        } 
....................        en_b2=1; 
35D8:  MOVLW  01
35DA:  MOVWF  x9F
....................    } 
....................    if( (bloq_p3)&&(tim_p3>=time_bloqueo)&&(!en_b3) ) {//bloqueo de par 3 por ms de X segundos 
35DC:  MOVF   x9D,F
35DE:  BZ    364C
35E0:  MOVF   xA6,W
35E2:  SUBLW  00
35E4:  BC    364C
35E6:  XORLW  FF
35E8:  BNZ   35F0
35EA:  MOVF   xA5,W
35EC:  SUBLW  F3
35EE:  BC    364C
35F0:  MOVF   xA0,F
35F2:  BNZ   364C
....................        bloq_p3=0; 
35F4:  CLRF   x9D
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
35F6:  MOVF   x9E,F
35F8:  BNZ   3648
35FA:  MOVF   x9F,F
35FC:  BNZ   3648
35FE:  MOVF   xA0,F
3600:  BNZ   3648
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
3602:  MOVLW  0A
3604:  MOVLB  1
3606:  MOVWF  xD7
3608:  MOVLW  01
360A:  MOVWF  xD8
360C:  MOVLB  0
360E:  CALL   0852
....................             lcd_putc("BL"); 
3612:  MOVLW  EC
3614:  MOVWF  FF6
3616:  MOVLW  02
3618:  MOVWF  FF7
361A:  CALL   0A28
....................             cta_bloq3++; 
361E:  INCF   54,F
....................             write_ext_eeprom(11,cta_bloq3);//bloq3 
3620:  MOVLB  1
3622:  CLRF   xD1
3624:  MOVLW  0B
3626:  MOVWF  xD0
3628:  MOVFF  54,1D2
362C:  MOVLB  0
362E:  CALL   0598
....................             if( (master==1)&&(j==0) ) solicitar(); 
3632:  DECFSZ 45,W
3634:  BRA    3640
3636:  MOVF   43,F
3638:  BNZ   3640
363A:  CALL   1194
363E:  BRA    3648
....................             else if(j==0) envio_master(); 
3640:  MOVF   43,F
3642:  BTFSC  FD8.2
3644:  CALL   121C
....................        } 
....................        en_b3=1; 
3648:  MOVLW  01
364A:  MOVWF  xA0
....................    }//end deteccion 
....................    if( (!bloq_p3)&&(!bloq_p2)&&(!bloq_p1) ){//Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
364C:  MOVF   x9D,F
364E:  BNZ   3674
3650:  MOVF   x9C,F
3652:  BNZ   3674
3654:  MOVF   x9B,F
3656:  BNZ   3674
....................       lcd_gotoxy(10,1); 
3658:  MOVLW  0A
365A:  MOVLB  1
365C:  MOVWF  xD7
365E:  MOVLW  01
3660:  MOVWF  xD8
3662:  MOVLB  0
3664:  CALL   0852
....................       lcd_putc("  "); 
3668:  MOVLW  F0
366A:  MOVWF  FF6
366C:  MOVLW  02
366E:  MOVWF  FF7
3670:  CALL   0A28
....................    } 
....................     
....................    if( (time_clr>=900)&&(f_clr) ){//refresca LCD 
3674:  MOVF   3F,W
3676:  SUBLW  02
3678:  BC    368E
367A:  XORLW  FF
367C:  BNZ   3684
367E:  MOVF   3E,W
3680:  SUBLW  83
3682:  BC    368E
3684:  MOVF   47,F
3686:  BZ    368E
....................         lcd_cuentas(); 
3688:  CALL   0A48
....................          f_clr=0; 
368C:  CLRF   47
....................    } 
....................    sensores();//Revisa estado de los sensores 
368E:  GOTO   2AE8
....................        
....................    restart_wdt(); 
3692:  CLRWDT
3694:  BRA    31A0
....................  }//end true 
.................... }//end main 
....................  
3696:  SLEEP 
.................... void solicitar(){//Solicita cuenta al poste esclavo 
....................    fprintf(monitor,"SOLICITADO\r");//4 
*
1194:  MOVLW  F4
1196:  MOVWF  FF6
1198:  MOVLW  02
119A:  MOVWF  FF7
119C:  RCALL  0E20
....................    time_envio=0; 
119E:  CLRF   xAA
11A0:  CLRF   xA9
....................    flag_enviar=1; 
11A2:  MOVLW  01
11A4:  MOVWF  46
....................    cta_enviar=0; 
11A6:  CLRF   4F
11A8:  CLRF   4E
11AA:  RETURN 0
.................... } 
....................  
.................... void envio_master(){//reporta al maestro 
....................     int16 envit; 
....................     envit=(entraront + salieront)/2; 
*
121C:  MOVF   x8C,W
121E:  ADDWF  x8A,W
1220:  MOVLB  1
1222:  MOVWF  xCE
1224:  MOVLB  0
1226:  MOVF   x8D,W
1228:  ADDWFC x8B,W
122A:  MOVLB  1
122C:  MOVWF  xCF
122E:  BCF    FD8.0
1230:  RRCF   xCF,W
1232:  MOVWF  xCD
1234:  RRCF   xCE,W
1236:  MOVWF  xCC
....................     cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1238:  MOVF   53,W
123A:  ADDWF  52,W
123C:  ADDWF  54,W
123E:  MOVWF  4C
1240:  CLRF   4D
....................     clear_lcd1=1; 
1242:  MOVLW  01
1244:  MOVLB  0
1246:  MOVWF  xAB
....................     time_lcd1=0; 
1248:  CLRF   xAC
....................     lcd_gotoxy(9,3);//cronometro para limpiar 
124A:  MOVLW  09
124C:  MOVLB  1
124E:  MOVWF  xD7
1250:  MOVLW  03
1252:  MOVWF  xD8
1254:  MOVLB  0
1256:  CALL   0852
....................     lcd_putc(0xAB); 
125A:  MOVLW  AB
125C:  MOVLB  1
125E:  MOVWF  xD6
1260:  MOVLB  0
1262:  CALL   08A4
....................     //fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
....................       fprintf(monitor,"PASAJEROS:\r"); 
1266:  MOVLW  00
1268:  MOVWF  FF6
126A:  MOVLW  03
126C:  MOVWF  FF7
126E:  RCALL  0E20
1270:  RETURN 0
....................      // fprintf(monitor,"PASAJEROS\r%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
.................... } 
....................  
.................... int convertir_to_entero(char *cadena) { 
*
1BDA:  MOVLB  1
1BDC:  CLRF   xCE
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
1BDE:  MOVF   xCC,W
1BE0:  SUBLW  30
1BE2:  BNZ   1BEC
1BE4:  MOVF   xCD,F
1BE6:  BNZ   1BEC
1BE8:  CLRF   xCE
1BEA:  BRA    1C7A
....................    else if(cadena=='1') valor=1; 
1BEC:  MOVF   xCC,W
1BEE:  SUBLW  31
1BF0:  BNZ   1BFC
1BF2:  MOVF   xCD,F
1BF4:  BNZ   1BFC
1BF6:  MOVLW  01
1BF8:  MOVWF  xCE
1BFA:  BRA    1C7A
....................    else if(cadena=='2') valor=2; 
1BFC:  MOVF   xCC,W
1BFE:  SUBLW  32
1C00:  BNZ   1C0C
1C02:  MOVF   xCD,F
1C04:  BNZ   1C0C
1C06:  MOVLW  02
1C08:  MOVWF  xCE
1C0A:  BRA    1C7A
....................    else if(cadena=='3') valor=3; 
1C0C:  MOVF   xCC,W
1C0E:  SUBLW  33
1C10:  BNZ   1C1C
1C12:  MOVF   xCD,F
1C14:  BNZ   1C1C
1C16:  MOVLW  03
1C18:  MOVWF  xCE
1C1A:  BRA    1C7A
....................    else if(cadena=='4') valor=4; 
1C1C:  MOVF   xCC,W
1C1E:  SUBLW  34
1C20:  BNZ   1C2C
1C22:  MOVF   xCD,F
1C24:  BNZ   1C2C
1C26:  MOVLW  04
1C28:  MOVWF  xCE
1C2A:  BRA    1C7A
....................    else if(cadena=='5') valor=5; 
1C2C:  MOVF   xCC,W
1C2E:  SUBLW  35
1C30:  BNZ   1C3C
1C32:  MOVF   xCD,F
1C34:  BNZ   1C3C
1C36:  MOVLW  05
1C38:  MOVWF  xCE
1C3A:  BRA    1C7A
....................    else if(cadena=='6') valor=6; 
1C3C:  MOVF   xCC,W
1C3E:  SUBLW  36
1C40:  BNZ   1C4C
1C42:  MOVF   xCD,F
1C44:  BNZ   1C4C
1C46:  MOVLW  06
1C48:  MOVWF  xCE
1C4A:  BRA    1C7A
....................    else if(cadena=='7') valor=7; 
1C4C:  MOVF   xCC,W
1C4E:  SUBLW  37
1C50:  BNZ   1C5C
1C52:  MOVF   xCD,F
1C54:  BNZ   1C5C
1C56:  MOVLW  07
1C58:  MOVWF  xCE
1C5A:  BRA    1C7A
....................    else if(cadena=='8') valor=8; 
1C5C:  MOVF   xCC,W
1C5E:  SUBLW  38
1C60:  BNZ   1C6C
1C62:  MOVF   xCD,F
1C64:  BNZ   1C6C
1C66:  MOVLW  08
1C68:  MOVWF  xCE
1C6A:  BRA    1C7A
....................    else if(cadena=='9') valor=9; 
1C6C:  MOVF   xCC,W
1C6E:  SUBLW  39
1C70:  BNZ   1C7A
1C72:  MOVF   xCD,F
1C74:  BNZ   1C7A
1C76:  MOVLW  09
1C78:  MOVWF  xCE
....................    return valor; 
1C7A:  MOVFF  1CE,01
1C7E:  MOVLB  0
1C80:  RETURN 0
.................... } 
....................  
.................... void enviop1(){//Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
16DA:  BCF    F9D.5
....................    entran1=0; 
16DC:  CLRF   39
16DE:  CLRF   38
....................    salen1=0; 
16E0:  CLRF   3B
16E2:  CLRF   3A
....................    temporal1=0; 
16E4:  CLRF   2F
16E6:  CLRF   2E
....................    temporal2=0; 
16E8:  CLRF   31
16EA:  CLRF   30
....................    temporal3=0; 
16EC:  CLRF   x97
16EE:  CLRF   x96
....................    tempo_tn=0; 
16F0:  CLRF   33
16F2:  CLRF   32
....................    pasajet=0; 
16F4:  CLRF   x91
16F6:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));//entran=0; 
16F8:  MOVLW  01
16FA:  MOVWF  FEA
16FC:  MOVLW  AD
16FE:  MOVWF  FE9
1700:  CLRF   00
1702:  CLRF   02
1704:  MOVLW  05
1706:  MOVWF  01
1708:  RCALL  1272
....................    memset(salen, 0, sizeof(salen));//salen=0; 
170A:  MOVLW  01
170C:  MOVWF  FEA
170E:  MOVLW  B2
1710:  MOVWF  FE9
1712:  CLRF   00
1714:  CLRF   02
1716:  MOVLW  05
1718:  MOVWF  01
171A:  RCALL  1272
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
171C:  MOVLW  01
171E:  MOVWF  FEA
1720:  MOVLW  B7
1722:  MOVWF  FE9
1724:  CLRF   00
1726:  CLRF   02
1728:  MOVLW  05
172A:  MOVWF  01
172C:  RCALL  1272
....................    memset(bloqueado, 0, sizeof(tempo_tc));//total 
172E:  MOVLW  01
1730:  MOVWF  FEA
1732:  MOVLW  B7
1734:  MOVWF  FE9
1736:  CLRF   00
1738:  CLRF   02
173A:  MOVLW  05
173C:  MOVWF  01
173E:  RCALL  1272
....................    i=10; 
1740:  MOVLW  0A
1742:  MOVWF  41
....................    ii=0; 
1744:  CLRF   42
....................    /* 
....................    for(ii=0;ii<=3;ii++)  entran[ii]=XX[10 +ii]; 
....................    for(ii=0;ii<=3;ii++)  salen[ii]=XX[15 +ii]; 
....................    for(ii=0;ii<=2;ii++)  bloqueado[ii]=XX[20 +ii]; 
....................    for(ii=0;ii<=3;ii++)  tempo_tc[ii]=XX[24 +ii]; 
....................    */ 
....................    /* 
....................    char cadena[] = "Hola,mundo,soy,una,cadena,separa,por,comas", 
....................    delimitador[] = ","; 
....................    char *token = strtok(cadena, delimitador); 
....................        if(token != NULL){ 
....................         while(token != NULL){ 
....................             // Slo en la primera pasamos la cadena; en las siguientes pasamos NULL 
....................            // printf("Token: %s\n", token); 
....................             token = strtok(NULL, delimitador); 
....................         } 
....................        } 
....................        */ 
....................     
....................     
....................  
....................   
....................    //strcpy(string,XX); 
....................    //char str[] ="This is - www.tutorialspoint.com - website"; 
....................    strcpy(term,":/"); 
1746:  CLRF   FEA
1748:  MOVLW  B1
174A:  MOVWF  FE9
174C:  MOVLW  00
174E:  CALL   00DA
1752:  TBLRD*-
1754:  TBLRD*+
1756:  MOVF   FF5,W
1758:  MOVWF  FEE
175A:  IORLW  00
175C:  BNZ   1754
....................    ptr = strtok(XX, term); 
175E:  MOVLW  01
1760:  MOVLB  1
1762:  MOVWF  xCE
1764:  MOVLW  8D
1766:  MOVWF  xCD
1768:  CLRF   xD0
176A:  MOVLW  B1
176C:  MOVWF  xCF
176E:  MOVLB  0
1770:  RCALL  1396
1772:  MOVFF  02,B5
1776:  MOVFF  01,B4
....................    //lcd_gotoxy(9,2); 
....................    //printf(lcd_putc,"%s",ptr); 
....................     int conteo_wl=0; 
177A:  MOVLB  1
177C:  CLRF   xCC
....................   // while(ptr!=0) { 
....................           
....................          strcpy(data1,ptr);                        // 1ra Palabra 
177E:  CLRF   FEA
1780:  MOVLW  B6
1782:  MOVWF  FE9
1784:  MOVFF  B5,FE2
1788:  MOVFF  B4,FE1
178C:  MOVF   FE7,F
178E:  MOVFF  FE6,FEE
1792:  BNZ   178C
....................          strcpy(data2, strtok(NULL , term));       // 2ra Palabra 
1794:  CLRF   xCE
1796:  CLRF   xCD
1798:  CLRF   xD0
179A:  MOVLW  B1
179C:  MOVWF  xCF
179E:  MOVLB  0
17A0:  RCALL  1396
17A2:  MOVFF  02,1CE
17A6:  MOVFF  01,1CD
17AA:  CLRF   FEA
17AC:  MOVLW  C4
17AE:  MOVWF  FE9
17B0:  MOVFF  02,FE2
17B4:  MOVFF  01,FE1
17B8:  MOVF   FE7,F
17BA:  MOVFF  FE6,FEE
17BE:  BNZ   17B8
....................          strcpy(data3, strtok(NULL , term));       // 3ra Palabra 
17C0:  MOVLB  1
17C2:  CLRF   xCE
17C4:  CLRF   xCD
17C6:  CLRF   xD0
17C8:  MOVLW  B1
17CA:  MOVWF  xCF
17CC:  MOVLB  0
17CE:  RCALL  1396
17D0:  MOVFF  02,1CE
17D4:  MOVFF  01,1CD
17D8:  CLRF   FEA
17DA:  MOVLW  CE
17DC:  MOVWF  FE9
17DE:  MOVFF  02,FE2
17E2:  MOVFF  01,FE1
17E6:  MOVF   FE7,F
17E8:  MOVFF  FE6,FEE
17EC:  BNZ   17E6
....................          strcpy(data4, strtok(NULL , term));       // 4ra Palabra 
17EE:  MOVLB  1
17F0:  CLRF   xCE
17F2:  CLRF   xCD
17F4:  CLRF   xD0
17F6:  MOVLW  B1
17F8:  MOVWF  xCF
17FA:  MOVLB  0
17FC:  RCALL  1396
17FE:  MOVFF  02,1CE
1802:  MOVFF  01,1CD
1806:  CLRF   FEA
1808:  MOVLW  D8
180A:  MOVWF  FE9
180C:  MOVFF  02,FE2
1810:  MOVFF  01,FE1
1814:  MOVF   FE7,F
1816:  MOVFF  FE6,FEE
181A:  BNZ   1814
....................          strcpy(data5, strtok(NULL , term));       // 5ra Palabra 
181C:  MOVLB  1
181E:  CLRF   xCE
1820:  CLRF   xCD
1822:  CLRF   xD0
1824:  MOVLW  B1
1826:  MOVWF  xCF
1828:  MOVLB  0
182A:  RCALL  1396
182C:  MOVFF  02,1CE
1830:  MOVFF  01,1CD
1834:  CLRF   FEA
1836:  MOVLW  E2
1838:  MOVWF  FE9
183A:  MOVFF  02,FE2
183E:  MOVFF  01,FE1
1842:  MOVF   FE7,F
1844:  MOVFF  FE6,FEE
1848:  BNZ   1842
....................          ptr = strtok(0, term); 
184A:  MOVLB  1
184C:  CLRF   xCE
184E:  CLRF   xCD
1850:  CLRF   xD0
1852:  MOVLW  B1
1854:  MOVWF  xCF
1856:  MOVLB  0
1858:  RCALL  1396
185A:  MOVFF  02,B5
185E:  MOVFF  01,B4
....................           
....................           
....................          //ptr = strtok(0, term); 
....................          conteo_wl++; 
1862:  MOVLB  1
1864:  INCF   xCC,F
....................          sub_atras = atoi32(data2); 
1866:  CLRF   xCE
1868:  MOVLW  C4
186A:  MOVWF  xCD
186C:  MOVLB  0
186E:  RCALL  1446
1870:  MOVFF  01,35
1874:  MOVFF  00,34
....................          baj_atras = atoi32(data3); 
1878:  MOVLB  1
187A:  CLRF   xCE
187C:  MOVLW  CE
187E:  MOVWF  xCD
1880:  MOVLB  0
1882:  RCALL  1446
1884:  MOVFF  01,37
1888:  MOVFF  00,36
....................          lcd_gotoxy(14,3); 
188C:  MOVLW  0E
188E:  MOVLB  1
1890:  MOVWF  xD7
1892:  MOVLW  03
1894:  MOVWF  xD8
1896:  MOVLB  0
1898:  CALL   0852
....................           printf(lcd_putc,"S2:%Ld ",sub_atras); 
189C:  MOVLW  0C
189E:  MOVWF  FF6
18A0:  MOVLW  03
18A2:  MOVWF  FF7
18A4:  MOVLW  03
18A6:  MOVLB  1
18A8:  MOVWF  xCD
18AA:  MOVLB  0
18AC:  CALL   0904
18B0:  MOVLW  10
18B2:  MOVWF  FE9
18B4:  MOVFF  35,1CE
18B8:  MOVFF  34,1CD
18BC:  CALL   092C
18C0:  MOVLW  20
18C2:  MOVLB  1
18C4:  MOVWF  xD6
18C6:  MOVLB  0
18C8:  CALL   08A4
....................           lcd_gotoxy(14,4); 
18CC:  MOVLW  0E
18CE:  MOVLB  1
18D0:  MOVWF  xD7
18D2:  MOVLW  04
18D4:  MOVWF  xD8
18D6:  MOVLB  0
18D8:  CALL   0852
....................           printf(lcd_putc,"B2:%Ld ",baj_atras); 
18DC:  MOVLW  14
18DE:  MOVWF  FF6
18E0:  MOVLW  03
18E2:  MOVWF  FF7
18E4:  MOVLW  03
18E6:  MOVLB  1
18E8:  MOVWF  xCD
18EA:  MOVLB  0
18EC:  CALL   0904
18F0:  MOVLW  10
18F2:  MOVWF  FE9
18F4:  MOVFF  37,1CE
18F8:  MOVFF  36,1CD
18FC:  CALL   092C
1900:  MOVLW  20
1902:  MOVLB  1
1904:  MOVWF  xD6
1906:  MOVLB  0
1908:  CALL   08A4
190C:  GOTO   338A (RETURN)
....................           //delay_ms(3000); 
....................           
....................          /* 
....................          printf(lcd_putc,"\f"); 
....................          lcd_gotoxy(1,1); 
....................          printf(lcd_putc,"%s->%ld",data2,sub_atras); 
....................          lcd_gotoxy(1,2); 
....................          printf(lcd_putc,"%s->%ld",data3,baj_atras); 
....................          lcd_gotoxy(1,3); 
....................          printf(lcd_putc,"%s",data4); 
....................          lcd_gotoxy(1,4); 
....................          printf(lcd_putc,"%s",data5); 
....................         delay_ms(5000); 
....................         */ 
....................           
....................       //} 
....................        
....................        
....................    //char conteo_poste_trasero; 
....................    //strncpy (conteo_poste_trasero, XX,  10); 
....................    /* 
....................    strcpy ( entran, data2); 
....................    entran[4] = '\0';   // null character manually added  
....................    strcpy ( salen, data3); 
....................    salen[4] = '\0';   // null character manually added  
....................    strcpy ( bloqueado, data4); 
....................    bloqueado[3] = '\0';   // null character manually added  
....................    strcpy ( tempo_tc, data5); 
....................    tempo_tc[4] = '\0';   //null character manually added  
....................    */ 
....................    //lcd_gotoxy(12,2); 
....................    //printf(lcd_putc,"%c%c",data1[0],data1[8]); 
....................     
.................... //!   lcd_gotoxy(15,3);// 
.................... //!   printf(lcd_putc,"A:%c%c%c%c",tempo_tc[0],tempo_tc[1],tempo_tc[2],tempo_tc[3]); 
.................... } 
....................  
.................... void envio(){//crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................    if(convertir_to_entero(tempo_tc[0]) >0) for(i=0;i< convertir_to_entero(tempo_tc[0]);i++) tempo_tn=tempo_tn+1000; 
*
1C82:  MOVLB  1
1C84:  CLRF   xCD
1C86:  MOVFF  1C6,1CC
1C8A:  MOVLB  0
1C8C:  RCALL  1BDA
1C8E:  MOVF   01,F
1C90:  BZ    1CB2
1C92:  CLRF   41
1C94:  MOVLB  1
1C96:  CLRF   xCD
1C98:  MOVFF  1C6,1CC
1C9C:  MOVLB  0
1C9E:  RCALL  1BDA
1CA0:  MOVF   01,W
1CA2:  SUBWF  41,W
1CA4:  BC    1CB2
1CA6:  MOVLW  E8
1CA8:  ADDWF  32,F
1CAA:  MOVLW  03
1CAC:  ADDWFC 33,F
1CAE:  INCF   41,F
1CB0:  BRA    1C94
....................    if(convertir_to_entero(tempo_tc[1]) >0) for(i=0;i< convertir_to_entero(tempo_tc[1]);i++) tempo_tn=tempo_tn+100; 
1CB2:  MOVLB  1
1CB4:  CLRF   xCD
1CB6:  MOVFF  1C7,1CC
1CBA:  MOVLB  0
1CBC:  RCALL  1BDA
1CBE:  MOVF   01,F
1CC0:  BZ    1CE2
1CC2:  CLRF   41
1CC4:  MOVLB  1
1CC6:  CLRF   xCD
1CC8:  MOVFF  1C7,1CC
1CCC:  MOVLB  0
1CCE:  RCALL  1BDA
1CD0:  MOVF   01,W
1CD2:  SUBWF  41,W
1CD4:  BC    1CE2
1CD6:  MOVLW  64
1CD8:  ADDWF  32,F
1CDA:  MOVLW  00
1CDC:  ADDWFC 33,F
1CDE:  INCF   41,F
1CE0:  BRA    1CC4
....................    if(convertir_to_entero(tempo_tc[2]) >0) for(i=0;i< convertir_to_entero(tempo_tc[2]);i++) tempo_tn=tempo_tn+10; 
1CE2:  MOVLB  1
1CE4:  CLRF   xCD
1CE6:  MOVFF  1C8,1CC
1CEA:  MOVLB  0
1CEC:  RCALL  1BDA
1CEE:  MOVF   01,F
1CF0:  BZ    1D12
1CF2:  CLRF   41
1CF4:  MOVLB  1
1CF6:  CLRF   xCD
1CF8:  MOVFF  1C8,1CC
1CFC:  MOVLB  0
1CFE:  RCALL  1BDA
1D00:  MOVF   01,W
1D02:  SUBWF  41,W
1D04:  BC    1D12
1D06:  MOVLW  0A
1D08:  ADDWF  32,F
1D0A:  MOVLW  00
1D0C:  ADDWFC 33,F
1D0E:  INCF   41,F
1D10:  BRA    1CF4
....................    tempo_tn=tempo_tn+convertir_to_entero(tempo_tc[3]); 
1D12:  MOVLB  1
1D14:  CLRF   xCD
1D16:  MOVFF  1C9,1CC
1D1A:  MOVLB  0
1D1C:  RCALL  1BDA
1D1E:  MOVF   01,W
1D20:  ADDWF  32,F
1D22:  MOVLW  00
1D24:  ADDWFC 33,F
....................    //////////////////////////////////////////////////// 
....................    if(convertir_to_entero(entran[0]) >0) for(i=0;i< convertir_to_entero(entran[0]);i++) temporal1=temporal1+1000; 
1D26:  MOVLB  1
1D28:  CLRF   xCD
1D2A:  MOVFF  1AD,1CC
1D2E:  MOVLB  0
1D30:  RCALL  1BDA
1D32:  MOVF   01,F
1D34:  BZ    1D56
1D36:  CLRF   41
1D38:  MOVLB  1
1D3A:  CLRF   xCD
1D3C:  MOVFF  1AD,1CC
1D40:  MOVLB  0
1D42:  RCALL  1BDA
1D44:  MOVF   01,W
1D46:  SUBWF  41,W
1D48:  BC    1D56
1D4A:  MOVLW  E8
1D4C:  ADDWF  2E,F
1D4E:  MOVLW  03
1D50:  ADDWFC 2F,F
1D52:  INCF   41,F
1D54:  BRA    1D38
....................    if(convertir_to_entero(entran[1]) >0) for(i=0;i< convertir_to_entero(entran[1]);i++) temporal1=temporal1+100; 
1D56:  MOVLB  1
1D58:  CLRF   xCD
1D5A:  MOVFF  1AE,1CC
1D5E:  MOVLB  0
1D60:  RCALL  1BDA
1D62:  MOVF   01,F
1D64:  BZ    1D86
1D66:  CLRF   41
1D68:  MOVLB  1
1D6A:  CLRF   xCD
1D6C:  MOVFF  1AE,1CC
1D70:  MOVLB  0
1D72:  RCALL  1BDA
1D74:  MOVF   01,W
1D76:  SUBWF  41,W
1D78:  BC    1D86
1D7A:  MOVLW  64
1D7C:  ADDWF  2E,F
1D7E:  MOVLW  00
1D80:  ADDWFC 2F,F
1D82:  INCF   41,F
1D84:  BRA    1D68
....................    if(convertir_to_entero(entran[2]) >0) for(i=0;i< convertir_to_entero(entran[2]);i++) temporal1=temporal1+10; 
1D86:  MOVLB  1
1D88:  CLRF   xCD
1D8A:  MOVFF  1AF,1CC
1D8E:  MOVLB  0
1D90:  RCALL  1BDA
1D92:  MOVF   01,F
1D94:  BZ    1DB6
1D96:  CLRF   41
1D98:  MOVLB  1
1D9A:  CLRF   xCD
1D9C:  MOVFF  1AF,1CC
1DA0:  MOVLB  0
1DA2:  RCALL  1BDA
1DA4:  MOVF   01,W
1DA6:  SUBWF  41,W
1DA8:  BC    1DB6
1DAA:  MOVLW  0A
1DAC:  ADDWF  2E,F
1DAE:  MOVLW  00
1DB0:  ADDWFC 2F,F
1DB2:  INCF   41,F
1DB4:  BRA    1D98
....................     
....................    //sub_atras = atol(entran); 
....................   // sub_atras = atoi32(data2); 
....................    //sub_atras=temporal1=temporal1+convertir_to_entero(entran[3]); 
....................     
....................    if(convertir_to_entero(salen[0]) >0) for(i=0;i< convertir_to_entero(salen[0]);i++) temporal2=temporal2+1000; 
1DB6:  MOVLB  1
1DB8:  CLRF   xCD
1DBA:  MOVFF  1B2,1CC
1DBE:  MOVLB  0
1DC0:  RCALL  1BDA
1DC2:  MOVF   01,F
1DC4:  BZ    1DE6
1DC6:  CLRF   41
1DC8:  MOVLB  1
1DCA:  CLRF   xCD
1DCC:  MOVFF  1B2,1CC
1DD0:  MOVLB  0
1DD2:  RCALL  1BDA
1DD4:  MOVF   01,W
1DD6:  SUBWF  41,W
1DD8:  BC    1DE6
1DDA:  MOVLW  E8
1DDC:  ADDWF  30,F
1DDE:  MOVLW  03
1DE0:  ADDWFC 31,F
1DE2:  INCF   41,F
1DE4:  BRA    1DC8
....................    if(convertir_to_entero(salen[1]) >0) for(i=0;i< convertir_to_entero(salen[1]);i++) temporal2=temporal2+100; 
1DE6:  MOVLB  1
1DE8:  CLRF   xCD
1DEA:  MOVFF  1B3,1CC
1DEE:  MOVLB  0
1DF0:  RCALL  1BDA
1DF2:  MOVF   01,F
1DF4:  BZ    1E16
1DF6:  CLRF   41
1DF8:  MOVLB  1
1DFA:  CLRF   xCD
1DFC:  MOVFF  1B3,1CC
1E00:  MOVLB  0
1E02:  RCALL  1BDA
1E04:  MOVF   01,W
1E06:  SUBWF  41,W
1E08:  BC    1E16
1E0A:  MOVLW  64
1E0C:  ADDWF  30,F
1E0E:  MOVLW  00
1E10:  ADDWFC 31,F
1E12:  INCF   41,F
1E14:  BRA    1DF8
....................    if(convertir_to_entero(salen[2]) >0) for(i=0;i< convertir_to_entero(salen[2]);i++) temporal2=temporal2+10; 
1E16:  MOVLB  1
1E18:  CLRF   xCD
1E1A:  MOVFF  1B4,1CC
1E1E:  MOVLB  0
1E20:  RCALL  1BDA
1E22:  MOVF   01,F
1E24:  BZ    1E46
1E26:  CLRF   41
1E28:  MOVLB  1
1E2A:  CLRF   xCD
1E2C:  MOVFF  1B4,1CC
1E30:  MOVLB  0
1E32:  RCALL  1BDA
1E34:  MOVF   01,W
1E36:  SUBWF  41,W
1E38:  BC    1E46
1E3A:  MOVLW  0A
1E3C:  ADDWF  30,F
1E3E:  MOVLW  00
1E40:  ADDWFC 31,F
1E42:  INCF   41,F
1E44:  BRA    1E28
....................    //baj_atras = atol(salen); 
....................    //baj_atras = atoi32(data3); 
....................    //baj_atras=temporal2=temporal2+convertir_to_entero(salen[3]); 
....................     
....................    if(convertir_to_entero(bloqueado[0]) >0) for(i=0;i< convertir_to_entero(bloqueado[0]);i++) temporal3=temporal3+100; 
1E46:  MOVLB  1
1E48:  CLRF   xCD
1E4A:  MOVFF  1B7,1CC
1E4E:  MOVLB  0
1E50:  RCALL  1BDA
1E52:  MOVF   01,F
1E54:  BZ    1E76
1E56:  CLRF   41
1E58:  MOVLB  1
1E5A:  CLRF   xCD
1E5C:  MOVFF  1B7,1CC
1E60:  MOVLB  0
1E62:  RCALL  1BDA
1E64:  MOVF   01,W
1E66:  SUBWF  41,W
1E68:  BC    1E76
1E6A:  MOVLW  64
1E6C:  ADDWF  x96,F
1E6E:  MOVLW  00
1E70:  ADDWFC x97,F
1E72:  INCF   41,F
1E74:  BRA    1E58
....................    if(convertir_to_entero(bloqueado[1]) >0) for(i=0;i< convertir_to_entero(bloqueado[1]);i++) temporal3=temporal3+10; 
1E76:  MOVLB  1
1E78:  CLRF   xCD
1E7A:  MOVFF  1B8,1CC
1E7E:  MOVLB  0
1E80:  RCALL  1BDA
1E82:  MOVF   01,F
1E84:  BZ    1EA6
1E86:  CLRF   41
1E88:  MOVLB  1
1E8A:  CLRF   xCD
1E8C:  MOVFF  1B8,1CC
1E90:  MOVLB  0
1E92:  RCALL  1BDA
1E94:  MOVF   01,W
1E96:  SUBWF  41,W
1E98:  BC    1EA6
1E9A:  MOVLW  0A
1E9C:  ADDWF  x96,F
1E9E:  MOVLW  00
1EA0:  ADDWFC x97,F
1EA2:  INCF   41,F
1EA4:  BRA    1E88
....................    temporal3=temporal3+convertir_to_entero(bloqueado[2]); 
1EA6:  MOVLB  1
1EA8:  CLRF   xCD
1EAA:  MOVFF  1B9,1CC
1EAE:  MOVLB  0
1EB0:  RCALL  1BDA
1EB2:  MOVF   01,W
1EB4:  ADDWF  x96,F
1EB6:  MOVLW  00
1EB8:  ADDWFC x97,F
....................     
....................    entran1=(entraront+salieront)/2; 
1EBA:  MOVF   x8C,W
1EBC:  ADDWF  x8A,W
1EBE:  MOVLB  1
1EC0:  MOVWF  xCC
1EC2:  MOVLB  0
1EC4:  MOVF   x8D,W
1EC6:  ADDWFC x8B,W
1EC8:  MOVLB  1
1ECA:  MOVWF  xCD
1ECC:  BCF    FD8.0
1ECE:  RRCF   xCD,W
1ED0:  MOVWF  39
1ED2:  RRCF   xCC,W
1ED4:  MOVWF  38
....................     
....................    total2_t=(temporal1+temporal2)/2; 
1ED6:  MOVF   30,W
1ED8:  ADDWF  2E,W
1EDA:  MOVWF  xCC
1EDC:  MOVF   31,W
1EDE:  ADDWFC 2F,W
1EE0:  MOVWF  xCD
1EE2:  BCF    FD8.0
1EE4:  RRCF   xCD,W
1EE6:  MOVWF  51
1EE8:  RRCF   xCC,W
1EEA:  MOVWF  50
....................    ////////////////// 
.................... //!   lcd_gotoxy(16,1);// 
.................... //!   printf(lcd_putc,"S:%Lu",total2_t); 
.................... //!   lcd_gotoxy(16,2);// 
.................... //!   printf(lcd_putc,"R:%Lu",tempo_tn); 
....................     
....................    ///////////////// 
....................    leer_conta2(); 
1EEC:  MOVLB  0
1EEE:  CALL   0800
....................    if( total2_t== tempo_tn ) {//dato recibido correcto 
1EF2:  MOVF   32,W
1EF4:  SUBWF  50,W
1EF6:  BNZ   1F16
1EF8:  MOVF   33,W
1EFA:  SUBWF  51,W
1EFC:  BNZ   1F16
....................          salian=salen1=total2_t; 
1EFE:  MOVFF  51,3B
1F02:  MOVFF  50,3A
1F06:  MOVFF  3B,3D
1F0A:  MOVFF  3A,3C
....................          graba_conta2(); 
1F0E:  CALL   069E
....................          error=0; 
1F12:  CLRF   23
....................    } 
1F14:  BRA    1F1A
....................    else error=2; 
1F16:  MOVLW  02
1F18:  MOVWF  23
....................    ///////////// 
....................    pasajet=entran1+salen1; 
1F1A:  MOVF   3A,W
1F1C:  ADDWF  38,W
1F1E:  MOVWF  x90
1F20:  MOVF   3B,W
1F22:  ADDWFC 39,W
1F24:  MOVWF  x91
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1F26:  MOVF   53,W
1F28:  ADDWF  52,W
1F2A:  ADDWF  54,W
1F2C:  MOVWF  4C
1F2E:  CLRF   4D
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entran1,salen1,cta_bloqueo,temporal3,error); 
1F30:  MOVLW  1C
1F32:  MOVWF  FF6
1F34:  MOVLW  03
1F36:  MOVWF  FF7
1F38:  MOVLW  07
1F3A:  MOVLB  1
1F3C:  MOVWF  xCC
1F3E:  MOVLB  0
1F40:  RCALL  1910
1F42:  MOVLW  09
1F44:  MOVWF  FE9
1F46:  MOVFF  91,1CD
1F4A:  MOVFF  90,1CC
1F4E:  RCALL  1938
1F50:  MOVLW  2C
1F52:  MOVLB  1
1F54:  MOVWF  xD5
1F56:  MOVLB  0
1F58:  CALL   11AC
1F5C:  MOVLW  09
1F5E:  MOVWF  FE9
1F60:  MOVFF  39,1CD
1F64:  MOVFF  38,1CC
1F68:  RCALL  1938
1F6A:  MOVLW  2C
1F6C:  MOVLB  1
1F6E:  MOVWF  xD5
1F70:  MOVLB  0
1F72:  CALL   11AC
1F76:  MOVLW  09
1F78:  MOVWF  FE9
1F7A:  MOVFF  3B,1CD
1F7E:  MOVFF  3A,1CC
1F82:  RCALL  1938
1F84:  MOVLW  2C
1F86:  MOVLB  1
1F88:  MOVWF  xD5
1F8A:  MOVLB  0
1F8C:  CALL   11AC
1F90:  MOVLW  0A
1F92:  MOVWF  FE9
1F94:  MOVFF  4D,1CD
1F98:  MOVFF  4C,1CC
1F9C:  RCALL  1938
1F9E:  MOVLW  2C
1FA0:  MOVLB  1
1FA2:  MOVWF  xD5
1FA4:  MOVLB  0
1FA6:  CALL   11AC
1FAA:  MOVLW  0A
1FAC:  MOVWF  FE9
1FAE:  MOVFF  97,1CD
1FB2:  MOVFF  96,1CC
1FB6:  RCALL  1938
1FB8:  MOVLW  2C
1FBA:  MOVLB  1
1FBC:  MOVWF  xD5
1FBE:  MOVLB  0
1FC0:  CALL   11AC
1FC4:  MOVFF  23,1CC
1FC8:  MOVLW  01
1FCA:  MOVLB  1
1FCC:  MOVWF  xCD
1FCE:  MOVLB  0
1FD0:  RCALL  19FE
1FD2:  MOVLW  45
1FD4:  MOVWF  FF6
1FD6:  MOVLW  03
1FD8:  MOVWF  FF7
1FDA:  MOVLW  03
1FDC:  MOVLB  1
1FDE:  MOVWF  xCC
1FE0:  MOVLB  0
1FE2:  RCALL  1910
....................    lcd_cuentas(); 
1FE4:  CALL   0A48
....................    /////////////////////////// 
.................... //!   lcd_gotoxy(8,4); 
.................... //!   printf(lcd_putc,"M:%Ld E:%Ld T:%Ld ",entran1,salen1,pasajet); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1FE8:  MOVLW  09
1FEA:  MOVLB  1
1FEC:  MOVWF  xD7
1FEE:  MOVLW  03
1FF0:  MOVWF  xD8
1FF2:  MOVLB  0
1FF4:  CALL   0852
....................    lcd_putc(0xAB); 
1FF8:  MOVLW  AB
1FFA:  MOVLB  1
1FFC:  MOVWF  xD6
1FFE:  MOVLB  0
2000:  CALL   08A4
....................    //lcd_gotoxy(9,4);//cronometro para limpiar 
....................    //lcd_putc("    "); 
....................    clear_lcd1=1; 
2004:  MOVLW  01
2006:  MOVWF  xAB
....................    time_lcd1=0; 
2008:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
200A:  CLRF   xAA
200C:  CLRF   xA9
....................    transmitir=0; 
200E:  CLRF   24
....................    enable_interrupts(INT_RDA); 
2010:  BSF    F9D.5
2012:  GOTO   34FC (RETURN)
.................... } 
....................  
.................... void envia2(){//Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
1A84:  BCF    F9D.5
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1A86:  MOVF   53,W
1A88:  ADDWF  52,W
1A8A:  ADDWF  54,W
1A8C:  MOVWF  4C
1A8E:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));//entran=0; 
1A90:  MOVLW  01
1A92:  MOVWF  FEA
1A94:  MOVLW  AD
1A96:  MOVWF  FE9
1A98:  CLRF   00
1A9A:  CLRF   02
1A9C:  MOVLW  05
1A9E:  MOVWF  01
1AA0:  CALL   1272
....................    memset(salen, 0, sizeof(salen));//salen=0; 
1AA4:  MOVLW  01
1AA6:  MOVWF  FEA
1AA8:  MOVLW  B2
1AAA:  MOVWF  FE9
1AAC:  CLRF   00
1AAE:  CLRF   02
1AB0:  MOVLW  05
1AB2:  MOVWF  01
1AB4:  CALL   1272
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
1AB8:  MOVLW  01
1ABA:  MOVWF  FEA
1ABC:  MOVLW  B7
1ABE:  MOVWF  FE9
1AC0:  CLRF   00
1AC2:  CLRF   02
1AC4:  MOVLW  05
1AC6:  MOVWF  01
1AC8:  CALL   1272
....................    i=10; 
1ACC:  MOVLW  0A
1ACE:  MOVWF  41
....................    ii=0; 
1AD0:  CLRF   42
....................    entran1=(entraront+salieront)/2; 
1AD2:  MOVF   x8C,W
1AD4:  ADDWF  x8A,W
1AD6:  MOVLB  1
1AD8:  MOVWF  xCC
1ADA:  MOVLB  0
1ADC:  MOVF   x8D,W
1ADE:  ADDWFC x8B,W
1AE0:  MOVLB  1
1AE2:  MOVWF  xCD
1AE4:  BCF    FD8.0
1AE6:  RRCF   xCD,W
1AE8:  MOVWF  39
1AEA:  RRCF   xCC,W
1AEC:  MOVWF  38
....................    leer_conta2(); 
1AEE:  MOVLB  0
1AF0:  CALL   0800
....................    pasajet=entran1+salian; 
1AF4:  MOVF   3C,W
1AF6:  ADDWF  38,W
1AF8:  MOVWF  x90
1AFA:  MOVF   3D,W
1AFC:  ADDWFC 39,W
1AFE:  MOVWF  x91
....................    error=1; 
1B00:  MOVLW  01
1B02:  MOVWF  23
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n",pasajet,entran1,cta_bloqueo,error); 
1B04:  MOVLW  4A
1B06:  MOVWF  FF6
1B08:  MOVLW  03
1B0A:  MOVWF  FF7
1B0C:  MOVLW  07
1B0E:  MOVLB  1
1B10:  MOVWF  xCC
1B12:  MOVLB  0
1B14:  RCALL  1910
1B16:  MOVLW  09
1B18:  MOVWF  FE9
1B1A:  MOVFF  91,1CD
1B1E:  MOVFF  90,1CC
1B22:  RCALL  1938
1B24:  MOVLW  2C
1B26:  MOVLB  1
1B28:  MOVWF  xD5
1B2A:  MOVLB  0
1B2C:  CALL   11AC
1B30:  MOVLW  09
1B32:  MOVWF  FE9
1B34:  MOVFF  39,1CD
1B38:  MOVFF  38,1CC
1B3C:  RCALL  1938
1B3E:  MOVLW  5C
1B40:  MOVWF  FF6
1B42:  MOVLW  03
1B44:  MOVWF  FF7
1B46:  MOVLW  06
1B48:  MOVLB  1
1B4A:  MOVWF  xCC
1B4C:  MOVLB  0
1B4E:  RCALL  1910
1B50:  MOVLW  0A
1B52:  MOVWF  FE9
1B54:  MOVFF  4D,1CD
1B58:  MOVFF  4C,1CC
1B5C:  RCALL  1938
1B5E:  MOVLW  67
1B60:  MOVWF  FF6
1B62:  MOVLW  03
1B64:  MOVWF  FF7
1B66:  MOVLW  05
1B68:  MOVLB  1
1B6A:  MOVWF  xCC
1B6C:  MOVLB  0
1B6E:  RCALL  1910
1B70:  MOVFF  23,1CC
1B74:  MOVLW  01
1B76:  MOVLB  1
1B78:  MOVWF  xCD
1B7A:  MOVLB  0
1B7C:  RCALL  19FE
1B7E:  MOVLW  70
1B80:  MOVWF  FF6
1B82:  MOVLW  03
1B84:  MOVWF  FF7
1B86:  MOVLW  03
1B88:  MOVLB  1
1B8A:  MOVWF  xCC
1B8C:  MOVLB  0
1B8E:  RCALL  1910
.................... //!   lcd_gotoxy(1,4); 
.................... //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1B90:  MOVLW  09
1B92:  MOVLB  1
1B94:  MOVWF  xD7
1B96:  MOVLW  03
1B98:  MOVWF  xD8
1B9A:  MOVLB  0
1B9C:  CALL   0852
....................    lcd_putc(0xAB); 
1BA0:  MOVLW  AB
1BA2:  MOVLB  1
1BA4:  MOVWF  xD6
1BA6:  MOVLB  0
1BA8:  CALL   08A4
....................    lcd_gotoxy(9,4);//cronometro para limpiar 
1BAC:  MOVLW  09
1BAE:  MOVLB  1
1BB0:  MOVWF  xD7
1BB2:  MOVLW  04
1BB4:  MOVWF  xD8
1BB6:  MOVLB  0
1BB8:  CALL   0852
....................    lcd_putc("DESC"); 
1BBC:  MOVLW  74
1BBE:  MOVWF  FF6
1BC0:  MOVLW  03
1BC2:  MOVWF  FF7
1BC4:  CALL   0A28
....................    clear_lcd1=1; 
1BC8:  MOVLW  01
1BCA:  MOVWF  xAB
....................    time_lcd1=0; 
1BCC:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1BCE:  CLRF   xAA
1BD0:  CLRF   xA9
....................    flag_enviar=0; 
1BD2:  CLRF   46
....................    enable_interrupts(INT_RDA); 
1BD4:  BSF    F9D.5
1BD6:  GOTO   34F2 (RETURN)
.................... } 
....................  
.................... void limpiar(){//borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront=0; 
*
0D00:  CLRF   x93
0D02:  CLRF   x92
....................    tem_salieront=0; 
0D04:  CLRF   x95
0D06:  CLRF   x94
....................    salian=0; 
0D08:  CLRF   3D
0D0A:  CLRF   3C
....................    graba_conta2(); 
0D0C:  RCALL  069E
....................    leer_conta2(); 
0D0E:  RCALL  0800
....................    pasaje=0; 
0D10:  CLRF   x8F
0D12:  CLRF   x8E
....................    pasajet=0; 
0D14:  CLRF   x91
0D16:  CLRF   x90
....................    salieront=0; 
0D18:  CLRF   x8D
0D1A:  CLRF   x8C
....................    entraront=0; 
0D1C:  CLRF   x8B
0D1E:  CLRF   x8A
....................    write_ent(); 
0D20:  RCALL  0C94
....................    write_sal(); 
0D22:  RCALL  0CCA
....................    cta_bloqueo=0; 
0D24:  CLRF   4D
0D26:  CLRF   4C
....................    cta_bloq1=0; 
0D28:  CLRF   52
....................    cta_bloq2=0; 
0D2A:  CLRF   53
....................    cta_bloq3=0; 
0D2C:  CLRF   54
....................    write_ext_eeprom(9,cta_bloq1);//bloq1 
0D2E:  MOVLB  1
0D30:  CLRF   xD1
0D32:  MOVLW  09
0D34:  MOVWF  xD0
0D36:  MOVFF  52,1D2
0D3A:  MOVLB  0
0D3C:  RCALL  0598
....................    write_ext_eeprom(10,cta_bloq2);//bloq2 
0D3E:  MOVLB  1
0D40:  CLRF   xD1
0D42:  MOVLW  0A
0D44:  MOVWF  xD0
0D46:  MOVFF  53,1D2
0D4A:  MOVLB  0
0D4C:  RCALL  0598
....................    write_ext_eeprom(11,cta_bloq3);//bloq3 
0D4E:  MOVLB  1
0D50:  CLRF   xD1
0D52:  MOVLW  0B
0D54:  MOVWF  xD0
0D56:  MOVFF  54,1D2
0D5A:  MOVLB  0
0D5C:  RCALL  0598
....................    lcd_putc("\f"); 
0D5E:  MOVLW  7A
0D60:  MOVWF  FF6
0D62:  MOVLW  03
0D64:  MOVWF  FF7
0D66:  RCALL  0A28
....................    lcd_cuentas(); 
0D68:  RCALL  0A48
0D6A:  RETURN 0
.................... } 
....................  
.................... void detecta_suma(){//Realiza suma de entradas o salidas 
....................     if( (!detec1)&&(!detec2)&&(!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){//suma sin bloqueos 
*
22E6:  MOVF   x69,F
22E8:  BNZ   2354
22EA:  MOVF   x6A,F
22EC:  BNZ   2354
22EE:  MOVF   x6B,F
22F0:  BNZ   2354
22F2:  MOVF   x6C,F
22F4:  BNZ   2354
22F6:  MOVF   x6D,F
22F8:  BNZ   2354
22FA:  MOVF   x6E,F
22FC:  BNZ   2354
....................       sumae1=fse1+fse2+fse3; 
22FE:  MOVF   29,W
2300:  ADDWF  28,W
2302:  ADDWF  2A,W
2304:  MOVWF  25
....................       sumas1=fss1+fss2+fss3; 
2306:  MOVF   2C,W
2308:  ADDWF  2B,W
230A:  ADDWF  2D,W
230C:  MOVWF  26
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if( (sumae1>=2)||(sumas1>=2) ){ 
230E:  MOVF   25,W
2310:  SUBLW  01
2312:  BNC   231A
2314:  MOVF   26,W
2316:  SUBLW  01
2318:  BC    2336
....................          if(sumae1>sumas1) { 
231A:  MOVF   25,W
231C:  SUBWF  26,W
231E:  BC    232C
....................             entraront++; 
2320:  INCF   x8A,F
2322:  BTFSC  FD8.2
2324:  INCF   x8B,F
....................             write_ent(); 
2326:  CALL   0C94
....................          } 
232A:  BRA    2336
....................          else{ 
....................             salieront++; 
232C:  INCF   x8C,F
232E:  BTFSC  FD8.2
2330:  INCF   x8D,F
....................             write_sal(); 
2332:  CALL   0CCA
....................          } 
....................       } 
....................       sumae1=fse1=fse2=fse3=0; 
2336:  CLRF   2A
2338:  MOVFF  2A,29
233C:  MOVFF  29,28
2340:  MOVFF  28,25
....................       sumas1=fss1=fss2=fss3=0; 
2344:  CLRF   2D
2346:  MOVFF  2D,2C
234A:  MOVFF  2C,2B
234E:  MOVFF  2B,26
....................       //envio_PC(); 
....................    }//fin suma sin bloqueos 
2352:  BRA    2452
....................    else if( (en_b1)||(en_b2)||(en_b3) ){//contar con bloqueos 
2354:  MOVF   x9E,F
2356:  BNZ   2362
2358:  MOVF   x9F,F
235A:  BNZ   2362
235C:  MOVF   xA0,F
235E:  BTFSC  FD8.2
2360:  BRA    2452
....................             lim_b= en_b1+ en_b2+ en_b3; 
2362:  MOVF   x9F,W
2364:  ADDWF  x9E,W
2366:  ADDWF  xA0,W
2368:  MOVWF  27
.................... //!            lcd_gotoxy(9,2);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"lim_b:%u ",lim_b);//habilitar unicamente para hacer diagnosticos 
.................... //!            lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................              
....................             if(lim_b==1){//un solo bloqueo 
236A:  DECFSZ 27,W
236C:  BRA    23FE
....................                if(en_b1){ 
236E:  MOVF   x9E,F
2370:  BZ    239E
....................                   if( (!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){ 
2372:  MOVF   x6B,F
2374:  BNZ   239C
2376:  MOVF   x6C,F
2378:  BNZ   239C
237A:  MOVF   x6D,F
237C:  BNZ   239C
237E:  MOVF   x6E,F
2380:  BNZ   239C
....................                      if(sen_ent==1){ 
2382:  DECFSZ 5B,W
2384:  BRA    2392
....................                         entraront++; 
2386:  INCF   x8A,F
2388:  BTFSC  FD8.2
238A:  INCF   x8B,F
....................                         write_ent(); 
238C:  CALL   0C94
....................                      } 
2390:  BRA    239C
....................                      else{ 
....................                         salieront++; 
2392:  INCF   x8C,F
2394:  BTFSC  FD8.2
2396:  INCF   x8D,F
....................                         write_sal(); 
2398:  CALL   0CCA
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin bloqueo par 1 
239C:  BRA    23FC
....................                else if(en_b2){//bloqueo en par 2 
239E:  MOVF   x9F,F
23A0:  BZ    23CE
....................                   if( (!detec1)&&(!detec2)&&(!detec5)&&(!detec6) ){ 
23A2:  MOVF   x69,F
23A4:  BNZ   23CC
23A6:  MOVF   x6A,F
23A8:  BNZ   23CC
23AA:  MOVF   x6D,F
23AC:  BNZ   23CC
23AE:  MOVF   x6E,F
23B0:  BNZ   23CC
....................                      if(sen_ent){ 
23B2:  MOVF   5B,F
23B4:  BZ    23C2
....................                         entraront++; 
23B6:  INCF   x8A,F
23B8:  BTFSC  FD8.2
23BA:  INCF   x8B,F
....................                         write_ent(); 
23BC:  CALL   0C94
....................                      } 
23C0:  BRA    23CC
....................                      else{ 
....................                         salieront++; 
23C2:  INCF   x8C,F
23C4:  BTFSC  FD8.2
23C6:  INCF   x8D,F
....................                         write_sal(); 
23C8:  CALL   0CCA
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin par 2 
23CC:  BRA    23FC
....................                else if(en_b3){//bloqueao en par 3 
23CE:  MOVF   xA0,F
23D0:  BZ    23FC
....................                   if( (!detec3)&&(!detec4)&&(!detec1)&&(!detec2) ){ 
23D2:  MOVF   x6B,F
23D4:  BNZ   23FC
23D6:  MOVF   x6C,F
23D8:  BNZ   23FC
23DA:  MOVF   x69,F
23DC:  BNZ   23FC
23DE:  MOVF   x6A,F
23E0:  BNZ   23FC
....................                      if(sen_ent){ 
23E2:  MOVF   5B,F
23E4:  BZ    23F2
....................                         entraront++; 
23E6:  INCF   x8A,F
23E8:  BTFSC  FD8.2
23EA:  INCF   x8B,F
....................                         write_ent(); 
23EC:  CALL   0C94
....................                      } 
23F0:  BRA    23FC
....................                      else{ 
....................                         salieront++; 
23F2:  INCF   x8C,F
23F4:  BTFSC  FD8.2
23F6:  INCF   x8D,F
....................                         write_sal(); 
23F8:  CALL   0CCA
....................                      } 
....................                   } 
....................                }//fin par 3 
....................             }//fin un solo bloqueo 
23FC:  BRA    2436
.................... //----------------------------------------------------------------------------- 
....................             else{//mas de un bloqueo 
....................                sumae1=fse1+fse2+fse3; 
23FE:  MOVF   29,W
2400:  ADDWF  28,W
2402:  ADDWF  2A,W
2404:  MOVWF  25
....................                sumas1=fss1+fss2+fss3; 
2406:  MOVF   2C,W
2408:  ADDWF  2B,W
240A:  ADDWF  2D,W
240C:  MOVWF  26
....................                //lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................                //printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................                if( (sumae1>=1)||(sumas1>=1) ){ 
240E:  MOVF   25,W
2410:  SUBLW  00
2412:  BNC   241A
2414:  MOVF   26,W
2416:  SUBLW  00
2418:  BC    2436
....................                   if(sumae1>sumas1) { 
241A:  MOVF   25,W
241C:  SUBWF  26,W
241E:  BC    242C
....................                      entraront++; 
2420:  INCF   x8A,F
2422:  BTFSC  FD8.2
2424:  INCF   x8B,F
....................                      write_ent(); 
2426:  CALL   0C94
....................                   } 
242A:  BRA    2436
....................                   else{ 
....................                      salieront++; 
242C:  INCF   x8C,F
242E:  BTFSC  FD8.2
2430:  INCF   x8D,F
....................                      write_sal(); 
2432:  CALL   0CCA
....................                   } 
....................                } 
....................             }//fin mas de un bloqueo 
....................                sumae1=fse1=fse2=fse3=0; 
2436:  CLRF   2A
2438:  MOVFF  2A,29
243C:  MOVFF  29,28
2440:  MOVFF  28,25
....................                sumas1=fss1=fss2=fss3=0; 
2444:  CLRF   2D
2446:  MOVFF  2D,2C
244A:  MOVFF  2C,2B
244E:  MOVFF  2B,26
.................... //----------------------------------------------------------------------------- 
....................    }//end bloqueos 
2452:  RETURN 0
.................... } 
....................  
.................... void finsuma(){//Pinta en LCD la nueva cifra de entrada o salida 
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................       pasaje=(entraront+salieront)/2; 
*
0C56:  MOVF   x8C,W
0C58:  ADDWF  x8A,W
0C5A:  MOVLB  1
0C5C:  MOVWF  xCC
0C5E:  MOVLB  0
0C60:  MOVF   x8D,W
0C62:  ADDWFC x8B,W
0C64:  MOVLB  1
0C66:  MOVWF  xCD
0C68:  BCF    FD8.0
0C6A:  RRCF   xCD,W
0C6C:  MOVLB  0
0C6E:  MOVWF  x8F
0C70:  MOVLB  1
0C72:  RRCF   xCC,W
0C74:  MOVLB  0
0C76:  MOVWF  x8E
....................       lcd_cuentas(); 
0C78:  RCALL  0A48
....................       sen_ent=0; 
0C7A:  CLRF   5B
....................       sen_sal=0; 
0C7C:  CLRF   5C
....................       fse1=fse2=fse3=0; 
0C7E:  CLRF   2A
0C80:  MOVFF  2A,29
0C84:  MOVFF  29,28
....................       fss1=fss2=fss3=0; 
0C88:  CLRF   2D
0C8A:  MOVFF  2D,2C
0C8E:  MOVFF  2C,2B
0C92:  RETURN 0
.................... } 
....................  
.................... void contando1(){//Revisa maquina de estados para par 1 
....................    if(entra_temp1!=edo1) { 
*
2454:  MOVF   x76,W
2456:  SUBWF  x7B,W
2458:  BZ    2462
....................       entra_temp1=edo1; 
245A:  MOVFF  76,7B
....................       enable1=1; 
245E:  MOVLW  01
2460:  MOVWF  x7A
....................    } 
....................    if (enable1==1){ 
2462:  DECFSZ x7A,W
2464:  BRA    24A2
....................          switch (edo1) { 
2466:  MOVLW  01
2468:  SUBWF  x76,W
246A:  ADDLW  F4
246C:  BC    249E
246E:  ADDLW  0C
2470:  GOTO   24A4
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
2474:  BRA    249E
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss1) fse1=1;//si no ha salido antes 
2476:  MOVF   2B,F
2478:  BNZ   2480
247A:  MOVLW  01
247C:  MOVWF  28
247E:  BRA    2482
....................                      else fss1=0; 
2480:  CLRF   2B
....................                      detecta_suma(); 
2482:  RCALL  22E6
....................                      break;} 
2484:  BRA    249E
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
2486:  RCALL  22E6
....................                      break;} 
2488:  BRA    249E
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
248A:  BRA    249E
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse1) fss1=1;//si no ha entrado antes 
248C:  MOVF   28,F
248E:  BNZ   2496
2490:  MOVLW  01
2492:  MOVWF  2B
2494:  BRA    2498
....................                      else fse1=0; 
2496:  CLRF   28
....................                      detecta_suma(); 
2498:  RCALL  22E6
....................                      break;} 
249A:  BRA    249E
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
249C:  RCALL  22E6
....................                      break;} 
....................          } 
....................       enable1=0; 
249E:  CLRF   x7A
....................       entra_act1=0; 
24A0:  CLRF   x75
....................    } 
24A2:  RETURN 0
.................... } 
....................  
.................... void contando2(){//Revisa maquina de estados para par 2 
....................    if(entra_temp2!=edo2) { 
*
275C:  MOVF   x7D,W
275E:  SUBWF  x82,W
2760:  BZ    276A
....................       entra_temp2=edo2; 
2762:  MOVFF  7D,82
....................       enable2=1; 
2766:  MOVLW  01
2768:  MOVWF  x81
....................    } 
....................    if (enable2==1){ 
276A:  DECFSZ x81,W
276C:  BRA    27AA
....................          switch (edo2) { 
276E:  MOVLW  01
2770:  SUBWF  x7D,W
2772:  ADDLW  F4
2774:  BC    27A6
2776:  ADDLW  0C
2778:  GOTO   27AC
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
277C:  BRA    27A6
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss2) fse2=1; 
277E:  MOVF   2C,F
2780:  BNZ   2788
2782:  MOVLW  01
2784:  MOVWF  29
2786:  BRA    278A
....................                      else fss2=0; 
2788:  CLRF   2C
....................                      detecta_suma(); 
278A:  RCALL  22E6
....................                      break;} 
278C:  BRA    27A6
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
278E:  RCALL  22E6
....................                      break;} 
2790:  BRA    27A6
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
2792:  BRA    27A6
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse2) fss2=1; 
2794:  MOVF   29,F
2796:  BNZ   279E
2798:  MOVLW  01
279A:  MOVWF  2C
279C:  BRA    27A0
....................                      else fse2=0; 
279E:  CLRF   29
....................                      detecta_suma(); 
27A0:  RCALL  22E6
....................                      break;} 
27A2:  BRA    27A6
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
27A4:  RCALL  22E6
....................                      break;} 
....................          } 
....................       enable2=0; 
27A6:  CLRF   x81
....................       entra_act2=0; 
27A8:  CLRF   x7C
....................    } 
27AA:  RETURN 0
.................... } 
....................  
.................... void contando3(){//Revisa maquina de estados para par 3 
....................    if(entra_temp3!=edo3) { 
*
2A66:  MOVF   x84,W
2A68:  SUBWF  x89,W
2A6A:  BZ    2A74
....................       entra_temp3=edo3; 
2A6C:  MOVFF  84,89
....................       enable3=1; 
2A70:  MOVLW  01
2A72:  MOVWF  x88
....................    } 
....................    if (enable3==1){ 
2A74:  DECFSZ x88,W
2A76:  BRA    2AB4
....................          switch (edo3) { 
2A78:  MOVLW  01
2A7A:  SUBWF  x84,W
2A7C:  ADDLW  F4
2A7E:  BC    2AB0
2A80:  ADDLW  0C
2A82:  GOTO   2AB6
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
2A86:  BRA    2AB0
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss3) fse3=1; 
2A88:  MOVF   2D,F
2A8A:  BNZ   2A92
2A8C:  MOVLW  01
2A8E:  MOVWF  2A
2A90:  BRA    2A94
....................                      else fss3=0; 
2A92:  CLRF   2D
....................                      detecta_suma(); 
2A94:  RCALL  22E6
....................                      break;} 
2A96:  BRA    2AB0
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
2A98:  RCALL  22E6
....................                      break;} 
2A9A:  BRA    2AB0
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
2A9C:  BRA    2AB0
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse3) fss3=1; 
2A9E:  MOVF   2A,F
2AA0:  BNZ   2AA8
2AA2:  MOVLW  01
2AA4:  MOVWF  2D
2AA6:  BRA    2AAA
....................                      else fse3=0; 
2AA8:  CLRF   2A
....................                      detecta_suma(); 
2AAA:  RCALL  22E6
....................                      break;} 
2AAC:  BRA    2AB0
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
2AAE:  RCALL  22E6
....................                      break;} 
....................          } 
....................       enable3=0; 
2AB0:  CLRF   x88
....................       entra_act3=0; 
2AB2:  CLRF   x83
....................    } 
2AB4:  RETURN 0
.................... } 
....................  
.................... void sensando1(){//Define estados para la maquina de estados del par 1 
.................... /////normal/////// 
.................... if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==0)){//LLEGA PERSONA EN ENTRADA1 
*
2060:  MOVF   x75,F
2062:  BNZ   20A8
2064:  DECFSZ x69,W
2066:  BRA    20A8
2068:  MOVF   x6A,F
206A:  BNZ   20A8
206C:  MOVF   x77,F
206E:  BNZ   20A8
2070:  MOVF   x78,F
2072:  BNZ   20A8
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2074:  MOVF   5B,F
2076:  BNZ   207E
2078:  MOVF   5C,F
207A:  BTFSC  FD8.2
207C:  RCALL  2016
....................    lcd_gotoxy(8,2); 
207E:  MOVLW  08
2080:  MOVLB  1
2082:  MOVWF  xD7
2084:  MOVLW  02
2086:  MOVWF  xD8
2088:  MOVLB  0
208A:  CALL   0852
....................    lcd_putc(0x7F);//flecha del sentido 
208E:  MOVLW  7F
2090:  MOVLB  1
2092:  MOVWF  xD6
2094:  MOVLB  0
2096:  CALL   08A4
....................    des1=1; 
209A:  MOVLW  01
209C:  MOVWF  x98
....................    //// 
....................    edo1=1; 
209E:  MOVWF  x76
....................    entra1=1; 
20A0:  MOVWF  x77
....................    edoa1=1; 
20A2:  MOVWF  x79
....................    entra_act1=1;} 
20A4:  MOVWF  x75
20A6:  BRA    22E4
.................... ///prioridad 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA ENTRANDO 
20A8:  MOVF   x75,F
20AA:  BNZ   20C8
20AC:  DECFSZ x69,W
20AE:  BRA    20C8
20B0:  DECFSZ x6A,W
20B2:  BRA    20C8
20B4:  DECFSZ x77,W
20B6:  BRA    20C8
20B8:  MOVF   x78,F
20BA:  BNZ   20C8
....................    edo1=3; 
20BC:  MOVLW  03
20BE:  MOVWF  x76
....................    edoa1=0; 
20C0:  CLRF   x79
....................    entra_act1=1;} 
20C2:  MOVLW  01
20C4:  MOVWF  x75
20C6:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA CASI TERMINA DE ENTRAR 
20C8:  MOVF   x75,F
20CA:  BNZ   20E6
20CC:  MOVF   x69,F
20CE:  BNZ   20E6
20D0:  DECFSZ x6A,W
20D2:  BRA    20E6
20D4:  DECFSZ x77,W
20D6:  BRA    20E6
20D8:  MOVF   x78,F
20DA:  BNZ   20E6
....................    edo1=4; 
20DC:  MOVLW  04
20DE:  MOVWF  x76
....................    entra_act1=1;} 
20E0:  MOVLW  01
20E2:  MOVWF  x75
20E4:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==1)&&(sale1==0)){//PERSONA A ENTRADO 
20E6:  MOVF   x75,F
20E8:  BNZ   213E
20EA:  MOVF   x69,F
20EC:  BNZ   213E
20EE:  MOVF   x6A,F
20F0:  BNZ   213E
20F2:  MOVF   x79,F
20F4:  BNZ   213E
20F6:  DECFSZ x77,W
20F8:  BRA    213E
20FA:  MOVF   x78,F
20FC:  BNZ   213E
....................    lcd_gotoxy(8,2); 
20FE:  MOVLW  08
2100:  MOVLB  1
2102:  MOVWF  xD7
2104:  MOVLW  02
2106:  MOVWF  xD8
2108:  MOVLB  0
210A:  CALL   0852
....................    lcd_putc(" "); 
210E:  MOVLW  7C
2110:  MOVWF  FF6
2112:  MOVLW  03
2114:  MOVWF  FF7
2116:  CALL   0A28
....................    des1=0; 
211A:  CLRF   x98
....................    if(entra_temp1==4){ 
211C:  MOVF   x7B,W
211E:  SUBLW  04
2120:  BNZ   212E
....................       edo1=5; 
2122:  MOVLW  05
2124:  MOVWF  x76
....................       entra1=0; 
2126:  CLRF   x77
....................       entra_act1=1; 
2128:  MOVLW  01
212A:  MOVWF  x75
....................    } 
212C:  BRA    213C
....................    else {//entraba y se regresa 
....................       des1=0; 
212E:  CLRF   x98
....................       edo1=6; 
2130:  MOVLW  06
2132:  MOVWF  x76
....................       entra1=0; 
2134:  CLRF   x77
....................       edoa1=0; 
2136:  CLRF   x79
....................       entra_act1=1;   
2138:  MOVLW  01
213A:  MOVWF  x75
....................    } 
.................... } 
213C:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==1)&&(sale1==0)){//entraba y se regresa 
213E:  MOVF   x75,F
2140:  BNZ   2182
2142:  MOVF   x69,F
2144:  BNZ   2182
2146:  MOVF   x6A,F
2148:  BNZ   2182
214A:  DECFSZ x79,W
214C:  BRA    2182
214E:  DECFSZ x77,W
2150:  BRA    2182
2152:  MOVF   x78,F
2154:  BNZ   2182
....................    lcd_gotoxy(8,2); 
2156:  MOVLW  08
2158:  MOVLB  1
215A:  MOVWF  xD7
215C:  MOVLW  02
215E:  MOVWF  xD8
2160:  MOVLB  0
2162:  CALL   0852
....................    lcd_putc(" "); 
2166:  MOVLW  7E
2168:  MOVWF  FF6
216A:  MOVLW  03
216C:  MOVWF  FF7
216E:  CALL   0A28
....................    des1=0; 
2172:  CLRF   x98
....................    edo1=6; 
2174:  MOVLW  06
2176:  MOVWF  x76
....................    entra1=0; 
2178:  CLRF   x77
....................    edoa1=0; 
217A:  CLRF   x79
....................    entra_act1=1;} 
217C:  MOVLW  01
217E:  MOVWF  x75
2180:  BRA    22E4
.................... ///// 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==1)&&(sale1==0)){ 
2182:  MOVF   x75,F
2184:  BNZ   21A2
2186:  DECFSZ x69,W
2188:  BRA    21A2
218A:  MOVF   x6A,F
218C:  BNZ   21A2
218E:  DECFSZ x77,W
2190:  BRA    21A2
2192:  MOVF   x78,F
2194:  BNZ   21A2
....................    edo1=2; 
2196:  MOVLW  02
2198:  MOVWF  x76
....................    edoa1=1; 
219A:  MOVLW  01
219C:  MOVWF  x79
....................    entra_act1=1;}//checar prioridad 
219E:  MOVWF  x75
21A0:  BRA    22E4
.................... //////sentido inverso/// 
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
21A2:  MOVF   x75,F
21A4:  BNZ   21EC
21A6:  MOVF   x69,F
21A8:  BNZ   21EC
21AA:  DECFSZ x6A,W
21AC:  BRA    21EC
21AE:  MOVF   x77,F
21B0:  BNZ   21EC
21B2:  MOVF   x78,F
21B4:  BNZ   21EC
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
21B6:  MOVF   5B,F
21B8:  BNZ   21C0
21BA:  MOVF   5C,F
21BC:  BTFSC  FD8.2
21BE:  RCALL  2016
....................    lcd_gotoxy(8,2); 
21C0:  MOVLW  08
21C2:  MOVLB  1
21C4:  MOVWF  xD7
21C6:  MOVLW  02
21C8:  MOVWF  xD8
21CA:  MOVLB  0
21CC:  CALL   0852
....................    lcd_putc(0x7E);//flecha del sentido 
21D0:  MOVLW  7E
21D2:  MOVLB  1
21D4:  MOVWF  xD6
21D6:  MOVLB  0
21D8:  CALL   08A4
....................    des1=1; 
21DC:  MOVLW  01
21DE:  MOVWF  x98
....................    edo1=7; 
21E0:  MOVLW  07
21E2:  MOVWF  x76
....................    sale1=1; 
21E4:  MOVLW  01
21E6:  MOVWF  x78
....................    entra_act1=1;} 
21E8:  MOVWF  x75
21EA:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 1 
21EC:  MOVF   x75,F
21EE:  BNZ   220C
21F0:  MOVF   x69,F
21F2:  BNZ   220C
21F4:  DECFSZ x6A,W
21F6:  BRA    220C
21F8:  MOVF   x77,F
21FA:  BNZ   220C
21FC:  DECFSZ x78,W
21FE:  BRA    220C
....................    edo1=8; 
2200:  MOVLW  08
2202:  MOVWF  x76
....................    edoa1=1; 
2204:  MOVLW  01
2206:  MOVWF  x79
....................    entra_act1=1;} 
2208:  MOVWF  x75
220A:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 2 
220C:  MOVF   x75,F
220E:  BNZ   222C
2210:  DECFSZ x69,W
2212:  BRA    222C
2214:  DECFSZ x6A,W
2216:  BRA    222C
2218:  MOVF   x77,F
221A:  BNZ   222C
221C:  DECFSZ x78,W
221E:  BRA    222C
....................    edo1=9; 
2220:  MOVLW  09
2222:  MOVWF  x76
....................    edoa1=0; 
2224:  CLRF   x79
....................    entra_act1=1;} 
2226:  MOVLW  01
2228:  MOVWF  x75
222A:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==1)){//CASI TERMINA DE SALIR 
222C:  MOVF   x75,F
222E:  BNZ   224A
2230:  DECFSZ x69,W
2232:  BRA    224A
2234:  MOVF   x6A,F
2236:  BNZ   224A
2238:  MOVF   x77,F
223A:  BNZ   224A
223C:  DECFSZ x78,W
223E:  BRA    224A
....................    edo1=10; 
2240:  MOVLW  0A
2242:  MOVWF  x76
....................    entra_act1=1;} 
2244:  MOVLW  01
2246:  MOVWF  x75
2248:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==0)&&(sale1==1)){//PERSONA A SALIDO POR ENTRADA 
224A:  MOVF   x75,F
224C:  BNZ   22A2
224E:  MOVF   x69,F
2250:  BNZ   22A2
2252:  MOVF   x6A,F
2254:  BNZ   22A2
2256:  MOVF   x79,F
2258:  BNZ   22A2
225A:  MOVF   x77,F
225C:  BNZ   22A2
225E:  DECFSZ x78,W
2260:  BRA    22A2
....................    lcd_gotoxy(8,2); 
2262:  MOVLW  08
2264:  MOVLB  1
2266:  MOVWF  xD7
2268:  MOVLW  02
226A:  MOVWF  xD8
226C:  MOVLB  0
226E:  CALL   0852
....................    lcd_putc(" "); 
2272:  MOVLW  80
2274:  MOVWF  FF6
2276:  MOVLW  03
2278:  MOVWF  FF7
227A:  CALL   0A28
....................    if(entra_temp1==10) { 
227E:  MOVF   x7B,W
2280:  SUBLW  0A
2282:  BNZ   2292
....................       des1=0; 
2284:  CLRF   x98
....................       edo1=11; 
2286:  MOVLW  0B
2288:  MOVWF  x76
....................       sale1=0; 
228A:  CLRF   x78
....................       entra_act1=1;} 
228C:  MOVLW  01
228E:  MOVWF  x75
2290:  BRA    22A0
....................    else { 
....................       des1=0; 
2292:  CLRF   x98
....................       edo1=12; 
2294:  MOVLW  0C
2296:  MOVWF  x76
....................       sale1=0; 
2298:  CLRF   x78
....................       edoa1=0; 
229A:  CLRF   x79
....................       entra_act1=1; 
229C:  MOVLW  01
229E:  MOVWF  x75
....................    } 
.................... } 
22A0:  BRA    22E4
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==0)&&(sale1==1)){//SALIA y se regresa 
22A2:  MOVF   x75,F
22A4:  BNZ   22E4
22A6:  MOVF   x69,F
22A8:  BNZ   22E4
22AA:  MOVF   x6A,F
22AC:  BNZ   22E4
22AE:  DECFSZ x79,W
22B0:  BRA    22E4
22B2:  MOVF   x77,F
22B4:  BNZ   22E4
22B6:  DECFSZ x78,W
22B8:  BRA    22E4
....................    lcd_gotoxy(8,2); 
22BA:  MOVLW  08
22BC:  MOVLB  1
22BE:  MOVWF  xD7
22C0:  MOVLW  02
22C2:  MOVWF  xD8
22C4:  MOVLB  0
22C6:  CALL   0852
....................    lcd_putc(" "); 
22CA:  MOVLW  82
22CC:  MOVWF  FF6
22CE:  MOVLW  03
22D0:  MOVWF  FF7
22D2:  CALL   0A28
....................    des1=0; 
22D6:  CLRF   x98
....................    edo1=12; 
22D8:  MOVLW  0C
22DA:  MOVWF  x76
....................    sale1=0; 
22DC:  CLRF   x78
....................    edoa1=0; 
22DE:  CLRF   x79
....................    entra_act1=1;} 
22E0:  MOVLW  01
22E2:  MOVWF  x75
22E4:  RETURN 0
.................... } 
....................  
.................... void sensando2(){//Define estados para la maquina de estados del par 2 
.................... /////normal/////// 
.................... if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==0)){//LLEGA PERSONA EN ENTRADA1 
*
24D6:  MOVF   x7C,F
24D8:  BNZ   251E
24DA:  DECFSZ x6B,W
24DC:  BRA    251E
24DE:  MOVF   x6C,F
24E0:  BNZ   251E
24E2:  MOVF   x7E,F
24E4:  BNZ   251E
24E6:  MOVF   x7F,F
24E8:  BNZ   251E
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
24EA:  MOVF   5B,F
24EC:  BNZ   24F4
24EE:  MOVF   5C,F
24F0:  BTFSC  FD8.2
24F2:  RCALL  2016
....................    lcd_gotoxy(8,3); 
24F4:  MOVLW  08
24F6:  MOVLB  1
24F8:  MOVWF  xD7
24FA:  MOVLW  03
24FC:  MOVWF  xD8
24FE:  MOVLB  0
2500:  CALL   0852
....................    lcd_putc(0x7F); 
2504:  MOVLW  7F
2506:  MOVLB  1
2508:  MOVWF  xD6
250A:  MOVLB  0
250C:  CALL   08A4
....................    des2=1; 
2510:  MOVLW  01
2512:  MOVWF  x99
....................    edo2=1; 
2514:  MOVWF  x7D
....................    entra2=1; 
2516:  MOVWF  x7E
....................    edoa2=1; 
2518:  MOVWF  x80
....................    entra_act2=1;} 
251A:  MOVWF  x7C
251C:  BRA    275A
.................... ///prioridad 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA ENTRANDO 
251E:  MOVF   x7C,F
2520:  BNZ   253E
2522:  DECFSZ x6B,W
2524:  BRA    253E
2526:  DECFSZ x6C,W
2528:  BRA    253E
252A:  DECFSZ x7E,W
252C:  BRA    253E
252E:  MOVF   x7F,F
2530:  BNZ   253E
....................    edo2=3; 
2532:  MOVLW  03
2534:  MOVWF  x7D
....................    edoa2=0; 
2536:  CLRF   x80
....................    entra_act2=1;} 
2538:  MOVLW  01
253A:  MOVWF  x7C
253C:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA CASI TERMINA DE ENTRAR 
253E:  MOVF   x7C,F
2540:  BNZ   255C
2542:  MOVF   x6B,F
2544:  BNZ   255C
2546:  DECFSZ x6C,W
2548:  BRA    255C
254A:  DECFSZ x7E,W
254C:  BRA    255C
254E:  MOVF   x7F,F
2550:  BNZ   255C
....................    edo2=4; 
2552:  MOVLW  04
2554:  MOVWF  x7D
....................    entra_act2=1;} 
2556:  MOVLW  01
2558:  MOVWF  x7C
255A:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==1)&&(sale2==0)){//PERSONA A ENTRADO 
255C:  MOVF   x7C,F
255E:  BNZ   25B4
2560:  MOVF   x6B,F
2562:  BNZ   25B4
2564:  MOVF   x6C,F
2566:  BNZ   25B4
2568:  MOVF   x80,F
256A:  BNZ   25B4
256C:  DECFSZ x7E,W
256E:  BRA    25B4
2570:  MOVF   x7F,F
2572:  BNZ   25B4
....................    lcd_gotoxy(8,3); 
2574:  MOVLW  08
2576:  MOVLB  1
2578:  MOVWF  xD7
257A:  MOVLW  03
257C:  MOVWF  xD8
257E:  MOVLB  0
2580:  CALL   0852
....................    lcd_putc(" "); 
2584:  MOVLW  84
2586:  MOVWF  FF6
2588:  MOVLW  03
258A:  MOVWF  FF7
258C:  CALL   0A28
....................    if(entra_temp2==4){ 
2590:  MOVF   x82,W
2592:  SUBLW  04
2594:  BNZ   25A4
....................       des2=0; 
2596:  CLRF   x99
....................       edo2=5; 
2598:  MOVLW  05
259A:  MOVWF  x7D
....................       entra2=0; 
259C:  CLRF   x7E
....................       entra_act2=1;} 
259E:  MOVLW  01
25A0:  MOVWF  x7C
25A2:  BRA    25B2
....................    else{ 
....................       des2=0; 
25A4:  CLRF   x99
....................       edo2=6; 
25A6:  MOVLW  06
25A8:  MOVWF  x7D
....................       entra2=0; 
25AA:  CLRF   x7E
....................       edoa2=0; 
25AC:  CLRF   x80
....................       entra_act2=1;} 
25AE:  MOVLW  01
25B0:  MOVWF  x7C
.................... } 
25B2:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==1)&&(sale2==0)){//entraba y se regresa 
25B4:  MOVF   x7C,F
25B6:  BNZ   25F8
25B8:  MOVF   x6B,F
25BA:  BNZ   25F8
25BC:  MOVF   x6C,F
25BE:  BNZ   25F8
25C0:  DECFSZ x80,W
25C2:  BRA    25F8
25C4:  DECFSZ x7E,W
25C6:  BRA    25F8
25C8:  MOVF   x7F,F
25CA:  BNZ   25F8
....................    lcd_gotoxy(8,3); 
25CC:  MOVLW  08
25CE:  MOVLB  1
25D0:  MOVWF  xD7
25D2:  MOVLW  03
25D4:  MOVWF  xD8
25D6:  MOVLB  0
25D8:  CALL   0852
....................    lcd_putc(" "); 
25DC:  MOVLW  86
25DE:  MOVWF  FF6
25E0:  MOVLW  03
25E2:  MOVWF  FF7
25E4:  CALL   0A28
....................    des2=0; 
25E8:  CLRF   x99
....................    edo2=6; 
25EA:  MOVLW  06
25EC:  MOVWF  x7D
....................    entra2=0; 
25EE:  CLRF   x7E
....................    edoa2=0; 
25F0:  CLRF   x80
....................    entra_act2=1;} 
25F2:  MOVLW  01
25F4:  MOVWF  x7C
25F6:  BRA    275A
.................... ///// 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==1)&&(sale2==0)){ 
25F8:  MOVF   x7C,F
25FA:  BNZ   2618
25FC:  DECFSZ x6B,W
25FE:  BRA    2618
2600:  MOVF   x6C,F
2602:  BNZ   2618
2604:  DECFSZ x7E,W
2606:  BRA    2618
2608:  MOVF   x7F,F
260A:  BNZ   2618
....................    edo2=2; 
260C:  MOVLW  02
260E:  MOVWF  x7D
....................    edoa2=1; 
2610:  MOVLW  01
2612:  MOVWF  x80
....................    entra_act2=1;}//checar prioridad 
2614:  MOVWF  x7C
2616:  BRA    275A
.................... //////sentido inverso/// 
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
2618:  MOVF   x7C,F
261A:  BNZ   2662
261C:  MOVF   x6B,F
261E:  BNZ   2662
2620:  DECFSZ x6C,W
2622:  BRA    2662
2624:  MOVF   x7E,F
2626:  BNZ   2662
2628:  MOVF   x7F,F
262A:  BNZ   2662
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
262C:  MOVF   5B,F
262E:  BNZ   2636
2630:  MOVF   5C,F
2632:  BTFSC  FD8.2
2634:  RCALL  2016
....................    lcd_gotoxy(8,3); 
2636:  MOVLW  08
2638:  MOVLB  1
263A:  MOVWF  xD7
263C:  MOVLW  03
263E:  MOVWF  xD8
2640:  MOVLB  0
2642:  CALL   0852
....................    lcd_putc(0x7E);//flecha del sentido 
2646:  MOVLW  7E
2648:  MOVLB  1
264A:  MOVWF  xD6
264C:  MOVLB  0
264E:  CALL   08A4
....................    des2=1; 
2652:  MOVLW  01
2654:  MOVWF  x99
....................    edo2=7; 
2656:  MOVLW  07
2658:  MOVWF  x7D
....................    sale2=1; 
265A:  MOVLW  01
265C:  MOVWF  x7F
....................    entra_act2=1;} 
265E:  MOVWF  x7C
2660:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 1 
2662:  MOVF   x7C,F
2664:  BNZ   2682
2666:  MOVF   x6B,F
2668:  BNZ   2682
266A:  DECFSZ x6C,W
266C:  BRA    2682
266E:  MOVF   x7E,F
2670:  BNZ   2682
2672:  DECFSZ x7F,W
2674:  BRA    2682
....................    edo2=8; 
2676:  MOVLW  08
2678:  MOVWF  x7D
....................    edoa2=1; 
267A:  MOVLW  01
267C:  MOVWF  x80
....................    entra_act2=1;} 
267E:  MOVWF  x7C
2680:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 2 
2682:  MOVF   x7C,F
2684:  BNZ   26A2
2686:  DECFSZ x6B,W
2688:  BRA    26A2
268A:  DECFSZ x6C,W
268C:  BRA    26A2
268E:  MOVF   x7E,F
2690:  BNZ   26A2
2692:  DECFSZ x7F,W
2694:  BRA    26A2
....................    edo2=9; 
2696:  MOVLW  09
2698:  MOVWF  x7D
....................    edoa2=0; 
269A:  CLRF   x80
....................    entra_act2=1;} 
269C:  MOVLW  01
269E:  MOVWF  x7C
26A0:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==1)){//CASI TERMINA DE SALIR 
26A2:  MOVF   x7C,F
26A4:  BNZ   26C0
26A6:  DECFSZ x6B,W
26A8:  BRA    26C0
26AA:  MOVF   x6C,F
26AC:  BNZ   26C0
26AE:  MOVF   x7E,F
26B0:  BNZ   26C0
26B2:  DECFSZ x7F,W
26B4:  BRA    26C0
....................    edo2=10; 
26B6:  MOVLW  0A
26B8:  MOVWF  x7D
....................    entra_act2=1;} 
26BA:  MOVLW  01
26BC:  MOVWF  x7C
26BE:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==0)&&(sale2==1)){//PERSONA A SALIDO POR ENTRADA 
26C0:  MOVF   x7C,F
26C2:  BNZ   2718
26C4:  MOVF   x6B,F
26C6:  BNZ   2718
26C8:  MOVF   x6C,F
26CA:  BNZ   2718
26CC:  MOVF   x80,F
26CE:  BNZ   2718
26D0:  MOVF   x7E,F
26D2:  BNZ   2718
26D4:  DECFSZ x7F,W
26D6:  BRA    2718
....................    lcd_gotoxy(8,3); 
26D8:  MOVLW  08
26DA:  MOVLB  1
26DC:  MOVWF  xD7
26DE:  MOVLW  03
26E0:  MOVWF  xD8
26E2:  MOVLB  0
26E4:  CALL   0852
....................    lcd_putc(" "); 
26E8:  MOVLW  88
26EA:  MOVWF  FF6
26EC:  MOVLW  03
26EE:  MOVWF  FF7
26F0:  CALL   0A28
....................    if(entra_temp2==10){ 
26F4:  MOVF   x82,W
26F6:  SUBLW  0A
26F8:  BNZ   2708
....................       des2=0; 
26FA:  CLRF   x99
....................       edo2=11; 
26FC:  MOVLW  0B
26FE:  MOVWF  x7D
....................       sale2=0; 
2700:  CLRF   x7F
....................       entra_act2=1;} 
2702:  MOVLW  01
2704:  MOVWF  x7C
2706:  BRA    2716
....................    else{ 
....................       des2=0; 
2708:  CLRF   x99
....................       edo2=12; 
270A:  MOVLW  0C
270C:  MOVWF  x7D
....................       sale2=0; 
270E:  CLRF   x7F
....................       edoa2=0; 
2710:  CLRF   x80
....................       entra_act2=1;} 
2712:  MOVLW  01
2714:  MOVWF  x7C
.................... } 
2716:  BRA    275A
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==0)&&(sale2==1)){//SALIA y se regresa 
2718:  MOVF   x7C,F
271A:  BNZ   275A
271C:  MOVF   x6B,F
271E:  BNZ   275A
2720:  MOVF   x6C,F
2722:  BNZ   275A
2724:  DECFSZ x80,W
2726:  BRA    275A
2728:  MOVF   x7E,F
272A:  BNZ   275A
272C:  DECFSZ x7F,W
272E:  BRA    275A
....................    lcd_gotoxy(8,3); 
2730:  MOVLW  08
2732:  MOVLB  1
2734:  MOVWF  xD7
2736:  MOVLW  03
2738:  MOVWF  xD8
273A:  MOVLB  0
273C:  CALL   0852
....................    lcd_putc(" "); 
2740:  MOVLW  8A
2742:  MOVWF  FF6
2744:  MOVLW  03
2746:  MOVWF  FF7
2748:  CALL   0A28
....................    des2=0; 
274C:  CLRF   x99
....................    edo2=12; 
274E:  MOVLW  0C
2750:  MOVWF  x7D
....................    sale2=0; 
2752:  CLRF   x7F
....................    edoa2=0; 
2754:  CLRF   x80
....................    entra_act2=1;} 
2756:  MOVLW  01
2758:  MOVWF  x7C
275A:  RETURN 0
.................... } 
....................  
.................... void sensando3(){//Define estados para la maquina de estados del par 3 
.................... /////normal/////// 
.................... if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==0)){//LLEGA PERSONA EN ENTRADA1 
*
27DE:  MOVF   x83,F
27E0:  BNZ   2826
27E2:  DECFSZ x6D,W
27E4:  BRA    2826
27E6:  MOVF   x6E,F
27E8:  BNZ   2826
27EA:  MOVF   x85,F
27EC:  BNZ   2826
27EE:  MOVF   x86,F
27F0:  BNZ   2826
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
27F2:  MOVF   5B,F
27F4:  BNZ   27FC
27F6:  MOVF   5C,F
27F8:  BTFSC  FD8.2
27FA:  RCALL  2016
....................    lcd_gotoxy(8,4); 
27FC:  MOVLW  08
27FE:  MOVLB  1
2800:  MOVWF  xD7
2802:  MOVLW  04
2804:  MOVWF  xD8
2806:  MOVLB  0
2808:  CALL   0852
....................    lcd_putc(0x7F); 
280C:  MOVLW  7F
280E:  MOVLB  1
2810:  MOVWF  xD6
2812:  MOVLB  0
2814:  CALL   08A4
....................    des3=1; 
2818:  MOVLW  01
281A:  MOVWF  x9A
....................    edo3=1; 
281C:  MOVWF  x84
....................    entra3=1; 
281E:  MOVWF  x85
....................    edoa3=1; 
2820:  MOVWF  x87
....................    entra_act3=1;} 
2822:  MOVWF  x83
2824:  BRA    2A64
.................... ///prioridad 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA ENTRANDO 
2826:  MOVF   x83,F
2828:  BNZ   2846
282A:  DECFSZ x6D,W
282C:  BRA    2846
282E:  DECFSZ x6E,W
2830:  BRA    2846
2832:  DECFSZ x85,W
2834:  BRA    2846
2836:  MOVF   x86,F
2838:  BNZ   2846
....................    edo3=3; 
283A:  MOVLW  03
283C:  MOVWF  x84
....................    edoa3=0; 
283E:  CLRF   x87
....................    entra_act3=1;} 
2840:  MOVLW  01
2842:  MOVWF  x83
2844:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA CASI TERMINA DE ENTRAR 
2846:  MOVF   x83,F
2848:  BNZ   2864
284A:  MOVF   x6D,F
284C:  BNZ   2864
284E:  DECFSZ x6E,W
2850:  BRA    2864
2852:  DECFSZ x85,W
2854:  BRA    2864
2856:  MOVF   x86,F
2858:  BNZ   2864
....................    edo3=4; 
285A:  MOVLW  04
285C:  MOVWF  x84
....................    entra_act3=1;} 
285E:  MOVLW  01
2860:  MOVWF  x83
2862:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==1)&&(sale3==0)){//PERSONA A ENTRADO 
2864:  MOVF   x83,F
2866:  BNZ   28BC
2868:  MOVF   x6D,F
286A:  BNZ   28BC
286C:  MOVF   x6E,F
286E:  BNZ   28BC
2870:  MOVF   x87,F
2872:  BNZ   28BC
2874:  DECFSZ x85,W
2876:  BRA    28BC
2878:  MOVF   x86,F
287A:  BNZ   28BC
....................    lcd_gotoxy(8,4); 
287C:  MOVLW  08
287E:  MOVLB  1
2880:  MOVWF  xD7
2882:  MOVLW  04
2884:  MOVWF  xD8
2886:  MOVLB  0
2888:  CALL   0852
....................    lcd_putc(" "); 
288C:  MOVLW  8C
288E:  MOVWF  FF6
2890:  MOVLW  03
2892:  MOVWF  FF7
2894:  CALL   0A28
....................    if(entra_temp3==4){ 
2898:  MOVF   x89,W
289A:  SUBLW  04
289C:  BNZ   28AC
....................       des3=0; 
289E:  CLRF   x9A
....................       edo3=5; 
28A0:  MOVLW  05
28A2:  MOVWF  x84
....................       entra3=0; 
28A4:  CLRF   x85
....................       entra_act3=1;} 
28A6:  MOVLW  01
28A8:  MOVWF  x83
28AA:  BRA    28BA
....................    else{ 
....................       des3=0; 
28AC:  CLRF   x9A
....................       edo3=6; 
28AE:  MOVLW  06
28B0:  MOVWF  x84
....................       entra3=0; 
28B2:  CLRF   x85
....................       edoa3=0; 
28B4:  CLRF   x87
....................       entra_act3=1;} 
28B6:  MOVLW  01
28B8:  MOVWF  x83
.................... } 
28BA:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==1)&&(sale3==0)){//entraba y se regresa 
28BC:  MOVF   x83,F
28BE:  BNZ   2900
28C0:  MOVF   x6D,F
28C2:  BNZ   2900
28C4:  MOVF   x6E,F
28C6:  BNZ   2900
28C8:  DECFSZ x87,W
28CA:  BRA    2900
28CC:  DECFSZ x85,W
28CE:  BRA    2900
28D0:  MOVF   x86,F
28D2:  BNZ   2900
....................    lcd_gotoxy(8,4); 
28D4:  MOVLW  08
28D6:  MOVLB  1
28D8:  MOVWF  xD7
28DA:  MOVLW  04
28DC:  MOVWF  xD8
28DE:  MOVLB  0
28E0:  CALL   0852
....................    lcd_putc(" "); 
28E4:  MOVLW  8E
28E6:  MOVWF  FF6
28E8:  MOVLW  03
28EA:  MOVWF  FF7
28EC:  CALL   0A28
....................    des3=0; 
28F0:  CLRF   x9A
....................    edo3=6; 
28F2:  MOVLW  06
28F4:  MOVWF  x84
....................    entra3=0; 
28F6:  CLRF   x85
....................    edoa3=0; 
28F8:  CLRF   x87
....................    entra_act3=1;} 
28FA:  MOVLW  01
28FC:  MOVWF  x83
28FE:  BRA    2A64
.................... ///// 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==1)&&(sale3==0)){ 
2900:  MOVF   x83,F
2902:  BNZ   2920
2904:  DECFSZ x6D,W
2906:  BRA    2920
2908:  MOVF   x6E,F
290A:  BNZ   2920
290C:  DECFSZ x85,W
290E:  BRA    2920
2910:  MOVF   x86,F
2912:  BNZ   2920
....................    //sentidos(); 
....................    edo3=2; 
2914:  MOVLW  02
2916:  MOVWF  x84
....................    edoa3=1; 
2918:  MOVLW  01
291A:  MOVWF  x87
....................    entra_act3=1;}//checar prioridad 
291C:  MOVWF  x83
291E:  BRA    2A64
.................... //////sentido inverso/// 
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
2920:  MOVF   x83,F
2922:  BNZ   296C
2924:  MOVF   x6D,F
2926:  BNZ   296C
2928:  DECFSZ x6E,W
292A:  BRA    296C
292C:  MOVF   x85,F
292E:  BNZ   296C
2930:  MOVF   x86,F
2932:  BNZ   296C
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2934:  MOVF   5B,F
2936:  BNZ   2940
2938:  MOVF   5C,F
293A:  BTFSC  FD8.2
293C:  CALL   2016
....................    lcd_gotoxy(8,4); 
2940:  MOVLW  08
2942:  MOVLB  1
2944:  MOVWF  xD7
2946:  MOVLW  04
2948:  MOVWF  xD8
294A:  MOVLB  0
294C:  CALL   0852
....................    lcd_putc(0x7E);//flecha del sentido 
2950:  MOVLW  7E
2952:  MOVLB  1
2954:  MOVWF  xD6
2956:  MOVLB  0
2958:  CALL   08A4
....................    des3=1; 
295C:  MOVLW  01
295E:  MOVWF  x9A
....................    edo3=7; 
2960:  MOVLW  07
2962:  MOVWF  x84
....................    sale3=1; 
2964:  MOVLW  01
2966:  MOVWF  x86
....................    entra_act3=1;} 
2968:  MOVWF  x83
296A:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 1 
296C:  MOVF   x83,F
296E:  BNZ   298C
2970:  MOVF   x6D,F
2972:  BNZ   298C
2974:  DECFSZ x6E,W
2976:  BRA    298C
2978:  MOVF   x85,F
297A:  BNZ   298C
297C:  DECFSZ x86,W
297E:  BRA    298C
....................    edo3=8; 
2980:  MOVLW  08
2982:  MOVWF  x84
....................    edoa3=1; 
2984:  MOVLW  01
2986:  MOVWF  x87
....................    entra_act3=1;} 
2988:  MOVWF  x83
298A:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 2 
298C:  MOVF   x83,F
298E:  BNZ   29AC
2990:  DECFSZ x6D,W
2992:  BRA    29AC
2994:  DECFSZ x6E,W
2996:  BRA    29AC
2998:  MOVF   x85,F
299A:  BNZ   29AC
299C:  DECFSZ x86,W
299E:  BRA    29AC
....................    edo3=9; 
29A0:  MOVLW  09
29A2:  MOVWF  x84
....................    edoa3=0; 
29A4:  CLRF   x87
....................    entra_act3=1;} 
29A6:  MOVLW  01
29A8:  MOVWF  x83
29AA:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==1)){//CASI TERMINA DE SALIR 
29AC:  MOVF   x83,F
29AE:  BNZ   29CA
29B0:  DECFSZ x6D,W
29B2:  BRA    29CA
29B4:  MOVF   x6E,F
29B6:  BNZ   29CA
29B8:  MOVF   x85,F
29BA:  BNZ   29CA
29BC:  DECFSZ x86,W
29BE:  BRA    29CA
....................    edo3=10; 
29C0:  MOVLW  0A
29C2:  MOVWF  x84
....................    entra_act3=1;} 
29C4:  MOVLW  01
29C6:  MOVWF  x83
29C8:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==0)&&(sale3==1)){//PERSONA A SALIDO POR ENTRADA 
29CA:  MOVF   x83,F
29CC:  BNZ   2A22
29CE:  MOVF   x6D,F
29D0:  BNZ   2A22
29D2:  MOVF   x6E,F
29D4:  BNZ   2A22
29D6:  MOVF   x87,F
29D8:  BNZ   2A22
29DA:  MOVF   x85,F
29DC:  BNZ   2A22
29DE:  DECFSZ x86,W
29E0:  BRA    2A22
....................    lcd_gotoxy(8,4); 
29E2:  MOVLW  08
29E4:  MOVLB  1
29E6:  MOVWF  xD7
29E8:  MOVLW  04
29EA:  MOVWF  xD8
29EC:  MOVLB  0
29EE:  CALL   0852
....................    lcd_putc(" "); 
29F2:  MOVLW  90
29F4:  MOVWF  FF6
29F6:  MOVLW  03
29F8:  MOVWF  FF7
29FA:  CALL   0A28
....................    if(entra_temp3==10){ 
29FE:  MOVF   x89,W
2A00:  SUBLW  0A
2A02:  BNZ   2A12
....................       des3=0; 
2A04:  CLRF   x9A
....................       edo3=11; 
2A06:  MOVLW  0B
2A08:  MOVWF  x84
....................       sale3=0; 
2A0A:  CLRF   x86
....................       entra_act3=1;} 
2A0C:  MOVLW  01
2A0E:  MOVWF  x83
2A10:  BRA    2A20
....................    else{ 
....................       des3=0; 
2A12:  CLRF   x9A
....................       edo3=12; 
2A14:  MOVLW  0C
2A16:  MOVWF  x84
....................       sale3=0; 
2A18:  CLRF   x86
....................       edoa3=0; 
2A1A:  CLRF   x87
....................       entra_act3=1;} 
2A1C:  MOVLW  01
2A1E:  MOVWF  x83
.................... } 
2A20:  BRA    2A64
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==0)&&(sale3==1)){//SALIA y se regresa 
2A22:  MOVF   x83,F
2A24:  BNZ   2A64
2A26:  MOVF   x6D,F
2A28:  BNZ   2A64
2A2A:  MOVF   x6E,F
2A2C:  BNZ   2A64
2A2E:  DECFSZ x87,W
2A30:  BRA    2A64
2A32:  MOVF   x85,F
2A34:  BNZ   2A64
2A36:  DECFSZ x86,W
2A38:  BRA    2A64
....................    lcd_gotoxy(8,4); 
2A3A:  MOVLW  08
2A3C:  MOVLB  1
2A3E:  MOVWF  xD7
2A40:  MOVLW  04
2A42:  MOVWF  xD8
2A44:  MOVLB  0
2A46:  CALL   0852
....................    lcd_putc(" "); 
2A4A:  MOVLW  92
2A4C:  MOVWF  FF6
2A4E:  MOVLW  03
2A50:  MOVWF  FF7
2A52:  CALL   0A28
....................    des3=0; 
2A56:  CLRF   x9A
....................    edo3=12; 
2A58:  MOVLW  0C
2A5A:  MOVWF  x84
....................    sale3=0; 
2A5C:  CLRF   x86
....................    edoa3=0; 
2A5E:  CLRF   x87
....................    entra_act3=1;} 
2A60:  MOVLW  01
2A62:  MOVWF  x83
2A64:  RETURN 0
.................... } 
....................  
.................... void sensores(){//Detecta estado (bloqueado o libre) de los sensores 
.................... //sensor1 
.................... ent1=input(entrada01); 
*
2AE8:  BSF    F93.4
2AEA:  CLRF   55
2AEC:  BTFSC  F81.4
2AEE:  INCF   55,F
.................... if(ent1==1){ 
2AF0:  DECFSZ 55,W
2AF2:  BRA    2B0C
....................    sub_cta1=0; 
2AF4:  CLRF   5E
2AF6:  CLRF   5D
....................    detec1=0; 
2AF8:  CLRF   x69
....................    bloq_p1=0;//deshabilita bloqueo par1 
2AFA:  CLRF   x9B
....................    tim_p1=0; 
2AFC:  CLRF   xA2
2AFE:  CLRF   xA1
....................    if(en_b1) {//pregunta si esta sonando el par1 
2B00:  MOVF   x9E,F
2B02:  BZ    2B0A
....................       output_low(salida01);//apaga alarma bloqueo 
2B04:  BCF    F94.3
2B06:  BCF    F8B.3
....................       en_b1=0; 
2B08:  CLRF   x9E
....................    } 
.................... } 
2B0A:  BRA    2B66
.................... else { 
....................    if(sub_cta1>=s_cta) detec1=1;//revisa si se interumpio la luz en (5ms*4) 
2B0C:  MOVF   5E,F
2B0E:  BNZ   2B16
2B10:  MOVF   5D,W
2B12:  SUBLW  04
2B14:  BC    2B1A
2B16:  MOVLW  01
2B18:  MOVWF  x69
....................    if(sub_d1!=detec1) {//si, cambia de estado el sensor 
2B1A:  MOVF   x69,W
2B1C:  SUBWF  x6F,W
2B1E:  BZ    2B66
....................       sub_d1=detec1; 
2B20:  MOVFF  69,6F
....................       enable1=1; 
2B24:  MOVLW  01
2B26:  MOVWF  x7A
....................       lcd_gotoxy(5,2); 
2B28:  MOVLW  05
2B2A:  MOVLB  1
2B2C:  MOVWF  xD7
2B2E:  MOVLW  02
2B30:  MOVWF  xD8
2B32:  MOVLB  0
2B34:  CALL   0852
....................       printf(lcd_putc,"1:%d",sub_d1); 
2B38:  MOVLW  31
2B3A:  MOVLB  1
2B3C:  MOVWF  xD6
2B3E:  MOVLB  0
2B40:  CALL   08A4
2B44:  MOVLW  3A
2B46:  MOVLB  1
2B48:  MOVWF  xD6
2B4A:  MOVLB  0
2B4C:  CALL   08A4
2B50:  MOVFF  6F,1CC
2B54:  MOVLW  18
2B56:  MOVLB  1
2B58:  MOVWF  xCD
2B5A:  MOVLB  0
2B5C:  CALL   10D0
....................       sensando1(); 
2B60:  CALL   2060
....................       contando1(); 
2B64:  RCALL  2454
....................    } 
.................... } 
.................... //sensor2 
.................... ent2=input(entrada02); 
2B66:  BSF    F95.4
2B68:  CLRF   56
2B6A:  BTFSC  F83.4
2B6C:  INCF   56,F
.................... if(ent2==1){ 
2B6E:  DECFSZ 56,W
2B70:  BRA    2B8E
....................    output_high(salida02);// 
2B72:  BCF    F94.4
2B74:  BSF    F8B.4
....................    sub_cta2=0; 
2B76:  CLRF   x60
2B78:  CLRF   5F
....................    detec2=0; 
2B7A:  CLRF   x6A
....................    bloq_p1=0;//deshabilita bloqueo 
2B7C:  CLRF   x9B
....................    tim_p1=0; 
2B7E:  CLRF   xA2
2B80:  CLRF   xA1
....................    if(en_b1) { 
2B82:  MOVF   x9E,F
2B84:  BZ    2B8C
....................       output_low(salida01);//apaga alarma bloqueo 
2B86:  BCF    F94.3
2B88:  BCF    F8B.3
....................       en_b1=0; 
2B8A:  CLRF   x9E
....................    } 
.................... } 
2B8C:  BRA    2BF6
.................... else { 
....................    output_low(salida02); 
2B8E:  BCF    F94.4
2B90:  BCF    F8B.4
....................    if(sub_cta2>=s_cta) detec2=1; 
2B92:  MOVF   x60,F
2B94:  BNZ   2B9C
2B96:  MOVF   5F,W
2B98:  SUBLW  04
2B9A:  BC    2BA0
2B9C:  MOVLW  01
2B9E:  MOVWF  x6A
....................    if(sub_d2!=detec2) { 
2BA0:  MOVF   x6A,W
2BA2:  SUBWF  x70,W
2BA4:  BZ    2BF6
....................       sub_d2=detec2; 
2BA6:  MOVFF  6A,70
....................       enable1=1; 
2BAA:  MOVLW  01
2BAC:  MOVWF  x7A
....................       lcd_gotoxy(1,2); 
2BAE:  MOVLB  1
2BB0:  MOVWF  xD7
2BB2:  MOVLW  02
2BB4:  MOVWF  xD8
2BB6:  MOVLB  0
2BB8:  CALL   0852
....................       printf(lcd_putc,"2:%d ",sub_d2); 
2BBC:  MOVLW  32
2BBE:  MOVLB  1
2BC0:  MOVWF  xD6
2BC2:  MOVLB  0
2BC4:  CALL   08A4
2BC8:  MOVLW  3A
2BCA:  MOVLB  1
2BCC:  MOVWF  xD6
2BCE:  MOVLB  0
2BD0:  CALL   08A4
2BD4:  MOVFF  70,1CC
2BD8:  MOVLW  18
2BDA:  MOVLB  1
2BDC:  MOVWF  xCD
2BDE:  MOVLB  0
2BE0:  CALL   10D0
2BE4:  MOVLW  20
2BE6:  MOVLB  1
2BE8:  MOVWF  xD6
2BEA:  MOVLB  0
2BEC:  CALL   08A4
....................       sensando1(); 
2BF0:  CALL   2060
....................       contando1(); 
2BF4:  RCALL  2454
....................    } 
.................... } 
.................... //sensor3 
.................... ent3=input(entrada03); 
2BF6:  BSF    F93.2
2BF8:  CLRF   57
2BFA:  BTFSC  F81.2
2BFC:  INCF   57,F
.................... if(ent3==1){ 
2BFE:  DECFSZ 57,W
2C00:  BRA    2C1A
....................    sub_cta3=0; 
2C02:  CLRF   x62
2C04:  CLRF   x61
....................    detec3=0; 
2C06:  CLRF   x6B
....................    bloq_p2=0;//deshabilita bloqueo 
2C08:  CLRF   x9C
....................    tim_p2=0; 
2C0A:  CLRF   xA4
2C0C:  CLRF   xA3
....................    if(en_b2) { 
2C0E:  MOVF   x9F,F
2C10:  BZ    2C18
....................       output_low(salida01);//apaga alarma bloqueo 
2C12:  BCF    F94.3
2C14:  BCF    F8B.3
....................       en_b2=0; 
2C16:  CLRF   x9F
....................    } 
.................... } 
2C18:  BRA    2C72
.................... else { 
....................    if(sub_cta3>=s_cta) detec3=1; 
2C1A:  MOVF   x62,F
2C1C:  BNZ   2C24
2C1E:  MOVF   x61,W
2C20:  SUBLW  04
2C22:  BC    2C28
2C24:  MOVLW  01
2C26:  MOVWF  x6B
....................    if(sub_d3!=detec3) { 
2C28:  MOVF   x6B,W
2C2A:  SUBWF  x71,W
2C2C:  BZ    2C72
....................       sub_d3=detec3; 
2C2E:  MOVFF  6B,71
....................       enable2=1; 
2C32:  MOVLW  01
2C34:  MOVWF  x81
....................       lcd_gotoxy(5,3); 
2C36:  MOVLW  05
2C38:  MOVLB  1
2C3A:  MOVWF  xD7
2C3C:  MOVLW  03
2C3E:  MOVWF  xD8
2C40:  MOVLB  0
2C42:  CALL   0852
....................       printf(lcd_putc,"3:%d",sub_d3); 
2C46:  MOVLW  33
2C48:  MOVLB  1
2C4A:  MOVWF  xD6
2C4C:  MOVLB  0
2C4E:  CALL   08A4
2C52:  MOVLW  3A
2C54:  MOVLB  1
2C56:  MOVWF  xD6
2C58:  MOVLB  0
2C5A:  CALL   08A4
2C5E:  MOVFF  71,1CC
2C62:  MOVLW  18
2C64:  MOVLB  1
2C66:  MOVWF  xCD
2C68:  MOVLB  0
2C6A:  CALL   10D0
....................       sensando2(); 
2C6E:  RCALL  24D6
....................       contando2(); 
2C70:  RCALL  275C
....................    } 
.................... } 
.................... //sensor4 
.................... ent4=input(entrada04); 
2C72:  BSF    F93.3
2C74:  CLRF   58
2C76:  BTFSC  F81.3
2C78:  INCF   58,F
.................... if(ent4==1){ 
2C7A:  DECFSZ 58,W
2C7C:  BRA    2C9A
....................    output_high(salida02);// 
2C7E:  BCF    F94.4
2C80:  BSF    F8B.4
....................    sub_cta4=0; 
2C82:  CLRF   x64
2C84:  CLRF   x63
....................    detec4=0; 
2C86:  CLRF   x6C
....................    bloq_p2=0;//deshabilita bloqueo 
2C88:  CLRF   x9C
....................    tim_p2=0; 
2C8A:  CLRF   xA4
2C8C:  CLRF   xA3
....................    if(en_b2) { 
2C8E:  MOVF   x9F,F
2C90:  BZ    2C98
....................       output_low(salida01);//apaga alarma bloqueo 
2C92:  BCF    F94.3
2C94:  BCF    F8B.3
....................       en_b2=0; 
2C96:  CLRF   x9F
....................    } 
.................... } 
2C98:  BRA    2D02
.................... else { 
....................     output_low(salida02); 
2C9A:  BCF    F94.4
2C9C:  BCF    F8B.4
....................     if(sub_cta4>=s_cta) detec4=1; 
2C9E:  MOVF   x64,F
2CA0:  BNZ   2CA8
2CA2:  MOVF   x63,W
2CA4:  SUBLW  04
2CA6:  BC    2CAC
2CA8:  MOVLW  01
2CAA:  MOVWF  x6C
....................     if(sub_d4!=detec4) { 
2CAC:  MOVF   x6C,W
2CAE:  SUBWF  x72,W
2CB0:  BZ    2D02
....................       sub_d4=detec4; 
2CB2:  MOVFF  6C,72
....................       enable2=1; 
2CB6:  MOVLW  01
2CB8:  MOVWF  x81
....................       lcd_gotoxy(1,3); 
2CBA:  MOVLB  1
2CBC:  MOVWF  xD7
2CBE:  MOVLW  03
2CC0:  MOVWF  xD8
2CC2:  MOVLB  0
2CC4:  CALL   0852
....................       printf(lcd_putc,"4:%d ",sub_d4); 
2CC8:  MOVLW  34
2CCA:  MOVLB  1
2CCC:  MOVWF  xD6
2CCE:  MOVLB  0
2CD0:  CALL   08A4
2CD4:  MOVLW  3A
2CD6:  MOVLB  1
2CD8:  MOVWF  xD6
2CDA:  MOVLB  0
2CDC:  CALL   08A4
2CE0:  MOVFF  72,1CC
2CE4:  MOVLW  18
2CE6:  MOVLB  1
2CE8:  MOVWF  xCD
2CEA:  MOVLB  0
2CEC:  CALL   10D0
2CF0:  MOVLW  20
2CF2:  MOVLB  1
2CF4:  MOVWF  xD6
2CF6:  MOVLB  0
2CF8:  CALL   08A4
....................       sensando2(); 
2CFC:  CALL   24D6
....................       contando2(); 
2D00:  RCALL  275C
....................    } 
.................... } 
.................... //sensor5 
.................... ent5=input(entrada05); 
2D02:  BSF    F93.0
2D04:  CLRF   59
2D06:  BTFSC  F81.0
2D08:  INCF   59,F
.................... if(ent5==1){ 
2D0A:  DECFSZ 59,W
2D0C:  BRA    2D26
....................    sub_cta5=0; 
2D0E:  CLRF   x66
2D10:  CLRF   x65
....................    detec5=0; 
2D12:  CLRF   x6D
....................    bloq_p3=0;//deshabilita bloqueo 
2D14:  CLRF   x9D
....................    tim_p3=0; 
2D16:  CLRF   xA6
2D18:  CLRF   xA5
....................    if(en_b3) { 
2D1A:  MOVF   xA0,F
2D1C:  BZ    2D24
....................       output_low(salida01);//apaga alarma bloqueo 
2D1E:  BCF    F94.3
2D20:  BCF    F8B.3
....................       en_b3=0; 
2D22:  CLRF   xA0
....................    } 
.................... } 
2D24:  BRA    2D7E
.................... else { 
....................     if(sub_cta5>=s_cta) detec5=1; 
2D26:  MOVF   x66,F
2D28:  BNZ   2D30
2D2A:  MOVF   x65,W
2D2C:  SUBLW  04
2D2E:  BC    2D34
2D30:  MOVLW  01
2D32:  MOVWF  x6D
....................     if(sub_d5!=detec5) { 
2D34:  MOVF   x6D,W
2D36:  SUBWF  x73,W
2D38:  BZ    2D7E
....................       sub_d5=detec5; 
2D3A:  MOVFF  6D,73
....................       enable3=1; 
2D3E:  MOVLW  01
2D40:  MOVWF  x88
....................       lcd_gotoxy(5,4); 
2D42:  MOVLW  05
2D44:  MOVLB  1
2D46:  MOVWF  xD7
2D48:  MOVLW  04
2D4A:  MOVWF  xD8
2D4C:  MOVLB  0
2D4E:  CALL   0852
....................       printf(lcd_putc,"5:%d",sub_d5); 
2D52:  MOVLW  35
2D54:  MOVLB  1
2D56:  MOVWF  xD6
2D58:  MOVLB  0
2D5A:  CALL   08A4
2D5E:  MOVLW  3A
2D60:  MOVLB  1
2D62:  MOVWF  xD6
2D64:  MOVLB  0
2D66:  CALL   08A4
2D6A:  MOVFF  73,1CC
2D6E:  MOVLW  18
2D70:  MOVLB  1
2D72:  MOVWF  xCD
2D74:  MOVLB  0
2D76:  CALL   10D0
....................       sensando3(); 
2D7A:  RCALL  27DE
....................       contando3(); 
2D7C:  RCALL  2A66
....................    } 
.................... } 
.................... //sensor6 
.................... ent6=input(entrada06); 
2D7E:  BSF    F93.1
2D80:  CLRF   5A
2D82:  BTFSC  F81.1
2D84:  INCF   5A,F
.................... if(ent6==1){ 
2D86:  DECFSZ 5A,W
2D88:  BRA    2DA6
....................    output_high(salida02);// 
2D8A:  BCF    F94.4
2D8C:  BSF    F8B.4
....................    sub_cta6=0; 
2D8E:  CLRF   x68
2D90:  CLRF   x67
....................    detec6=0; 
2D92:  CLRF   x6E
....................    bloq_p3=0;//deshabilita bloqueo 
2D94:  CLRF   x9D
....................    tim_p3=0; 
2D96:  CLRF   xA6
2D98:  CLRF   xA5
....................    if(en_b3) { 
2D9A:  MOVF   xA0,F
2D9C:  BZ    2DA4
....................       output_low(salida01);//apaga alarma bloqueo 
2D9E:  BCF    F94.3
2DA0:  BCF    F8B.3
....................       en_b3=0; 
2DA2:  CLRF   xA0
....................    } 
.................... } 
2DA4:  BRA    2E0C
.................... else { 
....................    output_low(salida02);// 
2DA6:  BCF    F94.4
2DA8:  BCF    F8B.4
....................    if(sub_cta6>=s_cta)   detec6=1; 
2DAA:  MOVF   x68,F
2DAC:  BNZ   2DB4
2DAE:  MOVF   x67,W
2DB0:  SUBLW  04
2DB2:  BC    2DB8
2DB4:  MOVLW  01
2DB6:  MOVWF  x6E
....................    if(sub_d6!=detec6) { 
2DB8:  MOVF   x6E,W
2DBA:  SUBWF  x74,W
2DBC:  BZ    2E0C
....................       sub_d6=detec6; 
2DBE:  MOVFF  6E,74
....................       enable3=1; 
2DC2:  MOVLW  01
2DC4:  MOVWF  x88
....................       lcd_gotoxy(1,4); 
2DC6:  MOVLB  1
2DC8:  MOVWF  xD7
2DCA:  MOVLW  04
2DCC:  MOVWF  xD8
2DCE:  MOVLB  0
2DD0:  CALL   0852
....................       printf(lcd_putc,"6:%d ",sub_d6); 
2DD4:  MOVLW  36
2DD6:  MOVLB  1
2DD8:  MOVWF  xD6
2DDA:  MOVLB  0
2DDC:  CALL   08A4
2DE0:  MOVLW  3A
2DE2:  MOVLB  1
2DE4:  MOVWF  xD6
2DE6:  MOVLB  0
2DE8:  CALL   08A4
2DEC:  MOVFF  74,1CC
2DF0:  MOVLW  18
2DF2:  MOVLB  1
2DF4:  MOVWF  xCD
2DF6:  MOVLB  0
2DF8:  CALL   10D0
2DFC:  MOVLW  20
2DFE:  MOVLB  1
2E00:  MOVWF  xD6
2E02:  MOVLB  0
2E04:  CALL   08A4
....................       sensando3(); 
2E08:  RCALL  27DE
....................       contando3(); 
2E0A:  RCALL  2A66
....................    } 
.................... } 
.................... ////////////////////////// 
.................... if( (detec1==1)&&(detec2==1)&&(bloq_p1==0) ){ 
2E0C:  DECFSZ x69,W
2E0E:  BRA    2E20
2E10:  DECFSZ x6A,W
2E12:  BRA    2E20
2E14:  MOVF   x9B,F
2E16:  BNZ   2E20
....................          bloq_p1=1; 
2E18:  MOVLW  01
2E1A:  MOVWF  x9B
....................          tim_p1=0; 
2E1C:  CLRF   xA2
2E1E:  CLRF   xA1
....................       } 
.................... if( (detec3==1)&&(detec4==1)&&(bloq_p2==0) ){ 
2E20:  DECFSZ x6B,W
2E22:  BRA    2E34
2E24:  DECFSZ x6C,W
2E26:  BRA    2E34
2E28:  MOVF   x9C,F
2E2A:  BNZ   2E34
....................          bloq_p2=1; 
2E2C:  MOVLW  01
2E2E:  MOVWF  x9C
....................          tim_p2=0; 
2E30:  CLRF   xA4
2E32:  CLRF   xA3
....................       } 
.................... if( (detec5==1)&&(detec6==1)&&(bloq_p3==0) ){ 
2E34:  DECFSZ x6D,W
2E36:  BRA    2E48
2E38:  DECFSZ x6E,W
2E3A:  BRA    2E48
2E3C:  MOVF   x9D,F
2E3E:  BNZ   2E48
....................          bloq_p3=1; 
2E40:  MOVLW  01
2E42:  MOVWF  x9D
....................          tim_p3=0; 
2E44:  CLRF   xA6
2E46:  CLRF   xA5
....................       } 
2E48:  GOTO   3692 (RETURN)
.................... }//end sensores 
....................  
.................... void sentidos(){//Define si la persona esta entrando o saliendo 
....................  if( (!sen_ent)&&(!sen_sal) ){ 
*
2016:  MOVF   5B,F
2018:  BNZ   205E
201A:  MOVF   5C,F
201C:  BNZ   205E
....................    if ( ( (detec1==1)&&(detec3==1) )|| ( (detec1==1)&&(detec5==1) )|| ( (detec3==1)&&(detec5==1) ) ) { 
201E:  DECFSZ x69,W
2020:  BRA    2028
2022:  DECFSZ x6B,W
2024:  BRA    2028
2026:  BRA    203A
2028:  DECFSZ x69,W
202A:  BRA    2032
202C:  DECFSZ x6D,W
202E:  BRA    2032
2030:  BRA    203A
2032:  DECFSZ x6B,W
2034:  BRA    203E
2036:  DECFSZ x6D,W
2038:  BRA    203E
....................       sen_ent=1; 
203A:  MOVLW  01
203C:  MOVWF  5B
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Sub"); 
....................    } 
....................    if ( ( (detec2==1)&&(detec4==1) )|| ( (detec2==1)&&(detec6==1) )|| ( (detec4==1)&&(detec6==1) ) ) { 
203E:  DECFSZ x6A,W
2040:  BRA    2048
2042:  DECFSZ x6C,W
2044:  BRA    2048
2046:  BRA    205A
2048:  DECFSZ x6A,W
204A:  BRA    2052
204C:  DECFSZ x6E,W
204E:  BRA    2052
2050:  BRA    205A
2052:  DECFSZ x6C,W
2054:  BRA    205E
2056:  DECFSZ x6E,W
2058:  BRA    205E
....................       sen_sal=1; 
205A:  MOVLW  01
205C:  MOVWF  5C
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Baj"); 
....................    } 
....................  } 
205E:  RETURN 0
.................... } 
....................  
.................... void rd_eeprom(){//Revisa si cadena recibida es un instruccion 
....................    a=b=0; 
*
0EF2:  CLRF   49
0EF4:  CLRF   48
0EF6:  MOVFF  48,44
....................    n=word_size;// 
0EFA:  CLRF   4B
0EFC:  MOVLW  0A
0EFE:  MOVWF  4A
....................    //i=0; 
....................    //i=2; 
....................    while ((b <=data_set)&&(a==0)){//NUMERO TOTAL DE INSTRUCCIONES 
0F00:  MOVF   49,F
0F02:  BNZ   0F98
0F04:  MOVF   48,W
0F06:  SUBLW  09
0F08:  BNC   0F98
0F0A:  MOVF   44,F
0F0C:  BNZ   0F98
....................        i=0; 
0F0E:  CLRF   41
....................        b++; 
0F10:  INCF   48,F
0F12:  BTFSC  FD8.2
0F14:  INCF   49,F
....................        while (i < word_size) {//word_size=10 
0F16:  MOVF   41,W
0F18:  SUBLW  09
0F1A:  BNC   0F8C
....................            memory[i] = read_eeprom(n+i); 
0F1C:  CLRF   03
0F1E:  MOVF   41,W
0F20:  ADDLW  BC
0F22:  MOVWF  FE9
0F24:  MOVLW  01
0F26:  ADDWFC 03,W
0F28:  MOVWF  FEA
0F2A:  MOVF   41,W
0F2C:  ADDWF  4A,W
0F2E:  MOVLB  1
0F30:  MOVWF  xCE
0F32:  MOVLW  00
0F34:  ADDWFC 4B,W
0F36:  MOVWF  xCF
0F38:  MOVFF  FF2,1D0
0F3C:  BCF    FF2.7
0F3E:  MOVFF  1CE,FA9
0F42:  BCF    FA6.6
0F44:  BCF    FA6.7
0F46:  BSF    FA6.0
0F48:  MOVF   FA8,W
0F4A:  BTFSC  xD0.7
0F4C:  BSF    FF2.7
0F4E:  MOVWF  FEF
....................             
....................            if (memory[i] != XX[i]) 
0F50:  CLRF   03
0F52:  MOVF   41,W
0F54:  ADDLW  BC
0F56:  MOVWF  FE9
0F58:  MOVLW  01
0F5A:  ADDWFC 03,W
0F5C:  MOVWF  FEA
0F5E:  MOVFF  FEF,1CC
0F62:  CLRF   03
0F64:  MOVF   41,W
0F66:  ADDLW  8D
0F68:  MOVWF  FE9
0F6A:  MOVLW  01
0F6C:  ADDWFC 03,W
0F6E:  MOVWF  FEA
0F70:  MOVF   FEF,W
0F72:  SUBWF  xCC,W
0F74:  BZ    0F7C
....................                break; 
0F76:  MOVLB  0
0F78:  BRA    0F8C
0F7A:  MOVLB  1
....................            i++; 
0F7C:  INCF   41,F
....................            if (i==word_size) a=1; 
0F7E:  MOVF   41,W
0F80:  SUBLW  0A
0F82:  BNZ   0F88
0F84:  MOVLW  01
0F86:  MOVWF  44
0F88:  MOVLB  0
0F8A:  BRA    0F16
....................        } 
....................        //fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
0F8C:  MOVLW  0A
0F8E:  ADDWF  4A,F
0F90:  MOVLW  00
0F92:  ADDWFC 4B,F
....................        restart_wdt(); 
0F94:  CLRWDT
0F96:  BRA    0F00
....................    } 
0F98:  GOTO   32C0 (RETURN)
.................... } 
....................  
.................... void rd_eeprom_inicio(){// 
....................    a=b=0; 
....................    n=word_size;// 
....................     
....................    while (b <=data_set){//NUMERO TOTAL DE INSTRUCCIONES 
....................        i=0; 
....................        b++; 
....................        while (i < word_size) {//word_size=10 
....................            memory[i] = read_eeprom(n+i); 
....................            i++; 
....................            if (i==word_size) a=1; 
....................        } 
....................        fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
....................        //restart_wdt(); 
....................    } 
.................... } 
....................  
.................... /* 
.................... void llaves(){//Graba las instrucciones de control en eeprom 
.................... int tem; 
.................... ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
....................       switch (tem) { 
....................         case 1:{for (i=0;i<word_size;++i)  texto[i]=texto1[i]; 
....................               break;} 
....................         case 2:{for (i=0;i<word_size;++i)  texto[i]=texto2[i]; 
....................               break;} 
....................         case 3:{for (i=0;i<word_size;++i)  texto[i]=texto3[i]; 
....................               break;} 
....................         case 4:{for (i=0;i<word_size;++i)  texto[i]=texto4[i]; 
....................               break;} 
....................         case 5:{for (i=0;i<word_size;++i)  texto[i]=texto5[i]; 
....................               break;} 
....................         case 6:{for (i=0;i<word_size;++i)  texto[i]=texto6[i]; 
....................               break;} 
....................         case 7:{for (i=0;i<word_size;++i)  texto[i]=texto7[i]; 
....................               break;} 
....................         case 8:{for (i=0;i<word_size;++i)  texto[i]=texto8[i]; 
....................               break;} 
....................         case 9:{for (i=0;i<word_size;++i)  texto[i]=texto9[i]; 
....................               break;} 
....................       } 
....................       a=i=0; 
....................       while (i < word_size) {  //word_size=8 
....................               memory[i] = read_eeprom((tem*word_size)+i); 
....................               fprintf(monitor,"tx[]:%s",texto); 
....................               if (memory[i] != texto[i]){ 
....................              // fprintf(monitor,"es diferente."); 
....................               break; 
....................               } 
....................               i++; 
....................               if (i==word_size){ 
....................              // fprintf(monitor,"a=1"); 
....................               a=1; 
....................               } 
....................       } 
....................       if (a==0){ 
....................          i=0; 
....................          fprintf(monitor,"e."); 
....................         // fprintf(monitor,"texto[]:%s",texto); 
....................          while (texto[i] != 0x00){ 
....................             write_eeprom(i+(tem*word_size),texto[i]); 
....................             i++; 
....................          } 
....................       } 
....................    }//end for 
.................... } 
.................... */ 
....................  
.................... void lcd_cuentas(){//Escribe las cuenta en LCD  
....................     lcd_gotoxy(1,1); 
*
0A48:  MOVLW  01
0A4A:  MOVLB  1
0A4C:  MOVWF  xD7
0A4E:  MOVWF  xD8
0A50:  MOVLB  0
0A52:  RCALL  0852
....................     if(master) { 
0A54:  MOVF   45,F
0A56:  BTFSC  FD8.2
0A58:  BRA    0B78
....................        printf(lcd_putc,"1 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0A5A:  MOVLW  31
0A5C:  MOVLB  1
0A5E:  MOVWF  xD6
0A60:  MOVLB  0
0A62:  RCALL  08A4
0A64:  MOVLW  20
0A66:  MOVLB  1
0A68:  MOVWF  xD6
0A6A:  MOVLB  0
0A6C:  RCALL  08A4
0A6E:  MOVFF  187,1D6
0A72:  RCALL  08A4
0A74:  MOVFF  188,1D6
0A78:  RCALL  08A4
0A7A:  MOVFF  189,1D6
0A7E:  RCALL  08A4
0A80:  MOVFF  18A,1D6
0A84:  RCALL  08A4
0A86:  MOVFF  18B,1D6
0A8A:  RCALL  08A4
0A8C:  MOVLW  20
0A8E:  MOVLB  1
0A90:  MOVWF  xD6
0A92:  MOVLB  0
0A94:  RCALL  08A4
....................        lcd_gotoxy(14,1); 
0A96:  MOVLW  0E
0A98:  MOVLB  1
0A9A:  MOVWF  xD7
0A9C:  MOVLW  01
0A9E:  MOVWF  xD8
0AA0:  MOVLB  0
0AA2:  RCALL  0852
....................        printf(lcd_putc,"S1:%Ld ",entraront); 
0AA4:  MOVLW  A0
0AA6:  MOVWF  FF6
0AA8:  MOVLW  03
0AAA:  MOVWF  FF7
0AAC:  MOVLW  03
0AAE:  MOVLB  1
0AB0:  MOVWF  xCD
0AB2:  MOVLB  0
0AB4:  RCALL  0904
0AB6:  MOVLW  10
0AB8:  MOVWF  FE9
0ABA:  MOVFF  8B,1CE
0ABE:  MOVFF  8A,1CD
0AC2:  RCALL  092C
0AC4:  MOVLW  20
0AC6:  MOVLB  1
0AC8:  MOVWF  xD6
0ACA:  MOVLB  0
0ACC:  RCALL  08A4
....................        lcd_gotoxy(14,2); 
0ACE:  MOVLW  0E
0AD0:  MOVLB  1
0AD2:  MOVWF  xD7
0AD4:  MOVLW  02
0AD6:  MOVWF  xD8
0AD8:  MOVLB  0
0ADA:  RCALL  0852
....................        printf(lcd_putc,"B1:%Ld ",salieront); 
0ADC:  MOVLW  A8
0ADE:  MOVWF  FF6
0AE0:  MOVLW  03
0AE2:  MOVWF  FF7
0AE4:  MOVLW  03
0AE6:  MOVLB  1
0AE8:  MOVWF  xCD
0AEA:  MOVLB  0
0AEC:  RCALL  0904
0AEE:  MOVLW  10
0AF0:  MOVWF  FE9
0AF2:  MOVFF  8D,1CE
0AF6:  MOVFF  8C,1CD
0AFA:  RCALL  092C
0AFC:  MOVLW  20
0AFE:  MOVLB  1
0B00:  MOVWF  xD6
0B02:  MOVLB  0
0B04:  RCALL  08A4
....................        lcd_gotoxy(14,3); 
0B06:  MOVLW  0E
0B08:  MOVLB  1
0B0A:  MOVWF  xD7
0B0C:  MOVLW  03
0B0E:  MOVWF  xD8
0B10:  MOVLB  0
0B12:  RCALL  0852
....................        printf(lcd_putc,"S2:%Ld ",sub_atras); 
0B14:  MOVLW  B0
0B16:  MOVWF  FF6
0B18:  MOVLW  03
0B1A:  MOVWF  FF7
0B1C:  MOVLW  03
0B1E:  MOVLB  1
0B20:  MOVWF  xCD
0B22:  MOVLB  0
0B24:  RCALL  0904
0B26:  MOVLW  10
0B28:  MOVWF  FE9
0B2A:  MOVFF  35,1CE
0B2E:  MOVFF  34,1CD
0B32:  RCALL  092C
0B34:  MOVLW  20
0B36:  MOVLB  1
0B38:  MOVWF  xD6
0B3A:  MOVLB  0
0B3C:  RCALL  08A4
....................        //printf(lcd_putc,"N2:"); 
....................        lcd_gotoxy(14,4); 
0B3E:  MOVLW  0E
0B40:  MOVLB  1
0B42:  MOVWF  xD7
0B44:  MOVLW  04
0B46:  MOVWF  xD8
0B48:  MOVLB  0
0B4A:  RCALL  0852
....................        printf(lcd_putc,"B2:%Ld ",baj_atras); 
0B4C:  MOVLW  B8
0B4E:  MOVWF  FF6
0B50:  MOVLW  03
0B52:  MOVWF  FF7
0B54:  MOVLW  03
0B56:  MOVLB  1
0B58:  MOVWF  xCD
0B5A:  MOVLB  0
0B5C:  RCALL  0904
0B5E:  MOVLW  10
0B60:  MOVWF  FE9
0B62:  MOVFF  37,1CE
0B66:  MOVFF  36,1CD
0B6A:  RCALL  092C
0B6C:  MOVLW  20
0B6E:  MOVLB  1
0B70:  MOVWF  xD6
0B72:  MOVLB  0
0B74:  RCALL  08A4
....................     } 
0B76:  BRA    0C54
....................     else{ 
....................        printf(lcd_putc,"2 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0B78:  MOVLW  32
0B7A:  MOVLB  1
0B7C:  MOVWF  xD6
0B7E:  MOVLB  0
0B80:  RCALL  08A4
0B82:  MOVLW  20
0B84:  MOVLB  1
0B86:  MOVWF  xD6
0B88:  MOVLB  0
0B8A:  RCALL  08A4
0B8C:  MOVFF  187,1D6
0B90:  RCALL  08A4
0B92:  MOVFF  188,1D6
0B96:  RCALL  08A4
0B98:  MOVFF  189,1D6
0B9C:  RCALL  08A4
0B9E:  MOVFF  18A,1D6
0BA2:  RCALL  08A4
0BA4:  MOVFF  18B,1D6
0BA8:  RCALL  08A4
0BAA:  MOVLW  20
0BAC:  MOVLB  1
0BAE:  MOVWF  xD6
0BB0:  MOVLB  0
0BB2:  RCALL  08A4
....................        lcd_gotoxy(14,1); 
0BB4:  MOVLW  0E
0BB6:  MOVLB  1
0BB8:  MOVWF  xD7
0BBA:  MOVLW  01
0BBC:  MOVWF  xD8
0BBE:  MOVLB  0
0BC0:  RCALL  0852
....................        lcd_putc("S1:    "); 
0BC2:  MOVLW  C0
0BC4:  MOVWF  FF6
0BC6:  MOVLW  03
0BC8:  MOVWF  FF7
0BCA:  RCALL  0A28
....................        lcd_gotoxy(14,2); 
0BCC:  MOVLW  0E
0BCE:  MOVLB  1
0BD0:  MOVWF  xD7
0BD2:  MOVLW  02
0BD4:  MOVWF  xD8
0BD6:  MOVLB  0
0BD8:  RCALL  0852
....................        lcd_putc("B1:    "); 
0BDA:  MOVLW  C8
0BDC:  MOVWF  FF6
0BDE:  MOVLW  03
0BE0:  MOVWF  FF7
0BE2:  RCALL  0A28
....................        lcd_gotoxy(14,3); 
0BE4:  MOVLW  0E
0BE6:  MOVLB  1
0BE8:  MOVWF  xD7
0BEA:  MOVLW  03
0BEC:  MOVWF  xD8
0BEE:  MOVLB  0
0BF0:  RCALL  0852
....................        printf(lcd_putc,"S2:%Ld ",entraront); 
0BF2:  MOVLW  D0
0BF4:  MOVWF  FF6
0BF6:  MOVLW  03
0BF8:  MOVWF  FF7
0BFA:  MOVLW  03
0BFC:  MOVLB  1
0BFE:  MOVWF  xCD
0C00:  MOVLB  0
0C02:  RCALL  0904
0C04:  MOVLW  10
0C06:  MOVWF  FE9
0C08:  MOVFF  8B,1CE
0C0C:  MOVFF  8A,1CD
0C10:  RCALL  092C
0C12:  MOVLW  20
0C14:  MOVLB  1
0C16:  MOVWF  xD6
0C18:  MOVLB  0
0C1A:  RCALL  08A4
....................        //printf(lcd_putc,"S2:v"); 
....................        lcd_gotoxy(14,4); 
0C1C:  MOVLW  0E
0C1E:  MOVLB  1
0C20:  MOVWF  xD7
0C22:  MOVLW  04
0C24:  MOVWF  xD8
0C26:  MOVLB  0
0C28:  RCALL  0852
....................        printf(lcd_putc,"B2:%Ld ",salieront); 
0C2A:  MOVLW  D8
0C2C:  MOVWF  FF6
0C2E:  MOVLW  03
0C30:  MOVWF  FF7
0C32:  MOVLW  03
0C34:  MOVLB  1
0C36:  MOVWF  xCD
0C38:  MOVLB  0
0C3A:  RCALL  0904
0C3C:  MOVLW  10
0C3E:  MOVWF  FE9
0C40:  MOVFF  8D,1CE
0C44:  MOVFF  8C,1CD
0C48:  RCALL  092C
0C4A:  MOVLW  20
0C4C:  MOVLB  1
0C4E:  MOVWF  xD6
0C50:  MOVLB  0
0C52:  RCALL  08A4
....................     } 
0C54:  RETURN 0
....................      
.................... } 
....................  
.................... void write_ent(){//Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0C94:  BCF    FF2.6
0C96:  BCF    FF2.7
0C98:  BTFSC  FF2.7
0C9A:  BRA    0C96
....................    write_ext_eeprom(2,entraront);//parte baja 
0C9C:  MOVLB  1
0C9E:  CLRF   xD1
0CA0:  MOVLW  02
0CA2:  MOVWF  xD0
0CA4:  MOVFF  8A,1D2
0CA8:  MOVLB  0
0CAA:  RCALL  0598
....................    write_ext_eeprom(1,(entraront>>8) );//parte alta 
0CAC:  MOVFF  8B,1CC
0CB0:  MOVLB  1
0CB2:  CLRF   xCD
0CB4:  CLRF   xD1
0CB6:  MOVLW  01
0CB8:  MOVWF  xD0
0CBA:  MOVFF  8B,1D2
0CBE:  MOVLB  0
0CC0:  RCALL  0598
....................    enable_interrupts(GLOBAL); 
0CC2:  MOVLW  C0
0CC4:  IORWF  FF2,F
....................    finsuma(); 
0CC6:  RCALL  0C56
0CC8:  RETURN 0
.................... } 
....................  
.................... void write_sal(){//Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0CCA:  BCF    FF2.6
0CCC:  BCF    FF2.7
0CCE:  BTFSC  FF2.7
0CD0:  BRA    0CCC
....................    write_ext_eeprom(4,salieront);//parte baja 
0CD2:  MOVLB  1
0CD4:  CLRF   xD1
0CD6:  MOVLW  04
0CD8:  MOVWF  xD0
0CDA:  MOVFF  8C,1D2
0CDE:  MOVLB  0
0CE0:  RCALL  0598
....................    write_ext_eeprom(3,(salieront>>8) );//parte alta 
0CE2:  MOVFF  8D,1CC
0CE6:  MOVLB  1
0CE8:  CLRF   xCD
0CEA:  CLRF   xD1
0CEC:  MOVLW  03
0CEE:  MOVWF  xD0
0CF0:  MOVFF  8D,1D2
0CF4:  MOVLB  0
0CF6:  RCALL  0598
....................    enable_interrupts(GLOBAL); 
0CF8:  MOVLW  C0
0CFA:  IORWF  FF2,F
....................    finsuma(); 
0CFC:  RCALL  0C56
0CFE:  RETURN 0
.................... } 
....................  
.................... void entraron_total(){//Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D6C:  BCF    FF2.6
0D6E:  BCF    FF2.7
0D70:  BTFSC  FF2.7
0D72:  BRA    0D6E
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0D74:  MOVLB  1
0D76:  CLRF   xCC
0D78:  CLRF   xCD
0D7A:  CLRF   xCF
0D7C:  CLRF   xCE
....................     
....................    reg_h=read_ext_eeprom(1); 
0D7E:  CLRF   xD1
0D80:  MOVLW  01
0D82:  MOVWF  xD0
0D84:  MOVLB  0
0D86:  RCALL  0758
0D88:  MOVFF  01,1CC
....................    reg_l=read_ext_eeprom(2); 
0D8C:  MOVLB  1
0D8E:  CLRF   xD1
0D90:  MOVLW  02
0D92:  MOVWF  xD0
0D94:  MOVLB  0
0D96:  RCALL  0758
0D98:  MOVFF  01,1CD
....................    total=reg_h; 
0D9C:  MOVLB  1
0D9E:  CLRF   xCF
0DA0:  MOVFF  1CC,1CE
....................    total=(total<<8)|reg_l; 
0DA4:  MOVFF  1CE,1D1
0DA8:  CLRF   xD0
0DAA:  MOVF   xD0,W
0DAC:  IORWF  xCD,W
0DAE:  MOVWF  xCE
0DB0:  MOVFF  1D1,1CF
....................    entraront=total; 
0DB4:  MOVFF  1CF,8B
0DB8:  MOVFF  1CE,8A
....................    enable_interrupts(GLOBAL); 
0DBC:  MOVLW  C0
0DBE:  IORWF  FF2,F
0DC0:  MOVLB  0
0DC2:  GOTO   30A0 (RETURN)
.................... } 
....................  
.................... void salieron_total(){//Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0DC6:  BCF    FF2.6
0DC8:  BCF    FF2.7
0DCA:  BTFSC  FF2.7
0DCC:  BRA    0DC8
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0DCE:  MOVLB  1
0DD0:  CLRF   xCC
0DD2:  CLRF   xCD
0DD4:  CLRF   xCF
0DD6:  CLRF   xCE
....................     
....................    reg_h=read_ext_eeprom(3); 
0DD8:  CLRF   xD1
0DDA:  MOVLW  03
0DDC:  MOVWF  xD0
0DDE:  MOVLB  0
0DE0:  RCALL  0758
0DE2:  MOVFF  01,1CC
....................    reg_l=read_ext_eeprom(4); 
0DE6:  MOVLB  1
0DE8:  CLRF   xD1
0DEA:  MOVLW  04
0DEC:  MOVWF  xD0
0DEE:  MOVLB  0
0DF0:  RCALL  0758
0DF2:  MOVFF  01,1CD
....................    total=reg_h; 
0DF6:  MOVLB  1
0DF8:  CLRF   xCF
0DFA:  MOVFF  1CC,1CE
....................    total=(total<<8)|reg_l; 
0DFE:  MOVFF  1CE,1D1
0E02:  CLRF   xD0
0E04:  MOVF   xD0,W
0E06:  IORWF  xCD,W
0E08:  MOVWF  xCE
0E0A:  MOVFF  1D1,1CF
....................    salieront=total; 
0E0E:  MOVFF  1CF,8D
0E12:  MOVFF  1CE,8C
....................    enable_interrupts(GLOBAL); 
0E16:  MOVLW  C0
0E18:  IORWF  FF2,F
0E1A:  MOVLB  0
0E1C:  GOTO   30A4 (RETURN)
.................... } 
....................  
.................... void graba_conta2(){//Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
069E:  BCF    FF2.6
06A0:  BCF    FF2.7
06A2:  BTFSC  FF2.7
06A4:  BRA    06A0
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
06A6:  MOVLB  1
06A8:  CLRF   xCC
06AA:  CLRF   xCD
06AC:  CLRF   xCF
06AE:  CLRF   xCE
....................    totalc=0; 
06B0:  CLRF   xCF
06B2:  CLRF   xCE
....................    reg_lc=0; 
06B4:  CLRF   xCD
....................    reg_hc=0; 
06B6:  CLRF   xCC
....................     
....................    totalc=salian; 
06B8:  MOVFF  3D,1CF
06BC:  MOVFF  3C,1CE
....................    reg_lc=totalc; 
06C0:  MOVFF  1CE,1CD
....................    reg_hc=totalc>>8; 
06C4:  MOVFF  1CF,1CC
....................    write_ext_eeprom(20,reg_hc); 
06C8:  CLRF   xD1
06CA:  MOVLW  14
06CC:  MOVWF  xD0
06CE:  MOVFF  1CC,1D2
06D2:  MOVLB  0
06D4:  RCALL  0598
....................    write_ext_eeprom(21,reg_lc); 
06D6:  MOVLB  1
06D8:  CLRF   xD1
06DA:  MOVLW  15
06DC:  MOVWF  xD0
06DE:  MOVFF  1CD,1D2
06E2:  MOVLB  0
06E4:  RCALL  0598
....................    enable_interrupts(GLOBAL); 
06E6:  MOVLW  C0
06E8:  IORWF  FF2,F
06EA:  RETURN 0
.................... } 
....................  
.................... void leer_conta2(){//Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
0800:  BCF    FF2.6
0802:  BCF    FF2.7
0804:  BTFSC  FF2.7
0806:  BRA    0802
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
0808:  MOVLB  1
080A:  CLRF   xCC
080C:  CLRF   xCD
080E:  CLRF   xCF
0810:  CLRF   xCE
....................     
....................    reg_hc=read_ext_eeprom(20); 
0812:  CLRF   xD1
0814:  MOVLW  14
0816:  MOVWF  xD0
0818:  MOVLB  0
081A:  RCALL  0758
081C:  MOVFF  01,1CC
....................    reg_lc=read_ext_eeprom(21); 
0820:  MOVLB  1
0822:  CLRF   xD1
0824:  MOVLW  15
0826:  MOVWF  xD0
0828:  MOVLB  0
082A:  RCALL  0758
082C:  MOVFF  01,1CD
....................    totalc=reg_hc; 
0830:  MOVLB  1
0832:  CLRF   xCF
0834:  MOVFF  1CC,1CE
....................    totalc=totalc<<8; 
0838:  MOVFF  1CE,1CF
083C:  CLRF   xCE
....................    totalc=totalc|reg_lc; 
083E:  MOVF   xCD,W
0840:  IORWF  xCE,F
....................    salian=totalc; 
0842:  MOVFF  1CF,3D
0846:  MOVFF  1CE,3C
....................    enable_interrupts(GLOBAL); 
084A:  MOVLW  C0
084C:  IORWF  FF2,F
084E:  MOVLB  0
0850:  RETURN 0
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) { 
*
0E42:  MOVF   FD0,W
0E44:  ANDLW  0F
0E46:  BTFSS  FD0.4
0E48:  MOVLW  00
0E4A:  BSF    FD0.0
0E4C:  BSF    FD0.1
0E4E:  BSF    FD0.4
0E50:  BSF    FD8.3
0E52:  BSF    FD8.4
0E54:  XORLW  07
0E56:  BZ    0E66
0E58:  XORLW  08
0E5A:  BZ    0E68
0E5C:  XORLW  01
0E5E:  BZ    0E74
0E60:  XORLW  02
0E62:  BZ    0E76
0E64:  BRA    0E76
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          break;} 
0E66:  BRA    0E76
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          fprintf(monitor,"SERIALTEST\r\n"); 
0E68:  MOVLW  E0
0E6A:  MOVWF  FF6
0E6C:  MOVLW  03
0E6E:  MOVWF  FF7
0E70:  RCALL  0E20
....................          //fprintf(monitor,"0\r"); 
....................          break;} 
0E72:  BRA    0E76
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          break; 
0E74:  BRA    0E76
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          break; 
....................       }//END MODO 
....................    } 
0E76:  GOTO   3182 (RETURN)
.................... } 
....................  
....................  
.................... int evaluar_string(char *command[]){ 
*
1016:  MOVLB  1
1018:  CLRF   xCE
....................   // fprintf(monitor,"<"); 
....................   // fprintf(monitor,"%s",command); 
....................   // fprintf(monitor,">"); 
....................    int conteo_command=0; 
....................    int iresult; 
....................    while(conteo_command<=10){ 
101A:  MOVF   xCE,W
101C:  SUBLW  0A
101E:  BNC   1066
....................    //lcd_gotoxy(9,4); 
....................    //printf(lcd_putc,"%c%c%c",command[0],command[1],command[8]);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................    iresult=strcoll(textosearch[conteo_command],command); 
1020:  CLRF   03
1022:  MOVFF  1CE,02
1026:  BCF    FD8.0
1028:  RLCF   02,F
102A:  RLCF   03,F
102C:  MOVF   02,W
102E:  ADDLW  ED
1030:  MOVWF  FE9
1032:  MOVLW  00
1034:  ADDWFC 03,W
1036:  MOVWF  FEA
1038:  MOVFF  FEC,1D1
103C:  MOVF   FED,F
103E:  MOVFF  FEF,1D0
1042:  MOVFF  1D1,1D3
1046:  MOVFF  1D0,1D2
104A:  MOVFF  1CD,1D5
104E:  MOVFF  1CC,1D4
1052:  MOVLB  0
1054:  BRA    0F9C
1056:  MOVFF  01,1CF
....................   // fprintf(monitor,"%d",iresult); 
....................   // fprintf(monitor,"%s",textosearch[conteo_command]); 
....................    if(iresult==0){ 
105A:  MOVLB  1
105C:  MOVF   xCF,F
105E:  BNZ   1062
....................   // fprintf(monitor,"Encontrado"); 
....................    //return (conteo_command); 
....................    break; 
1060:  BRA    1066
....................    } 
....................    //if(conteo_command==5){ 
....................       
....................  
....................    //} 
....................    
....................    conteo_command++; 
1062:  INCF   xCE,F
1064:  BRA    101A
....................    } 
....................       if(XX[1]=='A' && XX[2]=='S' && XX[3]=='A' && XX[4]=='J' && XX[5]=='E' && XX[6]=='R' && XX[7]=='O' && XX[8]=='S') 
1066:  MOVF   x8E,W
1068:  SUBLW  41
106A:  BNZ   109A
106C:  MOVF   x8F,W
106E:  SUBLW  53
1070:  BNZ   109A
1072:  MOVF   x90,W
1074:  SUBLW  41
1076:  BNZ   109A
1078:  MOVF   x91,W
107A:  SUBLW  4A
107C:  BNZ   109A
107E:  MOVF   x92,W
1080:  SUBLW  45
1082:  BNZ   109A
1084:  MOVF   x93,W
1086:  SUBLW  52
1088:  BNZ   109A
108A:  MOVF   x94,W
108C:  SUBLW  4F
108E:  BNZ   109A
1090:  MOVF   x95,W
1092:  SUBLW  53
1094:  BNZ   109A
....................       { 
....................          conteo_command = 5; 
1096:  MOVLW  05
1098:  MOVWF  xCE
....................         // lcd_gotoxy(9,2); 
....................         // printf(lcd_putc,"C=5"); 
....................       } 
....................      
....................    return conteo_command; 
109A:  MOVFF  1CE,01
109E:  MOVLB  0
10A0:  GOTO   32D0 (RETURN)
....................  
....................    } 
....................     

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
