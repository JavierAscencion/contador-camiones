CCS PCH C Compiler, Version 5.025, 24934               09-may.-22 11:27

               Filename:   D:\PROYECTOS\TRANSPORTE\ENCAPSULADO NUEVO\Contadores_V5.02\MASTER\CONTADOR_V5.02.lst

               ROM used:   13326 bytes (41%)
                           Largest free fragment is 19438
               RAM used:   462 (30%) at main() level
                           487 (32%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2BBE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0230
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   010A
006C:  BTFSS  FA0.1
006E:  GOTO   0078
0072:  BTFSC  FA1.1
0074:  GOTO   01BE
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVFF  15,FF5
00B2:  MOVFF  16,FF6
00B6:  MOVFF  17,FF7
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... //2021/05/13 *V5.01 Se recalcula frecuencia de IR 
.................... //2020/03/31 *V4.A1 Se agrega etiqueta para identificar por LCD si hay comunicacion entre los postes 
.................... //2020/02/28 *V04.A Se modifica codigo para evitar que postes cuenten solos 
.................... //2019/12/09 Se modifica la forma de contar con sensores bloqueados 
.................... //2019/11/19 Se modifica codigo para detectar una recepcion serial de dato poste posterior erronea, asi como identificar error de conexion tambien, 
.................... //           Se quita funcion de boton silenciador que nunca se uso 
.................... //2019/11/14 Se modifica la escucha de la cuenta del poste secundario, se cambia limite a 20 para dato posterior recibido. 
.................... //D01.2 2019/03/28 Se agrega cambios para confirmar reset a nuevo GSM y enter al final de envio de cuenta 
.................... //                 Se discriminan los primneros 2 caracteres de validacion serial 
.................... // ultima modificacion; 
.................... /* 
.................... VER.  FECHA 
.................... D02.6 2019/12/09 Cambia la forma de contar 
.................... - Poste de datos esta identificado como 1, el esclavo como 2 
.................... */ 
....................  
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00C6:  CLRF   FF7
00C8:  ADDLW  D6
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  RETURN 0
00D6:  DATA 28,0C
00D8:  DATA 01,06
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 42,4F
00EC:  DATA 52,52
00EE:  DATA 41,52
00F0:  DATA 5F,41
00F2:  DATA 4C,4C
00F4:  DATA 0D,00
00F6:  CLRF   FF7
00F8:  ADDLW  06
00FA:  MOVWF  FF6
00FC:  MOVLW  01
00FE:  ADDWFC FF7,F
0100:  TBLRD*+
0102:  MOVF   FF5,W
0104:  RETURN 0
0106:  DATA 3A,2F
0108:  DATA 00,00
*
028A:  DATA 0C,42
028C:  DATA 4F,52
028E:  DATA 52,41
0290:  DATA 52,5F
0292:  DATA 41,4C
0294:  DATA 4C,00
0296:  DATA 42,4F
0298:  DATA 52,52
029A:  DATA 41,52
029C:  DATA 5F,41
029E:  DATA 4C,4C
02A0:  DATA 0D,00
02A2:  DATA 52,45
02A4:  DATA 53,45
02A6:  DATA 54,5F
02A8:  DATA 4F,4B
02AA:  DATA 0D,0A
02AC:  DATA 00,00
02AE:  DATA 52,45
02B0:  DATA 53,45
02B2:  DATA 54,5F
02B4:  DATA 4F,4B
02B6:  DATA 0D,0A
02B8:  DATA 00,00
02BA:  DATA 42,4F
02BC:  DATA 52,52
02BE:  DATA 41,52
02C0:  DATA 5F,41
02C2:  DATA 4C,4C
02C4:  DATA 0D,00
02C6:  DATA 43,32
02C8:  DATA 4F,4B
02CA:  DATA 00,00
02CC:  DATA 43,31
02CE:  DATA 4F,4B
02D0:  DATA 00,00
02D2:  DATA 53,45
02D4:  DATA 52,49
02D6:  DATA 41,4C
02D8:  DATA 5F,54
02DA:  DATA 4F,4B
02DC:  DATA 0D,00
02DE:  DATA 43,32
02E0:  DATA 4F,4B
02E2:  DATA 00,00
02E4:  DATA 53,75
02E6:  DATA 62,32
02E8:  DATA 00,00
02EA:  DATA 63,3D
02EC:  DATA 30,00
02EE:  DATA 20,20
02F0:  DATA 20,20
02F2:  DATA 00,00
02F4:  DATA 20,20
02F6:  DATA 20,20
02F8:  DATA 00,00
02FA:  DATA 20,20
02FC:  DATA 20,20
02FE:  DATA 00,00
0300:  DATA 42,4C
0302:  DATA 00,00
0304:  DATA 42,4C
0306:  DATA 00,00
0308:  DATA 42,4C
030A:  DATA 00,00
030C:  DATA 20,20
030E:  DATA 00,00
0310:  DATA 53,4F
0312:  DATA 4C,49
0314:  DATA 43,49
0316:  DATA 54,41
0318:  DATA 44,4F
031A:  DATA 0D,00
031C:  DATA 50,41
031E:  DATA 53,41
0320:  DATA 4A,45
0322:  DATA 52,4F
0324:  DATA 53,3A
0326:  DATA 0D,00
0328:  DATA 53,32
032A:  DATA 3A,25
032C:  DATA 4C,64
032E:  DATA 20,00
0330:  DATA 42,32
0332:  DATA 3A,25
0334:  DATA 4C,64
0336:  DATA 20,00
0338:  DATA 41,43
033A:  DATA 43,2B
033C:  DATA 30,31
033E:  DATA 3A,25
0340:  DATA 30,34
0342:  DATA 4C,75
0344:  DATA 2C,25
0346:  DATA 30,34
0348:  DATA 4C,75
034A:  DATA 2C,25
034C:  DATA 30,34
034E:  DATA 4C,75
0350:  DATA 2C,25
0352:  DATA 30,33
0354:  DATA 4C,75
0356:  DATA 2C,25
0358:  DATA 30,33
035A:  DATA 4C,75
035C:  DATA 2C,25
035E:  DATA 30,32
0360:  DATA 75,2C
0362:  DATA 0D,0A
0364:  DATA 00,00
0366:  DATA 41,43
0368:  DATA 43,2B
036A:  DATA 30,31
036C:  DATA 3A,25
036E:  DATA 30,34
0370:  DATA 4C,75
0372:  DATA 2C,25
0374:  DATA 30,34
0376:  DATA 4C,75
0378:  DATA 2C,44
037A:  DATA 45,53
037C:  DATA 43,2C
037E:  DATA 25,30
0380:  DATA 33,4C
0382:  DATA 75,2C
0384:  DATA 30,30
0386:  DATA 30,2C
0388:  DATA 25,30
038A:  DATA 32,75
038C:  DATA 2C,0D
038E:  DATA 0A,00
0390:  DATA 44,45
0392:  DATA 53,43
0394:  DATA 00,00
0396:  DATA 0C,00
0398:  DATA 20,00
039A:  DATA 20,00
039C:  DATA 20,00
039E:  DATA 20,00
03A0:  DATA 20,00
03A2:  DATA 20,00
03A4:  DATA 20,00
03A6:  DATA 20,00
03A8:  DATA 20,00
03AA:  DATA 20,00
03AC:  DATA 20,00
03AE:  DATA 20,00
03B0:  DATA 6D,65
03B2:  DATA 6D,6F
03B4:  DATA 72,79
03B6:  DATA 3A,25
03B8:  DATA 73,0D
03BA:  DATA 00,00
03BC:  DATA 53,31
03BE:  DATA 3A,25
03C0:  DATA 4C,64
03C2:  DATA 20,00
03C4:  DATA 42,31
03C6:  DATA 3A,25
03C8:  DATA 4C,64
03CA:  DATA 20,00
03CC:  DATA 53,32
03CE:  DATA 3A,25
03D0:  DATA 4C,64
03D2:  DATA 20,00
03D4:  DATA 42,32
03D6:  DATA 3A,25
03D8:  DATA 4C,64
03DA:  DATA 20,00
03DC:  DATA 53,31
03DE:  DATA 3A,20
03E0:  DATA 20,20
03E2:  DATA 20,00
03E4:  DATA 42,31
03E6:  DATA 3A,20
03E8:  DATA 20,20
03EA:  DATA 20,00
03EC:  DATA 53,32
03EE:  DATA 3A,25
03F0:  DATA 4C,64
03F2:  DATA 20,00
03F4:  DATA 42,32
03F6:  DATA 3A,25
03F8:  DATA 4C,64
03FA:  DATA 20,00
03FC:  DATA 53,45
03FE:  DATA 52,49
0400:  DATA 41,4C
0402:  DATA 54,45
0404:  DATA 53,54
0406:  DATA 0D,0A
0408:  DATA 00,00
*
0920:  TBLRD*+
0922:  MOVFF  FF6,1CF
0926:  MOVFF  FF7,1D0
092A:  MOVFF  FF5,1D7
092E:  RCALL  08C0
0930:  MOVFF  1CF,FF6
0934:  MOVFF  1D0,FF7
0938:  MOVLB  1
093A:  DECFSZ xCE,F
093C:  BRA    0940
093E:  BRA    0944
0940:  MOVLB  0
0942:  BRA    0920
0944:  MOVLB  0
0946:  RETURN 0
0948:  MOVFF  FEA,1D6
094C:  MOVFF  FE9,1D5
0950:  MOVLB  1
0952:  BTFSS  xCF.7
0954:  BRA    0966
0956:  BSF    xD5.7
0958:  BTFSS  xD5.4
095A:  INCF   xD5,F
095C:  COMF   xCE,F
095E:  COMF   xCF,F
0960:  INCF   xCE,F
0962:  BTFSC  FD8.2
0964:  INCF   xCF,F
0966:  SWAPF  xCF,W
0968:  IORLW  F0
096A:  MOVWF  xD1
096C:  ADDWF  xD1,F
096E:  ADDLW  E2
0970:  MOVWF  xD2
0972:  ADDLW  32
0974:  MOVWF  xD4
0976:  MOVF   xCF,W
0978:  ANDLW  0F
097A:  ADDWF  xD2,F
097C:  ADDWF  xD2,F
097E:  ADDWF  xD4,F
0980:  ADDLW  E9
0982:  MOVWF  xD3
0984:  ADDWF  xD3,F
0986:  ADDWF  xD3,F
0988:  SWAPF  xCE,W
098A:  ANDLW  0F
098C:  ADDWF  xD3,F
098E:  ADDWF  xD4,F
0990:  RLCF   xD3,F
0992:  RLCF   xD4,F
0994:  COMF   xD4,F
0996:  RLCF   xD4,F
0998:  MOVF   xCE,W
099A:  ANDLW  0F
099C:  ADDWF  xD4,F
099E:  RLCF   xD1,F
09A0:  MOVLW  07
09A2:  MOVWF  xD0
09A4:  MOVLW  0A
09A6:  DECF   xD3,F
09A8:  ADDWF  xD4,F
09AA:  BNC   09A6
09AC:  DECF   xD2,F
09AE:  ADDWF  xD3,F
09B0:  BNC   09AC
09B2:  DECF   xD1,F
09B4:  ADDWF  xD2,F
09B6:  BNC   09B2
09B8:  DECF   xD0,F
09BA:  ADDWF  xD1,F
09BC:  BNC   09B8
09BE:  MOVLW  01
09C0:  MOVWF  FEA
09C2:  MOVLW  D0
09C4:  MOVWF  FE9
09C6:  MOVLW  07
09C8:  ANDWF  xD5,W
09CA:  BCF    xD5.6
09CC:  MOVF   FED,F
09CE:  ANDWF  xD5,W
09D0:  BNZ   09E0
09D2:  BTFSC  xD5.4
09D4:  MOVF   FEE,F
09D6:  BTFSC  xD5.4
09D8:  BRA    09E0
09DA:  MOVLW  20
09DC:  MOVWF  00
09DE:  BRA    0A20
09E0:  ADDWF  FE9,F
09E2:  MOVLW  00
09E4:  ADDWFC FEA,F
09E6:  MOVF   FE9,W
09E8:  SUBLW  D4
09EA:  BNZ   09F2
09EC:  DECFSZ FEA,W
09EE:  BRA    09F2
09F0:  BSF    xD5.6
09F2:  MOVF   FEF,W
09F4:  MOVWF  00
09F6:  BNZ   0A08
09F8:  BTFSC  xD5.6
09FA:  BRA    0A08
09FC:  BTFSC  xD5.4
09FE:  BRA    0A3A
0A00:  BTFSC  xD5.3
0A02:  BRA    0A08
0A04:  MOVLW  20
0A06:  BRA    0A1E
0A08:  BTFSS  xD5.7
0A0A:  BRA    0A18
0A0C:  MOVLW  2D
0A0E:  MOVWF  00
0A10:  MOVF   FED,W
0A12:  BCF    xD5.6
0A14:  BCF    xD5.7
0A16:  BRA    0A20
0A18:  BSF    xD5.3
0A1A:  BCF    xD5.4
0A1C:  MOVLW  30
0A1E:  ADDWF  00,F
0A20:  MOVFF  FEA,1CF
0A24:  MOVFF  FE9,1CE
0A28:  MOVFF  00,1D7
0A2C:  MOVLB  0
0A2E:  RCALL  08C0
0A30:  MOVFF  1CF,FEA
0A34:  MOVFF  1CE,FE9
0A38:  MOVLB  1
0A3A:  MOVF   FEE,W
0A3C:  BTFSS  xD5.6
0A3E:  BRA    09E6
0A40:  MOVLB  0
0A42:  RETURN 0
0A44:  TBLRD*+
0A46:  MOVF   FF5,F
0A48:  BZ    0A62
0A4A:  MOVFF  FF6,1CD
0A4E:  MOVFF  FF7,1CE
0A52:  MOVFF  FF5,1D7
0A56:  RCALL  08C0
0A58:  MOVFF  1CD,FF6
0A5C:  MOVFF  1CE,FF7
0A60:  BRA    0A44
0A62:  RETURN 0
*
0E3C:  TBLRD*+
0E3E:  MOVF   FF5,F
0E40:  BZ    0E5C
0E42:  MOVFF  FF6,1CF
0E46:  MOVFF  FF7,1D0
0E4A:  MOVF   FF5,W
0E4C:  BTFSS  F9E.4
0E4E:  BRA    0E4C
0E50:  MOVWF  FAD
0E52:  MOVFF  1CF,FF6
0E56:  MOVFF  1D0,FF7
0E5A:  BRA    0E3C
0E5C:  RETURN 0
*
10C0:  MOVLB  1
10C2:  MOVF   xD4,W
10C4:  CLRF   01
10C6:  SUBWF  xD3,W
10C8:  BC    10D0
10CA:  MOVFF  1D3,00
10CE:  BRA    10E8
10D0:  CLRF   00
10D2:  MOVLW  08
10D4:  MOVWF  xD5
10D6:  RLCF   xD3,F
10D8:  RLCF   00,F
10DA:  MOVF   xD4,W
10DC:  SUBWF  00,W
10DE:  BTFSC  FD8.0
10E0:  MOVWF  00
10E2:  RLCF   01,F
10E4:  DECFSZ xD5,F
10E6:  BRA    10D6
10E8:  MOVLB  0
10EA:  RETURN 0
10EC:  MOVLW  20
10EE:  MOVLB  1
10F0:  BTFSS  xCE.4
10F2:  MOVLW  30
10F4:  MOVWF  xCF
10F6:  MOVFF  1CD,00
10FA:  BTFSS  xCD.7
10FC:  BRA    110E
10FE:  COMF   00,F
1100:  INCF   00,F
1102:  MOVFF  00,1CD
1106:  MOVLW  2D
1108:  MOVWF  xCF
110A:  BSF    xCE.7
110C:  BSF    xCE.0
110E:  MOVF   01,W
1110:  MOVFF  1CD,1D3
1114:  MOVLW  64
1116:  MOVWF  xD4
1118:  MOVLB  0
111A:  RCALL  10C0
111C:  MOVFF  00,1CD
1120:  MOVLW  30
1122:  ADDWF  01,W
1124:  MOVLB  1
1126:  MOVWF  xD0
1128:  MOVFF  1CD,1D3
112C:  MOVLW  0A
112E:  MOVWF  xD4
1130:  MOVLB  0
1132:  RCALL  10C0
1134:  MOVLW  30
1136:  ADDWF  00,W
1138:  MOVLB  1
113A:  MOVWF  xD2
113C:  MOVLW  30
113E:  ADDWF  01,W
1140:  MOVWF  xD1
1142:  MOVFF  1CF,00
1146:  MOVLW  30
1148:  SUBWF  xD0,W
114A:  BZ    1154
114C:  BSF    xCE.1
114E:  BTFSC  xCE.7
1150:  BSF    xCE.2
1152:  BRA    1178
1154:  MOVFF  1CF,1D0
1158:  MOVLW  20
115A:  MOVWF  xCF
115C:  MOVLW  30
115E:  SUBWF  xD1,W
1160:  BZ    116A
1162:  BSF    xCE.0
1164:  BTFSC  xCE.7
1166:  BSF    xCE.1
1168:  BRA    1178
116A:  BTFSS  FD8.2
116C:  BSF    xCE.0
116E:  BNZ   1178
1170:  MOVFF  1D0,1D1
1174:  MOVLW  20
1176:  MOVWF  xD0
1178:  BTFSC  xCE.2
117A:  BRA    1186
117C:  BTFSC  xCE.1
117E:  BRA    1190
1180:  BTFSC  xCE.0
1182:  BRA    119A
1184:  BRA    11A4
1186:  MOVFF  1CF,1D7
118A:  MOVLB  0
118C:  CALL   08C0
1190:  MOVFF  1D0,1D7
1194:  MOVLB  0
1196:  CALL   08C0
119A:  MOVFF  1D1,1D7
119E:  MOVLB  0
11A0:  CALL   08C0
11A4:  MOVFF  1D2,1D7
11A8:  MOVLB  0
11AA:  CALL   08C0
11AE:  RETURN 0
*
11FE:  TBLRD*+
1200:  MOVF   FF5,F
1202:  BZ    121C
1204:  MOVFF  FF6,1CD
1208:  MOVFF  FF7,1CE
120C:  MOVFF  FF5,1D6
1210:  RCALL  11B0
1212:  MOVFF  1CD,FF6
1216:  MOVFF  1CE,FF7
121A:  BRA    11FE
121C:  RETURN 0
*
128C:  TSTFSZ 01
128E:  BRA    1296
1290:  TSTFSZ 02
1292:  BRA    1298
1294:  BRA    12A4
1296:  INCF   02,F
1298:  MOVFF  00,FEE
129C:  DECFSZ 01,F
129E:  BRA    1298
12A0:  DECFSZ 02,F
12A2:  BRA    1298
12A4:  RETURN 0
*
1952:  TBLRD*+
1954:  MOVFF  FF6,1CE
1958:  MOVFF  FF7,1CF
195C:  MOVFF  FF5,1D6
1960:  RCALL  11B0
1962:  MOVFF  1CE,FF6
1966:  MOVFF  1CF,FF7
196A:  MOVLB  1
196C:  DECFSZ xCD,F
196E:  BRA    1972
1970:  BRA    1976
1972:  MOVLB  0
1974:  BRA    1952
1976:  MOVLB  0
1978:  RETURN 0
197A:  MOVFF  FEA,1D5
197E:  MOVFF  FE9,1D4
1982:  MOVLB  1
1984:  SWAPF  xCE,W
1986:  IORLW  F0
1988:  MOVWF  xD0
198A:  ADDWF  xD0,F
198C:  ADDLW  E2
198E:  MOVWF  xD1
1990:  ADDLW  32
1992:  MOVWF  xD3
1994:  MOVF   xCE,W
1996:  ANDLW  0F
1998:  ADDWF  xD1,F
199A:  ADDWF  xD1,F
199C:  ADDWF  xD3,F
199E:  ADDLW  E9
19A0:  MOVWF  xD2
19A2:  ADDWF  xD2,F
19A4:  ADDWF  xD2,F
19A6:  SWAPF  xCD,W
19A8:  ANDLW  0F
19AA:  ADDWF  xD2,F
19AC:  ADDWF  xD3,F
19AE:  RLCF   xD2,F
19B0:  RLCF   xD3,F
19B2:  COMF   xD3,F
19B4:  RLCF   xD3,F
19B6:  MOVF   xCD,W
19B8:  ANDLW  0F
19BA:  ADDWF  xD3,F
19BC:  RLCF   xD0,F
19BE:  MOVLW  07
19C0:  MOVWF  xCF
19C2:  MOVLW  0A
19C4:  DECF   xD2,F
19C6:  ADDWF  xD3,F
19C8:  BNC   19C4
19CA:  DECF   xD1,F
19CC:  ADDWF  xD2,F
19CE:  BNC   19CA
19D0:  DECF   xD0,F
19D2:  ADDWF  xD1,F
19D4:  BNC   19D0
19D6:  DECF   xCF,F
19D8:  ADDWF  xD0,F
19DA:  BNC   19D6
19DC:  MOVLW  01
19DE:  MOVWF  FEA
19E0:  MOVLW  CF
19E2:  MOVWF  FE9
19E4:  MOVLW  07
19E6:  ANDWF  xD4,W
19E8:  BCF    xD4.6
19EA:  ADDWF  FE9,F
19EC:  MOVLW  00
19EE:  ADDWFC FEA,F
19F0:  MOVF   FE9,W
19F2:  SUBLW  D3
19F4:  BNZ   19FC
19F6:  DECFSZ FEA,W
19F8:  BRA    19FC
19FA:  BSF    xD4.6
19FC:  MOVF   FEF,W
19FE:  MOVWF  00
1A00:  BNZ   1A12
1A02:  BTFSC  xD4.6
1A04:  BRA    1A12
1A06:  BTFSC  xD4.4
1A08:  BRA    1A36
1A0A:  BTFSC  xD4.3
1A0C:  BRA    1A12
1A0E:  MOVLW  20
1A10:  BRA    1A18
1A12:  BSF    xD4.3
1A14:  BCF    xD4.4
1A16:  MOVLW  30
1A18:  ADDWF  00,F
1A1A:  MOVFF  FEA,1CE
1A1E:  MOVFF  FE9,1CD
1A22:  MOVFF  00,1D6
1A26:  MOVLB  0
1A28:  CALL   11B0
1A2C:  MOVFF  1CE,FEA
1A30:  MOVFF  1CD,FE9
1A34:  MOVLB  1
1A36:  MOVF   FEE,W
1A38:  BTFSS  xD4.6
1A3A:  BRA    19F0
1A3C:  MOVLB  0
1A3E:  RETURN 0
1A40:  MOVF   01,W
1A42:  MOVFF  1CD,1D3
1A46:  MOVLW  64
1A48:  MOVLB  1
1A4A:  MOVWF  xD4
1A4C:  MOVLB  0
1A4E:  CALL   10C0
1A52:  MOVFF  00,1CD
1A56:  MOVF   01,W
1A58:  MOVLW  30
1A5A:  BNZ   1A6C
1A5C:  MOVLB  1
1A5E:  BTFSS  xCE.1
1A60:  BRA    1A82
1A62:  BTFSC  xCE.3
1A64:  BRA    1A82
1A66:  BTFSC  xCE.4
1A68:  MOVLW  20
1A6A:  BRA    1A74
1A6C:  MOVLB  1
1A6E:  BCF    xCE.3
1A70:  BCF    xCE.4
1A72:  BSF    xCE.0
1A74:  ADDWF  01,F
1A76:  MOVFF  01,1D6
1A7A:  MOVLB  0
1A7C:  CALL   11B0
1A80:  MOVLB  1
1A82:  MOVFF  1CD,1D3
1A86:  MOVLW  0A
1A88:  MOVWF  xD4
1A8A:  MOVLB  0
1A8C:  CALL   10C0
1A90:  MOVFF  00,1CD
1A94:  MOVF   01,W
1A96:  MOVLW  30
1A98:  BNZ   1AAA
1A9A:  MOVLB  1
1A9C:  BTFSC  xCE.3
1A9E:  BRA    1AB6
1AA0:  BTFSS  xCE.0
1AA2:  BRA    1AB6
1AA4:  BTFSC  xCE.4
1AA6:  MOVLW  20
1AA8:  MOVLB  0
1AAA:  ADDWF  01,F
1AAC:  MOVFF  01,1D6
1AB0:  CALL   11B0
1AB4:  MOVLB  1
1AB6:  MOVLW  30
1AB8:  ADDWF  xCD,F
1ABA:  MOVFF  1CD,1D6
1ABE:  MOVLB  0
1AC0:  CALL   11B0
1AC4:  RETURN 0
*
2216:  ADDWF  FE8,W
2218:  CLRF   FF7
221A:  RLCF   FF7,F
221C:  ADDLW  31
221E:  MOVWF  FF6
2220:  MOVLW  22
2222:  ADDWFC FF7,F
2224:  TBLRD*-
2226:  MOVF   FF5,W
2228:  MOVWF  FFA
222A:  TBLRD*
222C:  MOVF   FF5,W
222E:  MOVWF  FF9
2230:  DATA E6,21
2232:  DATA 10,22
2234:  DATA 10,22
2236:  DATA 10,22
2238:  DATA E8,21
223A:  DATA F8,21
223C:  DATA FC,21
223E:  DATA 10,22
2240:  DATA 10,22
2242:  DATA 10,22
2244:  DATA FE,21
2246:  DATA 0E,22
*
251E:  ADDWF  FE8,W
2520:  CLRF   FF7
2522:  RLCF   FF7,F
2524:  ADDLW  39
2526:  MOVWF  FF6
2528:  MOVLW  25
252A:  ADDWFC FF7,F
252C:  TBLRD*-
252E:  MOVF   FF5,W
2530:  MOVWF  FFA
2532:  TBLRD*
2534:  MOVF   FF5,W
2536:  MOVWF  FF9
2538:  DATA EE,24
253A:  DATA 18,25
253C:  DATA 18,25
253E:  DATA 18,25
2540:  DATA F0,24
2542:  DATA 00,25
2544:  DATA 04,25
2546:  DATA 18,25
2548:  DATA 18,25
254A:  DATA 18,25
254C:  DATA 06,25
254E:  DATA 16,25
*
2828:  ADDWF  FE8,W
282A:  CLRF   FF7
282C:  RLCF   FF7,F
282E:  ADDLW  43
2830:  MOVWF  FF6
2832:  MOVLW  28
2834:  ADDWFC FF7,F
2836:  TBLRD*-
2838:  MOVF   FF5,W
283A:  MOVWF  FFA
283C:  TBLRD*
283E:  MOVF   FF5,W
2840:  MOVWF  FF9
2842:  DATA F8,27
2844:  DATA 22,28
2846:  DATA 22,28
2848:  DATA 22,28
284A:  DATA FA,27
284C:  DATA 0A,28
284E:  DATA 0E,28
2850:  DATA 22,28
2852:  DATA 22,28
2854:  DATA 22,28
2856:  DATA 10,28
2858:  DATA 20,28
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0FB8:  MOVLB  1
0FBA:  MOVFF  1D3,FE9
0FBE:  MOVFF  1D4,FEA
0FC2:  MOVFF  FEF,1D7
0FC6:  MOVFF  1D6,03
0FCA:  MOVFF  1D5,FE9
0FCE:  MOVFF  1D6,FEA
0FD2:  MOVF   FEF,W
0FD4:  SUBWF  xD7,W
0FD6:  BNZ   1002
....................       if (*s1 == '\0') 
0FD8:  MOVFF  1D4,03
0FDC:  MOVFF  1D3,FE9
0FE0:  MOVFF  03,FEA
0FE4:  MOVF   FEF,F
0FE6:  BNZ   0FEE
....................          return(0); 
0FE8:  MOVLW  00
0FEA:  MOVWF  01
0FEC:  BRA    102C
0FEE:  MOVFF  1D4,03
0FF2:  MOVF   xD3,W
0FF4:  INCF   xD3,F
0FF6:  BTFSC  FD8.2
0FF8:  INCF   xD4,F
0FFA:  INCF   xD5,F
0FFC:  BTFSC  FD8.2
0FFE:  INCF   xD6,F
1000:  BRA    0FBA
....................    return((*s1 < *s2) ? -1: 1); 
1002:  MOVFF  1D4,03
1006:  MOVFF  1D3,FE9
100A:  MOVFF  1D4,FEA
100E:  MOVFF  FEF,1D7
1012:  MOVFF  1D6,03
1016:  MOVFF  1D5,FE9
101A:  MOVFF  1D6,FEA
101E:  MOVF   FEF,W
1020:  SUBWF  xD7,W
1022:  BC    1028
1024:  MOVLW  FF
1026:  BRA    102A
1028:  MOVLW  01
102A:  MOVWF  01
102C:  MOVLB  0
102E:  GOTO   1072 (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
1336:  MOVFF  1D7,1DB
133A:  MOVFF  1D6,1DA
133E:  MOVFF  1DB,03
1342:  MOVLB  1
1344:  MOVFF  1DA,FE9
1348:  MOVFF  1DB,FEA
134C:  MOVF   FEF,F
134E:  BZ    13A4
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
1350:  MOVFF  1D9,1DD
1354:  MOVFF  1D8,1DC
1358:  MOVFF  1DD,03
135C:  MOVFF  1DC,FE9
1360:  MOVFF  1DD,FEA
1364:  MOVF   FEF,F
1366:  BZ    1398
....................          if (*sc1 == *sc2) 
1368:  MOVFF  1DA,FE9
136C:  MOVFF  1DB,FEA
1370:  MOVFF  FEF,1DE
1374:  MOVFF  1DD,03
1378:  MOVFF  1DC,FE9
137C:  MOVFF  1DD,FEA
1380:  MOVF   FEF,W
1382:  SUBWF  xDE,W
1384:  BNZ   1390
....................             return(sc1); 
1386:  MOVFF  1DA,01
138A:  MOVFF  1DB,02
138E:  BRA    13AA
1390:  INCF   xDC,F
1392:  BTFSC  FD8.2
1394:  INCF   xDD,F
1396:  BRA    1358
1398:  INCF   xDA,F
139A:  BTFSC  FD8.2
139C:  INCF   xDB,F
139E:  MOVLB  0
13A0:  BRA    133E
13A2:  MOVLB  1
....................    return(0); 
13A4:  MOVLW  00
13A6:  MOVWF  01
13A8:  MOVWF  02
13AA:  MOVLB  0
13AC:  GOTO   1422 (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
12A6:  MOVFF  1D7,1DB
12AA:  MOVFF  1D6,1DA
12AE:  MOVFF  1DB,03
12B2:  MOVLB  1
12B4:  MOVFF  1DA,FE9
12B8:  MOVFF  1DB,FEA
12BC:  MOVF   FEF,F
12BE:  BZ    1320
....................       for (sc2 = s2; ; sc2++) 
12C0:  MOVFF  1D9,1DD
12C4:  MOVFF  1D8,1DC
....................     if (*sc2 == '\0') 
12C8:  MOVFF  1DD,03
12CC:  MOVFF  1DC,FE9
12D0:  MOVFF  1DD,FEA
12D4:  MOVF   FEF,F
12D6:  BNZ   12EC
....................        return(sc1 - s1); 
12D8:  MOVF   xD6,W
12DA:  SUBWF  xDA,W
12DC:  MOVWF  00
12DE:  MOVF   xD7,W
12E0:  SUBWFB xDB,W
12E2:  MOVWF  03
12E4:  MOVFF  00,01
12E8:  BRA    1330
12EA:  BRA    130C
....................          else if (*sc1 == *sc2) 
12EC:  MOVFF  1DA,FE9
12F0:  MOVFF  1DB,FEA
12F4:  MOVFF  FEF,1DE
12F8:  MOVFF  1DD,03
12FC:  MOVFF  1DC,FE9
1300:  MOVFF  1DD,FEA
1304:  MOVF   FEF,W
1306:  SUBWF  xDE,W
1308:  BNZ   130C
....................             break; 
130A:  BRA    1314
130C:  INCF   xDC,F
130E:  BTFSC  FD8.2
1310:  INCF   xDD,F
1312:  BRA    12C8
1314:  INCF   xDA,F
1316:  BTFSC  FD8.2
1318:  INCF   xDB,F
131A:  MOVLB  0
131C:  BRA    12AE
131E:  MOVLB  1
....................    return(sc1 - s1); 
1320:  MOVF   xD6,W
1322:  SUBWF  xDA,W
1324:  MOVWF  00
1326:  MOVF   xD7,W
1328:  SUBWFB xDB,W
132A:  MOVWF  03
132C:  MOVFF  00,01
1330:  MOVLB  0
1332:  GOTO   13E0 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
13B0:  MOVLB  1
13B2:  MOVF   xCE,W
13B4:  IORWF  xCF,W
13B6:  BZ    13C0
13B8:  MOVFF  1CF,03
13BC:  MOVF   xCE,W
13BE:  BRA    13C6
13C0:  MOVFF  1A,03
13C4:  MOVF   19,W
13C6:  MOVWF  xD2
13C8:  MOVFF  03,1D3
....................    beg += strspn(beg, s2); 
13CC:  MOVFF  1D3,1D7
13D0:  MOVFF  1D2,1D6
13D4:  MOVFF  1D1,1D9
13D8:  MOVFF  1D0,1D8
13DC:  MOVLB  0
13DE:  BRA    12A6
13E0:  MOVF   01,W
13E2:  MOVLB  1
13E4:  ADDWF  xD2,F
13E6:  MOVLW  00
13E8:  ADDWFC xD3,F
....................    if (*beg == '\0') 
13EA:  MOVFF  1D3,03
13EE:  MOVFF  1D2,FE9
13F2:  MOVFF  1D3,FEA
13F6:  MOVF   FEF,F
13F8:  BNZ   140E
....................    { 
....................       *save = ' '; 
13FA:  MOVFF  19,FE9
13FE:  MOVFF  1A,FEA
1402:  MOVLW  20
1404:  MOVWF  FEF
....................       return(0); 
1406:  MOVLW  00
1408:  MOVWF  01
140A:  MOVWF  02
140C:  BRA    145C
....................    } 
....................    end = strpbrk(beg, s2); 
140E:  MOVFF  1D3,1D7
1412:  MOVFF  1D2,1D6
1416:  MOVFF  1D1,1D9
141A:  MOVFF  1D0,1D8
141E:  MOVLB  0
1420:  BRA    1336
1422:  MOVFF  02,1D5
1426:  MOVFF  01,1D4
....................    if (*end != '\0') 
142A:  MOVFF  1D5,03
142E:  MOVLB  1
1430:  MOVFF  1D4,FE9
1434:  MOVFF  1D5,FEA
1438:  MOVF   FEF,F
143A:  BZ    144C
....................    { 
....................       *end = '\0'; 
143C:  MOVFF  1D4,FE9
1440:  MOVFF  1D5,FEA
1444:  CLRF   FEF
....................       end++; 
1446:  INCF   xD4,F
1448:  BTFSC  FD8.2
144A:  INCF   xD5,F
....................    } 
....................    save = end; 
144C:  MOVFF  1D5,1A
1450:  MOVFF  1D4,19
....................    return(beg); 
1454:  MOVFF  1D2,01
1458:  MOVFF  1D3,02
145C:  MOVLB  0
145E:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
1460:  MOVLB  1
1462:  CLRF   xD6
....................    sign = 0; 
1464:  CLRF   xD4
....................    base = 10; 
1466:  MOVLW  0A
1468:  MOVWF  xD5
....................    result = 0; 
146A:  CLRF   xD3
146C:  CLRF   xD2
146E:  CLRF   xD1
1470:  CLRF   xD0
....................  
....................    if (!s) 
1472:  MOVF   xCE,W
1474:  IORWF  xCF,W
1476:  BNZ   1482
....................       return 0; 
1478:  CLRF   00
147A:  CLRF   01
147C:  CLRF   02
147E:  CLRF   03
1480:  BRA    16F0
....................    c = s[index++]; 
1482:  MOVF   xD6,W
1484:  INCF   xD6,F
1486:  ADDWF  xCE,W
1488:  MOVWF  FE9
148A:  MOVLW  00
148C:  ADDWFC xCF,W
148E:  MOVWF  FEA
1490:  MOVFF  FEF,1D7
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1494:  MOVF   xD7,W
1496:  SUBLW  2D
1498:  BNZ   14B2
....................    { 
....................       sign = 1;         // Set the sign to negative 
149A:  MOVLW  01
149C:  MOVWF  xD4
....................       c = s[index++]; 
149E:  MOVF   xD6,W
14A0:  INCF   xD6,F
14A2:  ADDWF  xCE,W
14A4:  MOVWF  FE9
14A6:  MOVLW  00
14A8:  ADDWFC xCF,W
14AA:  MOVWF  FEA
14AC:  MOVFF  FEF,1D7
....................    } 
14B0:  BRA    14CA
....................    else if (c == '+') 
14B2:  MOVF   xD7,W
14B4:  SUBLW  2B
14B6:  BNZ   14CA
....................    { 
....................       c = s[index++]; 
14B8:  MOVF   xD6,W
14BA:  INCF   xD6,F
14BC:  ADDWF  xCE,W
14BE:  MOVWF  FE9
14C0:  MOVLW  00
14C2:  ADDWFC xCF,W
14C4:  MOVWF  FEA
14C6:  MOVFF  FEF,1D7
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
14CA:  MOVF   xD7,W
14CC:  SUBLW  2F
14CE:  BTFSC  FD8.0
14D0:  BRA    16C0
14D2:  MOVF   xD7,W
14D4:  SUBLW  39
14D6:  BTFSS  FD8.0
14D8:  BRA    16C0
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
14DA:  MOVF   xD7,W
14DC:  SUBLW  30
14DE:  BNZ   151C
14E0:  MOVF   xD6,W
14E2:  ADDWF  xCE,W
14E4:  MOVWF  FE9
14E6:  MOVLW  00
14E8:  ADDWFC xCF,W
14EA:  MOVWF  FEA
14EC:  MOVF   FEF,W
14EE:  SUBLW  78
14F0:  BZ    1504
14F2:  MOVF   xD6,W
14F4:  ADDWF  xCE,W
14F6:  MOVWF  FE9
14F8:  MOVLW  00
14FA:  ADDWFC xCF,W
14FC:  MOVWF  FEA
14FE:  MOVF   FEF,W
1500:  SUBLW  58
1502:  BNZ   151C
....................       { 
....................          base = 16; 
1504:  MOVLW  10
1506:  MOVWF  xD5
....................          index++; 
1508:  INCF   xD6,F
....................          c = s[index++]; 
150A:  MOVF   xD6,W
150C:  INCF   xD6,F
150E:  ADDWF  xCE,W
1510:  MOVWF  FE9
1512:  MOVLW  00
1514:  ADDWFC xCF,W
1516:  MOVWF  FEA
1518:  MOVFF  FEF,1D7
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
151C:  MOVF   xD5,W
151E:  SUBLW  0A
1520:  BNZ   15A8
....................       { 
....................          while (c >= '0' && c <= '9') { 
1522:  MOVF   xD7,W
1524:  SUBLW  2F
1526:  BC    15A6
1528:  MOVF   xD7,W
152A:  SUBLW  39
152C:  BNC   15A6
....................             result = (result << 1) + (result << 3);  // result *= 10; 
152E:  BCF    FD8.0
1530:  RLCF   xD0,W
1532:  MOVWF  xD9
1534:  RLCF   xD1,W
1536:  MOVWF  xDA
1538:  RLCF   xD2,W
153A:  MOVWF  xDB
153C:  RLCF   xD3,W
153E:  MOVWF  xDC
1540:  RLCF   xD0,W
1542:  MOVWF  00
1544:  RLCF   xD1,W
1546:  MOVWF  01
1548:  RLCF   xD2,W
154A:  MOVWF  02
154C:  RLCF   xD3,W
154E:  MOVWF  03
1550:  RLCF   00,F
1552:  RLCF   01,F
1554:  RLCF   02,F
1556:  RLCF   03,F
1558:  RLCF   00,F
155A:  RLCF   01,F
155C:  RLCF   02,F
155E:  RLCF   03,F
1560:  MOVLW  F8
1562:  ANDWF  00,F
1564:  MOVF   xD9,W
1566:  ADDWF  00,F
1568:  MOVF   xDA,W
156A:  ADDWFC 01,F
156C:  MOVF   xDB,W
156E:  ADDWFC 02,F
1570:  MOVF   xDC,W
1572:  ADDWFC 03,F
1574:  MOVFF  03,1D3
1578:  MOVFF  02,1D2
157C:  MOVFF  01,1D1
1580:  MOVFF  00,1D0
....................             result += (c - '0'); 
1584:  MOVLW  30
1586:  SUBWF  xD7,W
1588:  ADDWF  xD0,F
158A:  MOVLW  00
158C:  ADDWFC xD1,F
158E:  ADDWFC xD2,F
1590:  ADDWFC xD3,F
....................             c = s[index++]; 
1592:  MOVF   xD6,W
1594:  INCF   xD6,F
1596:  ADDWF  xCE,W
1598:  MOVWF  FE9
159A:  MOVLW  00
159C:  ADDWFC xCF,W
159E:  MOVWF  FEA
15A0:  MOVFF  FEF,1D7
15A4:  BRA    1522
....................          } 
....................       } 
15A6:  BRA    16C0
....................       else if (base == 16)    // The number is a hexa number 
15A8:  MOVF   xD5,W
15AA:  SUBLW  10
15AC:  BTFSS  FD8.2
15AE:  BRA    16C0
....................       { 
....................          c = toupper(c); 
15B0:  MOVF   xD7,W
15B2:  SUBLW  60
15B4:  BC    15C2
15B6:  MOVF   xD7,W
15B8:  SUBLW  7A
15BA:  BNC   15C2
15BC:  MOVF   xD7,W
15BE:  ANDLW  DF
15C0:  BRA    15C4
15C2:  MOVF   xD7,W
15C4:  MOVWF  xD7
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
15C6:  MOVF   xD7,W
15C8:  SUBLW  2F
15CA:  BC    15D2
15CC:  MOVF   xD7,W
15CE:  SUBLW  39
15D0:  BC    15E0
15D2:  MOVF   xD7,W
15D4:  SUBLW  40
15D6:  BTFSC  FD8.0
15D8:  BRA    16C0
15DA:  MOVF   xD7,W
15DC:  SUBLW  46
15DE:  BNC   16C0
....................          { 
....................             if (c >= '0' && c <= '9') 
15E0:  MOVF   xD7,W
15E2:  SUBLW  2F
15E4:  BC    1642
15E6:  MOVF   xD7,W
15E8:  SUBLW  39
15EA:  BNC   1642
....................                result = (result << 4) + (c - '0'); 
15EC:  RLCF   xD0,W
15EE:  MOVWF  xD9
15F0:  RLCF   xD1,W
15F2:  MOVWF  xDA
15F4:  RLCF   xD2,W
15F6:  MOVWF  xDB
15F8:  RLCF   xD3,W
15FA:  MOVWF  xDC
15FC:  RLCF   xD9,F
15FE:  RLCF   xDA,F
1600:  RLCF   xDB,F
1602:  RLCF   xDC,F
1604:  RLCF   xD9,F
1606:  RLCF   xDA,F
1608:  RLCF   xDB,F
160A:  RLCF   xDC,F
160C:  RLCF   xD9,F
160E:  RLCF   xDA,F
1610:  RLCF   xDB,F
1612:  RLCF   xDC,F
1614:  MOVLW  F0
1616:  ANDWF  xD9,F
1618:  MOVLW  30
161A:  SUBWF  xD7,W
161C:  ADDWF  xD9,W
161E:  MOVWF  00
1620:  MOVLW  00
1622:  ADDWFC xDA,W
1624:  MOVWF  01
1626:  MOVLW  00
1628:  ADDWFC xDB,W
162A:  MOVWF  02
162C:  MOVLW  00
162E:  ADDWFC xDC,W
1630:  MOVWF  03
1632:  MOVWF  xD3
1634:  MOVFF  02,1D2
1638:  MOVFF  01,1D1
163C:  MOVFF  00,1D0
1640:  BRA    1696
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1642:  RLCF   xD0,W
1644:  MOVWF  xD9
1646:  RLCF   xD1,W
1648:  MOVWF  xDA
164A:  RLCF   xD2,W
164C:  MOVWF  xDB
164E:  RLCF   xD3,W
1650:  MOVWF  xDC
1652:  RLCF   xD9,F
1654:  RLCF   xDA,F
1656:  RLCF   xDB,F
1658:  RLCF   xDC,F
165A:  RLCF   xD9,F
165C:  RLCF   xDA,F
165E:  RLCF   xDB,F
1660:  RLCF   xDC,F
1662:  RLCF   xD9,F
1664:  RLCF   xDA,F
1666:  RLCF   xDB,F
1668:  RLCF   xDC,F
166A:  MOVLW  F0
166C:  ANDWF  xD9,F
166E:  MOVLW  41
1670:  SUBWF  xD7,W
1672:  ADDLW  0A
1674:  ADDWF  xD9,W
1676:  MOVWF  00
1678:  MOVLW  00
167A:  ADDWFC xDA,W
167C:  MOVWF  01
167E:  MOVLW  00
1680:  ADDWFC xDB,W
1682:  MOVWF  02
1684:  MOVLW  00
1686:  ADDWFC xDC,W
1688:  MOVWF  xD3
168A:  MOVFF  02,1D2
168E:  MOVFF  01,1D1
1692:  MOVFF  00,1D0
....................  
....................             c = s[index++];c = toupper(c); 
1696:  MOVF   xD6,W
1698:  INCF   xD6,F
169A:  ADDWF  xCE,W
169C:  MOVWF  FE9
169E:  MOVLW  00
16A0:  ADDWFC xCF,W
16A2:  MOVWF  FEA
16A4:  MOVFF  FEF,1D7
16A8:  MOVF   xD7,W
16AA:  SUBLW  60
16AC:  BC    16BA
16AE:  MOVF   xD7,W
16B0:  SUBLW  7A
16B2:  BNC   16BA
16B4:  MOVF   xD7,W
16B6:  ANDLW  DF
16B8:  BRA    16BC
16BA:  MOVF   xD7,W
16BC:  MOVWF  xD7
16BE:  BRA    15C6
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
16C0:  MOVF   xD5,W
16C2:  SUBLW  0A
16C4:  BNZ   16E0
16C6:  DECFSZ xD4,W
16C8:  BRA    16E0
....................       result = -result; 
16CA:  COMF   xD0,F
16CC:  COMF   xD1,F
16CE:  COMF   xD2,F
16D0:  COMF   xD3,F
16D2:  INCF   xD0,F
16D4:  BTFSC  FD8.2
16D6:  INCF   xD1,F
16D8:  BTFSC  FD8.2
16DA:  INCF   xD2,F
16DC:  BTFSC  FD8.2
16DE:  INCF   xD3,F
....................  
....................    return(result); 
16E0:  MOVFF  1D0,00
16E4:  MOVFF  1D1,01
16E8:  MOVFF  1D2,02
16EC:  MOVFF  1D3,03
16F0:  MOVLB  0
16F2:  RETURN 0
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=20000000) 
*
01D2:  MOVLW  03
01D4:  MOVLB  1
01D6:  SUBWF  xE6,F
01D8:  BNC   01EE
01DA:  MOVLW  01
01DC:  MOVWF  FEA
01DE:  MOVLW  E6
01E0:  MOVWF  FE9
01E2:  MOVF   FEF,W
01E4:  BZ    01EE
01E6:  BRA    01EA
01E8:  BRA    01EA
01EA:  DECFSZ FEF,F
01EC:  BRA    01E8
01EE:  MOVLB  0
01F0:  GOTO   0206 (RETURN)
*
040A:  MOVLW  01
040C:  MOVWF  FEA
040E:  MOVLW  D8
0410:  MOVWF  FE9
0412:  MOVF   FEF,W
0414:  BZ    0430
0416:  MOVLW  06
0418:  MOVWF  01
041A:  CLRF   00
041C:  DECFSZ 00,F
041E:  BRA    041C
0420:  DECFSZ 01,F
0422:  BRA    041A
0424:  MOVLW  7B
0426:  MOVWF  00
0428:  DECFSZ 00,F
042A:  BRA    0428
042C:  DECFSZ FEF,F
042E:  BRA    0416
0430:  RETURN 0
.................... #use rs232(uart1, baud=9600,TIMEOUT=10,stream=monitor)//pic to pic 
*
01F4:  MOVLW  20
01F6:  MOVLB  1
01F8:  MOVWF  xE4
01FA:  MOVLW  02
01FC:  MOVWF  xE5
01FE:  MOVLW  9B
0200:  MOVWF  xE6
0202:  MOVLB  0
0204:  BRA    01D2
0206:  MOVLB  1
0208:  DECFSZ xE5,F
020A:  BRA    01FE
020C:  DECFSZ xE4,F
020E:  BRA    0216
0210:  CLRF   1F
0212:  CLRF   01
0214:  BRA    022A
0216:  BTFSS  F9E.5
0218:  BRA    01FA
021A:  MOVF   FAB,W
021C:  MOVWF  1F
021E:  MOVF   FAE,W
0220:  MOVWF  01
0222:  BTFSS  1F.1
0224:  BRA    022A
0226:  BCF    FAB.4
0228:  BSF    FAB.4
022A:  MOVLB  0
022C:  GOTO   0258 (RETURN)
.................... //#use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
.................... #use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C1,rcv=PIN_C0,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
*
0E96:  MOVLW  10
0E98:  MOVLB  1
0E9A:  MOVWF  xCE
0E9C:  MOVLW  01
0E9E:  MOVWF  xCD
0EA0:  BSF    20.6
0EA2:  BSF    F94.0
0EA4:  MOVLW  10
0EA6:  MOVWF  00
0EA8:  DECFSZ 00,F
0EAA:  BRA    0EA8
0EAC:  NOP   
0EAE:  DECFSZ xCD,F
0EB0:  BRA    0EBC
0EB2:  DECFSZ xCE,F
0EB4:  BRA    0EBC
0EB6:  CLRF   20
0EB8:  CLRF   01
0EBA:  BRA    0F04
0EBC:  BTFSC  F82.0
0EBE:  BRA    0EA4
0EC0:  MOVLW  08
0EC2:  MOVWF  00
0EC4:  CLRF   xCF
0EC6:  MOVFF  FF2,1D0
0ECA:  BCF    FF2.7
0ECC:  BSF    00.7
0ECE:  BRA    0EEC
0ED0:  BCF    00.7
0ED2:  BRA    0EEC
0ED4:  BCF    FD8.0
0ED6:  BTFSC  F82.0
0ED8:  BSF    FD8.0
0EDA:  RRCF   xCF,F
0EDC:  BSF    00.6
0EDE:  BRA    0EEC
0EE0:  BCF    00.6
0EE2:  DECFSZ 00,F
0EE4:  BRA    0ED4
0EE6:  MOVF   xCF,W
0EE8:  MOVWF  01
0EEA:  BRA    0F04
0EEC:  MOVLW  A7
0EEE:  BTFSC  00.7
0EF0:  MOVLW  2D
0EF2:  MOVWF  01
0EF4:  DECFSZ 01,F
0EF6:  BRA    0EF4
0EF8:  NOP   
0EFA:  BTFSC  00.7
0EFC:  BRA    0ED0
0EFE:  BTFSC  00.6
0F00:  BRA    0EE0
0F02:  BRA    0ED4
0F04:  BTFSC  xD0.7
0F06:  BSF    FF2.7
0F08:  MOVLB  0
0F0A:  GOTO   2FB2 (RETURN)
*
11B0:  MOVFF  FF2,03
11B4:  BCF    FF2.7
11B6:  BCF    F94.1
11B8:  BCF    F8B.1
11BA:  MOVLW  08
11BC:  MOVWF  01
11BE:  BRA    11C0
11C0:  NOP   
11C2:  BSF    01.7
11C4:  BRA    11E6
11C6:  BCF    01.7
11C8:  MOVLB  1
11CA:  RRCF   xD6,F
11CC:  MOVLB  0
11CE:  BTFSC  FD8.0
11D0:  BSF    F8B.1
11D2:  BTFSS  FD8.0
11D4:  BCF    F8B.1
11D6:  BSF    01.6
11D8:  BRA    11E6
11DA:  BCF    01.6
11DC:  DECFSZ 01,F
11DE:  BRA    11C8
11E0:  BRA    11E2
11E2:  NOP   
11E4:  BSF    F8B.1
11E6:  MOVLW  A7
11E8:  MOVWF  FE9
11EA:  DECFSZ FE9,F
11EC:  BRA    11EA
11EE:  BRA    11F0
11F0:  BTFSC  01.7
11F2:  BRA    11C6
11F4:  BTFSC  01.6
11F6:  BRA    11DA
11F8:  BTFSC  03.7
11FA:  BSF    FF2.7
11FC:  RETURN 0
.................... #fuses HS,NOLVP,PUT,PROTECT,NODEBUG,NOWDT,WDT4096//pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
0432:  MOVLB  1
0434:  BTFSC  xDF.0
0436:  BRA    043C
0438:  BCF    F89.4
043A:  BRA    043E
043C:  BSF    F89.4
043E:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0440:  BTFSC  xDF.1
0442:  BRA    0448
0444:  BCF    F89.2
0446:  BRA    044A
0448:  BSF    F89.2
044A:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
044C:  BTFSC  xDF.2
044E:  BRA    0454
0450:  BCF    F89.1
0452:  BRA    0456
0454:  BSF    F89.1
0456:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0458:  BTFSC  xDF.3
045A:  BRA    0460
045C:  BCF    F89.0
045E:  BRA    0462
0460:  BSF    F89.0
0462:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0464:  NOP   
....................  output_high(LCD_E);  
0466:  BCF    F92.3
0468:  BSF    F89.3
....................  delay_us(2);  
046A:  MOVLW  02
046C:  MOVWF  00
046E:  DECFSZ 00,F
0470:  BRA    046E
0472:  BRA    0474
0474:  NOP   
....................  output_low(LCD_E);  
0476:  BCF    F92.3
0478:  BCF    F89.3
047A:  MOVLB  0
047C:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
047E:  BCF    F96.2
0480:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0482:  MOVLW  63
0484:  MOVWF  00
0486:  DECFSZ 00,F
0488:  BRA    0486
048A:  BRA    048C
.................... #endif  
....................  
.................... if(address)  
048C:  MOVLB  1
048E:  MOVF   xDC,F
0490:  BZ    0498
....................    output_high(LCD_RS);  
0492:  BCF    F96.2
0494:  BSF    F8D.2
0496:  BRA    049C
.................... else  
....................    output_low(LCD_RS);  
0498:  BCF    F96.2
049A:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
049C:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
049E:  BCF    F92.3
04A0:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
04A2:  SWAPF  xDD,W
04A4:  MOVWF  xDE
04A6:  MOVLW  0F
04A8:  ANDWF  xDE,F
04AA:  MOVFF  1DE,1DF
04AE:  MOVLB  0
04B0:  RCALL  0432
.................... lcd_send_nibble(n & 0xf);  
04B2:  MOVLB  1
04B4:  MOVF   xDD,W
04B6:  ANDLW  0F
04B8:  MOVWF  xDE
04BA:  MOVWF  xDF
04BC:  MOVLB  0
04BE:  RCALL  0432
04C0:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
04C2:  MOVLW  01
04C4:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
04C6:  BCF    F96.2
04C8:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
04CA:  BCF    F92.3
04CC:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
04CE:  MOVLW  23
04D0:  MOVLB  1
04D2:  MOVWF  xD8
04D4:  MOVLB  0
04D6:  RCALL  040A
....................  
....................    for(i=0 ;i < 3; i++)  
04D8:  MOVLB  1
04DA:  CLRF   xCD
04DC:  MOVF   xCD,W
04DE:  SUBLW  02
04E0:  BNC   04FA
....................    {  
....................       lcd_send_nibble(0x03);  
04E2:  MOVLW  03
04E4:  MOVWF  xDF
04E6:  MOVLB  0
04E8:  RCALL  0432
....................       delay_ms(5);  
04EA:  MOVLW  05
04EC:  MOVLB  1
04EE:  MOVWF  xD8
04F0:  MOVLB  0
04F2:  RCALL  040A
04F4:  MOVLB  1
04F6:  INCF   xCD,F
04F8:  BRA    04DC
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04FA:  MOVLW  02
04FC:  MOVWF  xDF
04FE:  MOVLB  0
0500:  RCALL  0432
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0502:  MOVLB  1
0504:  CLRF   xCD
0506:  MOVF   xCD,W
0508:  SUBLW  03
050A:  BNC   0530
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
050C:  CLRF   03
050E:  MOVF   xCD,W
0510:  MOVLB  0
0512:  RCALL  00C6
0514:  MOVLB  1
0516:  MOVWF  xCE
0518:  CLRF   xDC
051A:  MOVWF  xDD
051C:  MOVLB  0
051E:  RCALL  047E
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
0520:  MOVLW  05
0522:  MOVLB  1
0524:  MOVWF  xD8
0526:  MOVLB  0
0528:  RCALL  040A
....................       #endif  
052A:  MOVLB  1
052C:  INCF   xCD,F
052E:  BRA    0506
....................    }  
0530:  MOVLB  0
0532:  GOTO   2D82 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
086E:  MOVLB  1
0870:  MOVF   xD9,W
0872:  XORLW  01
0874:  MOVLB  0
0876:  BZ    0886
0878:  XORLW  03
087A:  BZ    088C
087C:  XORLW  01
087E:  BZ    0894
0880:  XORLW  07
0882:  BZ    089C
0884:  BRA    08A6
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
0886:  MOVLB  1
0888:  CLRF   xDA
....................      break;  
088A:  BRA    08AA
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
088C:  MOVLW  40
088E:  MOVLB  1
0890:  MOVWF  xDA
....................      break;  
0892:  BRA    08AA
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0894:  MOVLW  14
0896:  MOVLB  1
0898:  MOVWF  xDA
....................      break;  
089A:  BRA    08AA
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
089C:  MOVLW  54
089E:  MOVLB  1
08A0:  MOVWF  xDA
....................      break;  
08A2:  BRA    08AA
08A4:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
08A6:  MOVLB  1
08A8:  CLRF   xDA
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
08AA:  MOVLW  01
08AC:  SUBWF  xD8,W
08AE:  ADDWF  xDA,F
.................... lcd_send_byte(0, 0x80 | address);  
08B0:  MOVF   xDA,W
08B2:  IORLW  80
08B4:  MOVWF  xDB
08B6:  CLRF   xDC
08B8:  MOVWF  xDD
08BA:  MOVLB  0
08BC:  RCALL  047E
08BE:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
08C0:  MOVLB  1
08C2:  MOVF   xD7,W
08C4:  XORLW  0C
08C6:  MOVLB  0
08C8:  BZ    08D4
08CA:  XORLW  06
08CC:  BZ    08F0
08CE:  XORLW  02
08D0:  BZ    0902
08D2:  BRA    0910
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
08D4:  MOVLB  1
08D6:  CLRF   xDC
08D8:  MOVLW  01
08DA:  MOVWF  xDD
08DC:  MOVLB  0
08DE:  RCALL  047E
....................       lcd_line = 1;  
08E0:  MOVLW  01
08E2:  MOVWF  21
....................       delay_ms(2);  
08E4:  MOVLW  02
08E6:  MOVLB  1
08E8:  MOVWF  xD8
08EA:  MOVLB  0
08EC:  RCALL  040A
....................       break;  
08EE:  BRA    091E
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08F0:  INCF   21,F
08F2:  MOVLW  01
08F4:  MOVLB  1
08F6:  MOVWF  xD8
08F8:  MOVFF  21,1D9
08FC:  MOVLB  0
08FE:  RCALL  086E
....................        break;  
0900:  BRA    091E
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0902:  MOVLB  1
0904:  CLRF   xDC
0906:  MOVLW  10
0908:  MOVWF  xDD
090A:  MOVLB  0
090C:  RCALL  047E
....................        break;  
090E:  BRA    091E
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
0910:  MOVLW  01
0912:  MOVLB  1
0914:  MOVWF  xDC
0916:  MOVFF  1D7,1DD
091A:  MOVLB  0
091C:  RCALL  047E
....................        break;  
....................    }  
091E:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
053E:  MOVLW  08
0540:  MOVWF  01
0542:  MOVLW  05
0544:  MOVWF  00
0546:  DECFSZ 00,F
0548:  BRA    0546
054A:  BCF    F8C.7
054C:  BCF    F95.7
054E:  MOVLW  06
0550:  MOVWF  00
0552:  DECFSZ 00,F
0554:  BRA    0552
0556:  MOVLB  1
0558:  RLCF   xD7,F
055A:  BCF    F8C.6
055C:  BTFSC  FD8.0
055E:  BSF    F95.6
0560:  BTFSS  FD8.0
0562:  BCF    F95.6
0564:  BSF    F95.7
0566:  BTFSS  F83.7
0568:  BRA    0566
056A:  DECFSZ 01,F
056C:  BRA    0570
056E:  BRA    0574
0570:  MOVLB  0
0572:  BRA    0542
0574:  MOVLW  05
0576:  MOVWF  00
0578:  DECFSZ 00,F
057A:  BRA    0578
057C:  BCF    F8C.7
057E:  BCF    F95.7
0580:  NOP   
0582:  BSF    F95.6
0584:  MOVLW  06
0586:  MOVWF  00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  MOVLW  06
058E:  MOVWF  00
0590:  DECFSZ 00,F
0592:  BRA    0590
0594:  BSF    F95.7
0596:  BTFSS  F83.7
0598:  BRA    0596
059A:  CLRF   01
059C:  MOVLW  06
059E:  MOVWF  00
05A0:  DECFSZ 00,F
05A2:  BRA    05A0
05A4:  BTFSC  F83.6
05A6:  BSF    01.0
05A8:  BCF    F8C.7
05AA:  BCF    F95.7
05AC:  BCF    F8C.6
05AE:  BCF    F95.6
05B0:  MOVLB  0
05B2:  RETURN 0
*
0708:  MOVLW  08
070A:  MOVLB  1
070C:  MOVWF  xD5
070E:  MOVFF  00,1D6
0712:  BSF    F95.6
0714:  MOVLW  06
0716:  MOVWF  00
0718:  DECFSZ 00,F
071A:  BRA    0718
071C:  BSF    F95.7
071E:  BTFSS  F83.7
0720:  BRA    071E
0722:  BTFSC  F83.6
0724:  BSF    FD8.0
0726:  BTFSS  F83.6
0728:  BCF    FD8.0
072A:  RLCF   01,F
072C:  MOVLW  05
072E:  MOVWF  00
0730:  DECFSZ 00,F
0732:  BRA    0730
0734:  BCF    F95.7
0736:  BCF    F8C.7
0738:  DECFSZ xD5,F
073A:  BRA    0712
073C:  BSF    F95.6
073E:  MOVLW  06
0740:  MOVWF  00
0742:  DECFSZ 00,F
0744:  BRA    0742
0746:  BCF    F8C.6
0748:  MOVF   xD6,W
074A:  BTFSS  FD8.2
074C:  BCF    F95.6
074E:  NOP   
0750:  BSF    F95.7
0752:  BTFSS  F83.7
0754:  BRA    0752
0756:  MOVLW  05
0758:  MOVWF  00
075A:  DECFSZ 00,F
075C:  BRA    075A
075E:  BCF    F8C.7
0760:  BCF    F95.7
0762:  MOVLW  06
0764:  MOVWF  00
0766:  DECFSZ 00,F
0768:  BRA    0766
076A:  BCF    F8C.6
076C:  BCF    F95.6
076E:  MOVLB  0
0770:  GOTO   07EE (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
0536:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
0538:  BSF    F95.6
053A:  GOTO   2D86 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
05B4:  BSF    F95.6
05B6:  MOVLW  05
05B8:  MOVWF  00
05BA:  DECFSZ 00,F
05BC:  BRA    05BA
05BE:  BSF    F95.7
05C0:  MOVLW  06
05C2:  MOVWF  00
05C4:  DECFSZ 00,F
05C6:  BRA    05C4
05C8:  BCF    F8C.6
05CA:  BCF    F95.6
05CC:  MOVLW  05
05CE:  MOVWF  00
05D0:  DECFSZ 00,F
05D2:  BRA    05D0
05D4:  BCF    F8C.7
05D6:  BCF    F95.7
....................    i2c_write(0xa0); 
05D8:  MOVLW  A0
05DA:  MOVLB  1
05DC:  MOVWF  xD7
05DE:  MOVLB  0
05E0:  RCALL  053E
....................    i2c_write(address>>8); 
05E2:  MOVFF  1D2,1D5
05E6:  MOVLB  1
05E8:  CLRF   xD6
05EA:  MOVFF  1D2,1D7
05EE:  MOVLB  0
05F0:  RCALL  053E
....................    i2c_write(address); 
05F2:  MOVFF  1D1,1D7
05F6:  RCALL  053E
....................    i2c_write(data); 
05F8:  MOVFF  1D3,1D7
05FC:  RCALL  053E
....................    i2c_stop(); 
05FE:  BCF    F95.6
0600:  NOP   
0602:  BSF    F95.7
0604:  BTFSS  F83.7
0606:  BRA    0604
0608:  MOVLW  05
060A:  MOVWF  00
060C:  DECFSZ 00,F
060E:  BRA    060C
0610:  BRA    0612
0612:  NOP   
0614:  BSF    F95.6
0616:  MOVLW  05
0618:  MOVWF  00
061A:  DECFSZ 00,F
061C:  BRA    061A
....................    i2c_start(); 
061E:  BSF    F95.6
0620:  MOVLW  05
0622:  MOVWF  00
0624:  DECFSZ 00,F
0626:  BRA    0624
0628:  BSF    F95.7
062A:  MOVLW  06
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
0632:  BCF    F8C.6
0634:  BCF    F95.6
0636:  MOVLW  05
0638:  MOVWF  00
063A:  DECFSZ 00,F
063C:  BRA    063A
063E:  BCF    F8C.7
0640:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0642:  MOVLW  A0
0644:  MOVLB  1
0646:  MOVWF  xD7
0648:  MOVLB  0
064A:  RCALL  053E
064C:  MOVF   01,W
064E:  MOVLB  1
0650:  BCF    xD4.0
0652:  BTFSC  01.0
0654:  BSF    xD4.0
....................    while(status==1) 
0656:  BTFSS  xD4.0
0658:  BRA    0696
....................    { 
....................    i2c_start(); 
065A:  BSF    F95.6
065C:  MOVLW  05
065E:  MOVWF  00
0660:  DECFSZ 00,F
0662:  BRA    0660
0664:  BSF    F95.7
0666:  MOVLW  06
0668:  MOVWF  00
066A:  DECFSZ 00,F
066C:  BRA    066A
066E:  BTFSS  F83.7
0670:  BRA    066E
0672:  BCF    F8C.6
0674:  BCF    F95.6
0676:  MOVLW  05
0678:  MOVWF  00
067A:  DECFSZ 00,F
067C:  BRA    067A
067E:  BCF    F8C.7
0680:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0682:  MOVLW  A0
0684:  MOVWF  xD7
0686:  MOVLB  0
0688:  RCALL  053E
068A:  MOVF   01,W
068C:  MOVLB  1
068E:  BCF    xD4.0
0690:  BTFSC  01.0
0692:  BSF    xD4.0
0694:  BRA    0656
....................    } 
....................    i2c_stop(); 
0696:  BCF    F95.6
0698:  NOP   
069A:  BSF    F95.7
069C:  BTFSS  F83.7
069E:  BRA    069C
06A0:  MOVLW  05
06A2:  MOVWF  00
06A4:  DECFSZ 00,F
06A6:  BRA    06A4
06A8:  BRA    06AA
06AA:  NOP   
06AC:  BSF    F95.6
06AE:  MOVLW  05
06B0:  MOVWF  00
06B2:  DECFSZ 00,F
06B4:  BRA    06B2
06B6:  MOVLB  0
06B8:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0774:  BSF    F95.6
0776:  MOVLW  05
0778:  MOVWF  00
077A:  DECFSZ 00,F
077C:  BRA    077A
077E:  BSF    F95.7
0780:  MOVLW  06
0782:  MOVWF  00
0784:  DECFSZ 00,F
0786:  BRA    0784
0788:  BCF    F8C.6
078A:  BCF    F95.6
078C:  MOVLW  05
078E:  MOVWF  00
0790:  DECFSZ 00,F
0792:  BRA    0790
0794:  BCF    F8C.7
0796:  BCF    F95.7
....................    i2c_write(0xa0); 
0798:  MOVLW  A0
079A:  MOVLB  1
079C:  MOVWF  xD7
079E:  MOVLB  0
07A0:  RCALL  053E
....................    i2c_write(address>>8); 
07A2:  MOVFF  1D2,1D4
07A6:  MOVLB  1
07A8:  CLRF   xD5
07AA:  MOVFF  1D2,1D7
07AE:  MOVLB  0
07B0:  RCALL  053E
....................    i2c_write(address); 
07B2:  MOVFF  1D1,1D7
07B6:  RCALL  053E
....................    i2c_start(); 
07B8:  BSF    F95.6
07BA:  MOVLW  05
07BC:  MOVWF  00
07BE:  DECFSZ 00,F
07C0:  BRA    07BE
07C2:  BSF    F95.7
07C4:  MOVLW  06
07C6:  MOVWF  00
07C8:  DECFSZ 00,F
07CA:  BRA    07C8
07CC:  BTFSS  F83.7
07CE:  BRA    07CC
07D0:  BCF    F8C.6
07D2:  BCF    F95.6
07D4:  MOVLW  05
07D6:  MOVWF  00
07D8:  DECFSZ 00,F
07DA:  BRA    07D8
07DC:  BCF    F8C.7
07DE:  BCF    F95.7
....................    i2c_write(0xa1); 
07E0:  MOVLW  A1
07E2:  MOVLB  1
07E4:  MOVWF  xD7
07E6:  MOVLB  0
07E8:  RCALL  053E
....................    data=i2c_read(0); 
07EA:  CLRF   00
07EC:  BRA    0708
07EE:  MOVFF  01,1D3
....................    i2c_stop(); 
07F2:  BCF    F95.6
07F4:  NOP   
07F6:  BSF    F95.7
07F8:  BTFSS  F83.7
07FA:  BRA    07F8
07FC:  MOVLW  05
07FE:  MOVWF  00
0800:  DECFSZ 00,F
0802:  BRA    0800
0804:  BRA    0806
0806:  NOP   
0808:  BSF    F95.6
080A:  MOVLW  05
080C:  MOVWF  00
080E:  DECFSZ 00,F
0810:  BRA    080E
....................    return(data); 
0812:  MOVLB  1
0814:  MOVFF  1D3,01
0818:  MOVLB  0
081A:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... //entradas 
.................... #define entrada01  PIN_B4////SENSOR 1              2  1 
.................... #define entrada02  PIN_D4////SENSOR 2              4  3 
.................... #define entrada03  PIN_B2////SENSOR 3              6  5 
.................... #define entrada04  PIN_B3////SENSOR 4 
.................... #define entrada05  PIN_B0////SENSOR 5 
.................... #define entrada06  PIN_B1////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3////REINICIAR CONTADOR 
.................... #define frente  PIN_D2///INDICADOR DE MAESTRO 
.................... #define B_silencio  PIN_D1///BOTON PARA SILENCIAR (eliminado) 
.................... //salidas 
.................... #define salida01  PIN_C3//Buzzer 
.................... #define salida02  PIN_C4//Indicador de Sensado 
.................... #define salida03  PIN_C5//Relay 
....................  
.................... #define HB PIN_E0  //habilita recepcion de datos en gprs  pin 25->D39 
.................... #define EN PIN_E1  //monitor de "envio listo" desde gprs  pin 26->D38 
....................  
....................  
.................... const int s_cta=5;//numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;//Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error,transmitir;//variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1,sumas1;//Variables temporales de suma de entradas y salidas 
.................... int lim_b;//cuenta de sensores bloqueados 
.................... int fse1,fse2,fse3,fss1,fss2,fss3;//banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1,temporal2,tempo_tn,sub_atras,baj_atras;//variables temporales para hacer calculos. 
.................... int16 entran1,salen1;//variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian,time_clr;//variable temporal para guardar salidas 
.................... int ini,i,ii,j=0,a,master=0,flag_enviar,f_clr; 
.................... int16 b,n,cta_bloqueo,cta_enviar,total2_t;//,envia_ent,envia_sal; 
.................... int cta_bloq1=0,cta_bloq2=0,cta_bloq3=0;//variables para contar bloqueos por pares 
.................... int ent1=0,ent2=0,ent3=0,ent4=0,ent5=0,ent6=0;//variables de estado de sensores 
.................... int sen_ent=0,sen_sal=0;//variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1=0,sub_cta2=0,sub_cta3=0,sub_cta4=0,sub_cta5=0,sub_cta6=0;//variables para calculos de cuentas 
.................... int detec1,detec2,detec3,detec4,detec5,detec6;//variables para determinar el cambio de estado de los sensores 
.................... int sub_d1,sub_d2,sub_d3,sub_d4,sub_d5,sub_d6;//variables para determinar el cambio de estado de los sensores 
.................... int entra_act1=0,edo1=0,entra1=0,sale1=0,edoa1=0,enable1=0,entra_temp1=0;//variables para la maquina de estados de sensores par1 
.................... int entra_act2=0,edo2=0,entra2=0,sale2=0,edoa2=0,enable2=0,entra_temp2=0;//variables para la maquina de estados de sensores par2 
.................... int entra_act3=0,edo3=0,entra3=0,sale3=0,edoa3=0,enable3=0,entra_temp3=0;//variables para la maquina de estados de sensores par3 
.................... int16 entraront=0,salieront=0,pasaje=0,pasajet=0;//cuenta total de entradas y salidas 
.................... int16 tem_entraront=0,tem_salieront=0,temporal3;//cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1=0,des2=0,des3=0; 
.................... int bloq_p1,bloq_p2,bloq_p3,en_b1,en_b2,en_b3; 
.................... int16 tim_p1,tim_p2,tim_p3,segundoen,time_envio; 
.................... const int32 set_timer=59286;//10ms 
.................... const int16 time_bloqueo=500;//5seg. 100=1seg. 
.................... int clear_lcd1,time_lcd1; 
.................... int y=0; 
.................... int bandera_revision=0; 
.................... int16 cntbnd=0; 
....................  
.................... // variables temporales para la conversion de string a entero de datos seriales de la cuenta de pasajeros del poste trasero/// 
.................... char term[3], *ptr; 
.................... char data1[14]; 
.................... char data2[10]; 
.................... char data3[10]; 
.................... char data4[10]; 
.................... char data5[10]; 
.................... int caso_valor=0; 
.................... int solicitud_reset_gps=0; 
....................  
.................... //lista de comandos para contadores /// 
.................... char *textosearch[11] =    { "V5.01     \r", 
....................                              "BORRAR_ALL\r", 
....................                              "GRABAR_DAT\r", 
....................                              "LEERCUENTA\r",// 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r"                            
....................                            }; 
....................  
.................... char version[]="V5.02";//<---Version de codigo de contador 
....................  
.................... /////EEPROM/////////// 
.................... const int word_size =10;//TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set=9; 
.................... //char XX[word_size+19];// ARREGLO SERIAL 
.................... char XX[word_size+22];// ARREGLO SERIAL 
.................... char entran[5]; 
.................... char salen[5]; 
.................... char bloqueado[5]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[5]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... //void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
....................    time_clr++; 
*
010A:  INCF   3E,F
010C:  BTFSC  FD8.2
010E:  INCF   3F,F
....................    segundoen++; 
0110:  INCF   xA7,F
0112:  BTFSC  FD8.2
0114:  INCF   xA8,F
....................    if(segundoen>=100) { 
0116:  MOVF   xA8,F
0118:  BNZ   0120
011A:  MOVF   xA7,W
011C:  SUBLW  63
011E:  BC    012C
....................       segundoen=0; 
0120:  CLRF   xA8
0122:  CLRF   xA7
....................       time_envio++; 
0124:  INCF   xA9,F
0126:  BTFSC  FD8.2
0128:  INCF   xAA,F
....................       time_lcd1++; 
012A:  INCF   xAC,F
....................    } 
.................... //****Se definen los estados de los sensores (deteccion)***// 
....................    //sensor1 
....................    ent1=input(entrada01); 
012C:  BSF    F93.4
012E:  CLRF   55
0130:  BTFSC  F81.4
0132:  INCF   55,F
....................    if(ent1==0) sub_cta1++;//ent1 =0 (no pulso) 
0134:  MOVF   55,F
0136:  BNZ   013E
0138:  INCF   5D,F
013A:  BTFSC  FD8.2
013C:  INCF   5E,F
....................    //sensor2 
....................    ent2=input(entrada02); 
013E:  BSF    F95.4
0140:  CLRF   56
0142:  BTFSC  F83.4
0144:  INCF   56,F
....................    if(ent2==0) sub_cta2++; 
0146:  MOVF   56,F
0148:  BNZ   0150
014A:  INCF   5F,F
014C:  BTFSC  FD8.2
014E:  INCF   x60,F
....................    //sensor3 
....................    ent3=input(entrada03); 
0150:  BSF    F93.2
0152:  CLRF   57
0154:  BTFSC  F81.2
0156:  INCF   57,F
....................    if(ent3==0) sub_cta3++; 
0158:  MOVF   57,F
015A:  BNZ   0162
015C:  INCF   x61,F
015E:  BTFSC  FD8.2
0160:  INCF   x62,F
....................    //sensor4 
....................    ent4=input(entrada04); 
0162:  BSF    F93.3
0164:  CLRF   58
0166:  BTFSC  F81.3
0168:  INCF   58,F
....................    if(ent4==0) sub_cta4++; 
016A:  MOVF   58,F
016C:  BNZ   0174
016E:  INCF   x63,F
0170:  BTFSC  FD8.2
0172:  INCF   x64,F
....................    //sensor5 
....................    ent5=input(entrada05); 
0174:  BSF    F93.0
0176:  CLRF   59
0178:  BTFSC  F81.0
017A:  INCF   59,F
....................    if(ent5==0) sub_cta5++; 
017C:  MOVF   59,F
017E:  BNZ   0186
0180:  INCF   x65,F
0182:  BTFSC  FD8.2
0184:  INCF   x66,F
....................    //sensor6 
....................    ent6=input(entrada06); 
0186:  BSF    F93.1
0188:  CLRF   5A
018A:  BTFSC  F81.1
018C:  INCF   5A,F
....................    if(ent6==0) sub_cta6++; 
018E:  MOVF   5A,F
0190:  BNZ   0198
0192:  INCF   x67,F
0194:  BTFSC  FD8.2
0196:  INCF   x68,F
.................... //****************************************// 
....................    tim_p1++; 
0198:  INCF   xA1,F
019A:  BTFSC  FD8.2
019C:  INCF   xA2,F
....................    tim_p2++; 
019E:  INCF   xA3,F
01A0:  BTFSC  FD8.2
01A2:  INCF   xA4,F
....................    tim_p3++; 
01A4:  INCF   xA5,F
01A6:  BTFSC  FD8.2
01A8:  INCF   xA6,F
....................    cta_enviar++; 
01AA:  INCF   4E,F
01AC:  BTFSC  FD8.2
01AE:  INCF   4F,F
.................... set_timer1(set_timer);// 10ms 
01B0:  MOVLW  E7
01B2:  MOVWF  FCF
01B4:  MOVLW  96
01B6:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
....................  
.................... //----------------------------------------------------------------------------- 
.................... //timer para la el tiempo de espera del puerto serial emulado, datos del gprs// 
01B8:  BCF    F9E.0
01BA:  GOTO   0078
.................... #int_TIMER3 
.................... void  TIMER3_isr(void)  
.................... { 
....................    cntbnd++;  //bandera de conteo de timepo de espera de para puerto serial emlado 
01BE:  INCF   xAF,F
01C0:  BTFSC  FD8.2
01C2:  INCF   xB0,F
....................    set_timer3(65036);  
01C4:  MOVLW  FE
01C6:  MOVWF  FB3
01C8:  MOVLW  0C
01CA:  MOVWF  FB2
....................     
.................... } 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
.................... // captura de datos seriales entre postes, delantero y trasero ///////////// 
01CC:  BCF    FA1.1
01CE:  GOTO   0078
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... disable_interrupts(GLOBAL);//deshabilita interrupciones globales 
*
0230:  BCF    FF2.6
0232:  BCF    FF2.7
0234:  BTFSC  FF2.7
0236:  BRA    0232
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
0238:  CLRF   41
....................    while(i<=30){ 
023A:  MOVF   41,W
023C:  SUBLW  1E
023E:  BNC   027E
....................    XX[i] = fgetc(monitor); 
0240:  CLRF   03
0242:  MOVF   41,W
0244:  ADDLW  8E
0246:  MOVWF  FE9
0248:  MOVLW  01
024A:  ADDWFC 03,W
024C:  MOVWF  FEA
024E:  MOVFF  FEA,1E3
0252:  MOVFF  FE9,1E2
0256:  BRA    01F4
0258:  MOVFF  1E3,FEA
025C:  MOVFF  1E2,FE9
0260:  MOVFF  01,FEF
....................    i++; 
0264:  INCF   41,F
....................    if(XX[i]==13)break; 
0266:  CLRF   03
0268:  MOVF   41,W
026A:  ADDLW  8E
026C:  MOVWF  FE9
026E:  MOVLW  01
0270:  ADDWFC 03,W
0272:  MOVWF  FEA
0274:  MOVF   FEF,W
0276:  SUBLW  0D
0278:  BTFSC  FD8.2
027A:  BRA    027E
027C:  BRA    023A
....................    };//se captura el dato del serial monitor(comunicacion entre pics) 
.................... j=1; 
027E:  MOVLW  01
0280:  MOVWF  43
.................... y=1; 
0282:  MOVWF  xAD
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
0284:  BCF    F9E.5
0286:  GOTO   0078
.................... #ZERO_RAM 
.................... void main(){ 
*
2BBE:  CLRF   FF8
2BC0:  BCF    FD0.7
2BC2:  BSF    07.7
2BC4:  MOVLW  FE
2BC6:  MOVWF  00
2BC8:  MOVLW  06
2BCA:  MOVWF  01
2BCC:  MOVLW  02
2BCE:  MOVWF  FE9
2BD0:  MOVLW  00
2BD2:  MOVWF  FEA
2BD4:  CLRF   FEE
2BD6:  DECFSZ 00,F
2BD8:  BRA    2BD4
2BDA:  DECFSZ 01,F
2BDC:  BRA    2BD4
2BDE:  CLRF   1F
2BE0:  BSF    FB8.3
2BE2:  MOVLW  08
2BE4:  MOVWF  FAF
2BE6:  MOVLW  02
2BE8:  MOVWF  FB0
2BEA:  MOVLW  A6
2BEC:  MOVWF  FAC
2BEE:  MOVLW  90
2BF0:  MOVWF  FAB
2BF2:  CLRF   20
2BF4:  BCF    F94.1
2BF6:  BSF    F8B.1
2BF8:  CLRF   43
2BFA:  CLRF   45
2BFC:  CLRF   52
2BFE:  CLRF   53
2C00:  CLRF   54
2C02:  CLRF   55
2C04:  CLRF   56
2C06:  CLRF   57
2C08:  CLRF   58
2C0A:  CLRF   59
2C0C:  CLRF   5A
2C0E:  CLRF   5B
2C10:  CLRF   5C
2C12:  CLRF   5E
2C14:  CLRF   5D
2C16:  CLRF   x60
2C18:  CLRF   5F
2C1A:  CLRF   x62
2C1C:  CLRF   x61
2C1E:  CLRF   x64
2C20:  CLRF   x63
2C22:  CLRF   x66
2C24:  CLRF   x65
2C26:  CLRF   x68
2C28:  CLRF   x67
2C2A:  CLRF   x75
2C2C:  CLRF   x76
2C2E:  CLRF   x77
2C30:  CLRF   x78
2C32:  CLRF   x79
2C34:  CLRF   x7A
2C36:  CLRF   x7B
2C38:  CLRF   x7C
2C3A:  CLRF   x7D
2C3C:  CLRF   x7E
2C3E:  CLRF   x7F
2C40:  CLRF   x80
2C42:  CLRF   x81
2C44:  CLRF   x82
2C46:  CLRF   x83
2C48:  CLRF   x84
2C4A:  CLRF   x85
2C4C:  CLRF   x86
2C4E:  CLRF   x87
2C50:  CLRF   x88
2C52:  CLRF   x89
2C54:  CLRF   x8B
2C56:  CLRF   x8A
2C58:  CLRF   x8D
2C5A:  CLRF   x8C
2C5C:  CLRF   x8F
2C5E:  CLRF   x8E
2C60:  CLRF   x91
2C62:  CLRF   x90
2C64:  CLRF   x93
2C66:  CLRF   x92
2C68:  CLRF   x95
2C6A:  CLRF   x94
2C6C:  CLRF   x98
2C6E:  CLRF   x99
2C70:  CLRF   x9A
2C72:  CLRF   xAD
2C74:  CLRF   xAE
2C76:  CLRF   xB0
2C78:  CLRF   xAF
2C7A:  CLRF   xEC
2C7C:  CLRF   xED
2C7E:  MOVF   FC1,W
2C80:  ANDLW  C0
2C82:  IORLW  0F
2C84:  MOVWF  FC1
2C86:  MOVLW  07
2C88:  MOVWF  FB4
2C8A:  BRA    2D36
2C8C:  DATA 02,00
2C8E:  DATA 19,00
2C90:  DATA 00,05
2C92:  DATA 01,04
2C94:  DATA 56,35
2C96:  DATA 2E,30
2C98:  DATA 31,05
2C9A:  DATA C0,20
2C9C:  DATA 6E,80
2C9E:  DATA 0D,00
2CA0:  DATA 42,4F
2CA2:  DATA 52,52
2CA4:  DATA 41,52
2CA6:  DATA 5F,41
2CA8:  DATA 4C,4C
2CAA:  DATA 0D,00
2CAC:  DATA 47,52
2CAE:  DATA 41,42
2CB0:  DATA 41,52
2CB2:  DATA 5F,44
2CB4:  DATA 41,54
2CB6:  DATA 0D,00
2CB8:  DATA 4C,45
2CBA:  DATA 45,52
2CBC:  DATA 43,55
2CBE:  DATA 45,4E
2CC0:  DATA 54,41
2CC2:  DATA 0D,00
2CC4:  DATA 53,4F
2CC6:  DATA 4C,49
2CC8:  DATA 43,49
2CCA:  DATA 54,41
2CCC:  DATA 44,4F
2CCE:  DATA 0D,00
2CD0:  DATA 50,41
2CD2:  DATA 53,41
2CD4:  DATA 4A,45
2CD6:  DATA 52,4F
2CD8:  DATA 53,3A
2CDA:  DATA 0D,00
2CDC:  DATA 53,45
2CDE:  DATA 52,49
2CE0:  DATA 41,4C
2CE2:  DATA 54,45
2CE4:  DATA 53,54
2CE6:  DATA 0D,00
2CE8:  DATA 53,45
2CEA:  DATA 52,49
2CEC:  DATA 41,4C
2CEE:  DATA 5F,54
2CF0:  DATA 4F,4B
2CF2:  DATA 0D,00
2CF4:  DATA 53,55
2CF6:  DATA 42,49
2CF8:  DATA 45,4E
2CFA:  DATA 44,4F
2CFC:  DATA 43,32
2CFE:  DATA 0D,00
2D00:  DATA 53,49
2D02:  DATA 4E,46
2D04:  DATA 55,4E
2D06:  DATA 43,49
2D08:  DATA 4F,4E
2D0A:  DATA 0D,00
2D0C:  DATA 0A,C0
2D0E:  DATA 20,02
2D10:  DATA 80,0D
2D12:  DATA 00,16
2D14:  DATA 00,EE
2D16:  DATA 04,01
2D18:  DATA 10,01
2D1A:  DATA 1C,01
2D1C:  DATA 28,01
2D1E:  DATA 34,01
2D20:  DATA 40,01
2D22:  DATA 4C,01
2D24:  DATA 58,01
2D26:  DATA 64,01
2D28:  DATA 70,01
2D2A:  DATA 7C,01
2D2C:  DATA 06,01
2D2E:  DATA 88,56
2D30:  DATA 35,2E
2D32:  DATA 30,32
2D34:  DATA 00,00
2D36:  MOVLW  00
2D38:  MOVWF  FF8
2D3A:  MOVLW  2C
2D3C:  MOVWF  FF7
2D3E:  MOVLW  8C
2D40:  MOVWF  FF6
2D42:  TBLRD*+
2D44:  MOVF   FF5,W
2D46:  MOVWF  00
2D48:  XORLW  00
2D4A:  BZ    2D72
2D4C:  TBLRD*+
2D4E:  MOVF   FF5,W
2D50:  MOVWF  01
2D52:  BTFSC  FE8.7
2D54:  BRA    2D60
2D56:  ANDLW  0F
2D58:  MOVWF  FEA
2D5A:  TBLRD*+
2D5C:  MOVFF  FF5,FE9
2D60:  BTFSC  01.6
2D62:  TBLRD*+
2D64:  BTFSS  01.6
2D66:  TBLRD*+
2D68:  MOVFF  FF5,FEE
2D6C:  DCFSNZ 00,F
2D6E:  BRA    2D42
2D70:  BRA    2D64
2D72:  CLRF   FF8
.................... //Apaga entradas analogicas 
.................... setup_adc_ports(NO_ANALOGS); 
2D74:  MOVF   FC1,W
2D76:  ANDLW  C0
2D78:  IORLW  0F
2D7A:  MOVWF  FC1
.................... setup_adc(ADC_OFF); 
2D7C:  BCF    FC2.0
.................... lcd_init();//inicia LCD 
2D7E:  GOTO   04C2
.................... init_ext_eeprom();//Inicia EEPROM 
2D82:  GOTO   0536
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Configura timer1:Reloj interno, preescaler=8 
2D86:  MOVLW  B5
2D88:  MOVWF  FCD
.................... enable_interrupts(INT_TIMER1);//Habilito interrupcin particular del TIMER1 
2D8A:  BSF    F9D.0
.................... set_timer1(set_timer);//Setea cuenta para la interrupcion. 
2D8C:  MOVLW  E7
2D8E:  MOVWF  FCF
2D90:  MOVLW  96
2D92:  MOVWF  FCE
.................... disable_interrupts(INT_EXT);//desabilita interrupciones externas 
2D94:  BCF    FF2.4
.................... enable_interrupts(GLOBAL);//habilita interrupciones globales 
2D96:  MOVLW  C0
2D98:  IORWF  FF2,F
.................... ///**************************************************************************/// 
.................... ////////Confuguracion de PWM//////// 
.................... output_low(PIN_C2);//CCP1 
2D9A:  BCF    F94.2
2D9C:  BCF    F8B.2
.................... setup_ccp1(CCP_PWM); 
2D9E:  BCF    F94.2
2DA0:  BCF    F8B.2
2DA2:  MOVLW  0C
2DA4:  MOVWF  FBD
.................... setup_timer_2(t2_div_By_1,131,1);//frecuencia 38khz 
2DA6:  MOVLW  00
2DA8:  IORLW  04
2DAA:  MOVWF  FCA
2DAC:  MOVLW  83
2DAE:  MOVWF  FCB
.................... //set_pwm1_duty(26);//(5%) alto 
.................... set_pwm1_duty(279);//(10%) Parte alta del ciclo  
2DB0:  MOVLW  45
2DB2:  MOVWF  FBE
2DB4:  MOVF   FBD,W
2DB6:  ANDLW  CF
2DB8:  IORLW  30
2DBA:  MOVWF  FBD
.................... //////////////////////////////////// 
.................... ini=read_eeprom(100);//Carga estado de inicio 
2DBC:  MOVFF  FF2,1CD
2DC0:  BCF    FF2.7
2DC2:  MOVLW  64
2DC4:  MOVWF  FA9
2DC6:  BCF    FA6.6
2DC8:  BCF    FA6.7
2DCA:  BSF    FA6.0
2DCC:  MOVF   FA8,W
2DCE:  MOVLB  1
2DD0:  BTFSC  xCD.7
2DD2:  BSF    FF2.7
2DD4:  MOVWF  40
.................... if(ini!=1){//Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
2DD6:  DECFSZ 40,W
2DD8:  BRA    2DDC
2DDA:  BRA    2E0E
....................    write_eeprom(100,1);//Graba inicio 
2DDC:  MOVF   FF2,W
2DDE:  MOVWF  00
2DE0:  BCF    FF2.7
2DE2:  MOVLW  64
2DE4:  MOVWF  FA9
2DE6:  MOVLW  01
2DE8:  MOVWF  FA8
2DEA:  BCF    FA6.6
2DEC:  BCF    FA6.7
2DEE:  BSF    FA6.2
2DF0:  MOVLB  F
2DF2:  MOVLW  55
2DF4:  MOVWF  FA7
2DF6:  MOVLW  AA
2DF8:  MOVWF  FA7
2DFA:  BSF    FA6.1
2DFC:  BTFSC  FA6.1
2DFE:  BRA    2DFC
2E00:  BCF    FA6.2
2E02:  MOVF   00,W
2E04:  IORWF  FF2,F
....................    limpiar();//pone en 0 el registro de cuentas almacenadas. 
2E06:  MOVLB  0
2E08:  CALL   0D1C
2E0C:  MOVLB  1
.................... } 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... entraron_total();//carga el total de entradas registradas 
2E0E:  MOVLB  0
2E10:  GOTO   0D88
.................... salieron_total();//carga el total de salidas registradas 
2E14:  GOTO   0DE2
.................... ent1=ent2=ent3=ent4=ent5=ent6=0;//inicia en 0 variables de estado de sensores 
2E18:  CLRF   5A
2E1A:  MOVFF  5A,59
2E1E:  MOVFF  59,58
2E22:  MOVFF  58,57
2E26:  MOVFF  57,56
2E2A:  MOVFF  56,55
.................... tim_p1=tim_p2=tim_p3=0;//inicia en 0 las cuentas para detectar sensores bloqueados 
2E2E:  CLRF   xA6
2E30:  CLRF   xA5
2E32:  MOVFF  A6,A4
2E36:  MOVFF  A5,A3
2E3A:  MOVFF  A4,A2
2E3E:  MOVFF  A3,A1
.................... en_b1=en_b2=en_b3=0;//bandera de pares bloqueados 
2E42:  CLRF   xA0
2E44:  MOVFF  A0,9F
2E48:  MOVFF  9F,9E
.................... time_envio=0;//inicia en 0 cuenta para transmitir datos 
2E4C:  CLRF   xAA
2E4E:  CLRF   xA9
.................... if(input(frente) ) {//revisa si es maestro (1) o escalvo (2) 
2E50:  BSF    F95.2
2E52:  BTFSS  F83.2
2E54:  BRA    2E60
....................    master=1; 
2E56:  MOVLW  01
2E58:  MOVWF  45
....................    size_s=29; 
2E5A:  MOVLW  1D
2E5C:  MOVWF  22
.................... } 
2E5E:  BRA    2E66
.................... else { 
....................    master=0; 
2E60:  CLRF   45
....................    size_s=15; 
2E62:  MOVLW  0F
2E64:  MOVWF  22
.................... } 
.................... lcd_cuentas();//Escribe texto base en LCD 
2E66:  CALL   0A64
.................... cta_bloq1=read_ext_eeprom(9);//carga bloqueos acumulados en par1 
2E6A:  MOVLB  1
2E6C:  CLRF   xD2
2E6E:  MOVLW  09
2E70:  MOVWF  xD1
2E72:  MOVLB  0
2E74:  CALL   0774
2E78:  MOVFF  01,52
.................... cta_bloq2=read_ext_eeprom(10);//carga bloqueos acumulados en par2 
2E7C:  MOVLB  1
2E7E:  CLRF   xD2
2E80:  MOVLW  0A
2E82:  MOVWF  xD1
2E84:  MOVLB  0
2E86:  CALL   0774
2E8A:  MOVFF  01,53
.................... cta_bloq3=read_ext_eeprom(11);//carga bloqueos acumulados en par3 
2E8E:  MOVLB  1
2E90:  CLRF   xD2
2E92:  MOVLW  0B
2E94:  MOVWF  xD1
2E96:  MOVLB  0
2E98:  CALL   0774
2E9C:  MOVFF  01,54
.................... int tem_res; 
.................... tem_res=input(rst_cta);//inicializa variable de reset de cuenta fisico 
2EA0:  BSF    F95.3
2EA2:  MOVLB  1
2EA4:  CLRF   xCC
2EA6:  BTFSC  F83.3
2EA8:  INCF   xCC,F
.................... j=0; 
2EAA:  CLRF   43
.................... flag_enviar=0; 
2EAC:  CLRF   46
.................... salian=0; 
2EAE:  CLRF   3D
2EB0:  CLRF   3C
.................... enable_interrupts(INT_RDA);//habilita interrupcion serial 
2EB2:  BSF    F9D.5
.................... setup_wdt(WDT_ON);//habilita watch dog 
2EB4:  BSF    FD1.0
.................... sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
2EB6:  MOVLB  0
2EB8:  CLRF   x68
2EBA:  CLRF   x67
2EBC:  MOVFF  68,66
2EC0:  MOVFF  67,65
2EC4:  MOVFF  66,64
2EC8:  MOVFF  65,63
2ECC:  MOVFF  64,62
2ED0:  MOVFF  63,61
2ED4:  MOVFF  62,60
2ED8:  MOVFF  61,5F
2EDC:  MOVFF  60,5E
2EE0:  MOVFF  5F,5D
.................... tem_entraront=tem_salieront=0; 
2EE4:  CLRF   x95
2EE6:  CLRF   x94
2EE8:  MOVFF  95,93
2EEC:  MOVFF  94,92
.................... error=0; 
2EF0:  CLRF   23
.................... reset();//Revisa causa de inicio del pic 
2EF2:  GOTO   0E5E
.................... transmitir=0; 
2EF6:  CLRF   24
.................... output_low(salida02); 
2EF8:  BCF    F94.4
2EFA:  BCF    F8B.4
.................... sub_atras=baj_atras=0; 
2EFC:  CLRF   37
2EFE:  CLRF   36
2F00:  MOVFF  37,35
2F04:  MOVFF  36,34
.................... clear_lcd1=0; 
2F08:  CLRF   xAB
....................  
.................... output_low(HB); //esperamos a que se aliste un dato del puerto serial emulado 
2F0A:  BCF    F96.0
2F0C:  BCF    F8D.0
.................... bandera_revision=1; 
2F0E:  MOVLW  01
2F10:  MOVWF  xAE
.................... caso_valor=0; 
2F12:  CLRF   xEC
....................  
.................... while(TRUE){ 
.................... //solo para reinicializar interrupciones despues de obtener datos por puerto serial nato 
....................  if(y==1){ 
2F14:  DECFSZ xAD,W
2F16:  BRA    2F1E
....................   enable_interrupts(GLOBAL);//habilita interrupciones globales 
2F18:  MOVLW  C0
2F1A:  IORWF  FF2,F
....................   y=0; 
2F1C:  CLRF   xAD
....................  } 
.................... //////////////////////boton para reset cuenta//////////////////////////////////////////// 
....................    if(tem_res!=input(rst_cta) ){//BOTON DE RESET DE CUENTA 
2F1E:  BSF    F95.3
2F20:  MOVLW  00
2F22:  BTFSC  F83.3
2F24:  MOVLW  01
2F26:  MOVLB  1
2F28:  SUBWF  xCC,W
2F2A:  BZ    2F74
....................       delay_ms(50); 
2F2C:  MOVLW  32
2F2E:  MOVWF  xD8
2F30:  MOVLB  0
2F32:  CALL   040A
....................       if(tem_res!=input(rst_cta) ){ 
2F36:  BSF    F95.3
2F38:  MOVLW  00
2F3A:  BTFSC  F83.3
2F3C:  MOVLW  01
2F3E:  MOVLB  1
2F40:  SUBWF  xCC,W
2F42:  BZ    2F74
....................          tem_res=input(rst_cta); 
2F44:  BSF    F95.3
2F46:  CLRF   xCC
2F48:  BTFSC  F83.3
2F4A:  INCF   xCC,F
....................          if( (master==1)&&(tem_res==0) ) { 
2F4C:  DECFSZ 45,W
2F4E:  BRA    2F74
2F50:  MOVF   xCC,F
2F52:  BNZ   2F74
....................             fprintf(monitor,"BORRAR_ALL\r"); 
2F54:  MOVLW  EA
2F56:  MOVWF  FF6
2F58:  MOVLW  00
2F5A:  MOVWF  FF7
2F5C:  MOVLB  0
2F5E:  CALL   0E3C
....................             printf(lcd_putc,"\fBORRAR_ALL"); 
2F62:  MOVLW  8A
2F64:  MOVWF  FF6
2F66:  MOVLW  02
2F68:  MOVWF  FF7
2F6A:  CALL   0A44
....................             limpiar(); 
2F6E:  CALL   0D1C
2F72:  MOVLB  1
....................          } 
....................       } 
....................    } 
.................... //-------pines de monitoreo de datos seriales por puerto emulado---------------------------- 
.................... if(input(EN) == 1  && bandera_revision == 1){ //1 
2F74:  BSF    F96.1
2F76:  BTFSS  F84.1
2F78:  BRA    3018
2F7A:  MOVLB  0
2F7C:  DECFSZ xAE,W
2F7E:  BRA    2F82
2F80:  BRA    2F86
2F82:  MOVLB  1
2F84:  BRA    3018
....................      output_high(HB); //avisa que ya est listo para recibir dato serial 
2F86:  BCF    F96.0
2F88:  BSF    F8D.0
....................      cntbnd=0;  
2F8A:  CLRF   xB0
2F8C:  CLRF   xAF
....................      //i=0; 
....................      bandera_revision=0; 
2F8E:  CLRF   xAE
....................      output_high(salida03); 
2F90:  BCF    F94.5
2F92:  BSF    F8B.5
....................      //fprintf(monitor,"relay-");   
....................       while (kbhit(GPS)!=1 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
2F94:  MOVLW  00
2F96:  BTFSS  F82.0
2F98:  MOVLW  01
2F9A:  SUBLW  01
2F9C:  BNZ   2FA8
2F9E:  MOVF   xB0,F
2FA0:  BNZ   2FA8
2FA2:  MOVF   xAF,W
2FA4:  SUBLW  C7
2FA6:  BC    2FAE
....................       //while (XX[0]==0 || cntbnd >= 200) /// espera a que se complete dato serial o timer se agote 
....................       { 
....................         bandera_revision=1; 
2FA8:  MOVLW  01
2FAA:  MOVWF  xAE
2FAC:  BRA    2F94
....................         //fprintf(monitor,"wh-"); 
....................       }  
....................       XX[0] = fgetc(GPS); 
2FAE:  GOTO   0E96
2FB2:  MOVFF  01,18E
....................      /* 
....................       while(i<=30){ 
....................       XX[i] = fgetc(GPS); 
....................       fprintf(monitor,"."); 
....................       i++; 
....................       if(XX[i]==13)break; 
....................       };//se captura el dato del serial monitor(comunicacion entre pics) 
....................      */ 
....................      // si el comando es ?, es coomando valido de solicitud de borrar cuenta 
....................     // fprintf(monitor,"<"); 
....................     // fprintf(monitor,"%c",XX[0]); 
....................     // fprintf(monitor,">"); 
....................      if(XX[0]==63) 
2FB6:  MOVLB  1
2FB8:  MOVF   x8E,W
2FBA:  SUBLW  3F
2FBC:  BNZ   3018
....................      { 
....................      output_low(salida03); 
2FBE:  BCF    F94.5
2FC0:  BCF    F8B.5
....................          j=1; 
2FC2:  MOVLW  01
2FC4:  MOVWF  43
....................          sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; //se inicializa cuenta pasajeros 
2FC6:  MOVLB  0
2FC8:  CLRF   x68
2FCA:  CLRF   x67
2FCC:  MOVFF  68,66
2FD0:  MOVFF  67,65
2FD4:  MOVFF  66,64
2FD8:  MOVFF  65,63
2FDC:  MOVFF  64,62
2FE0:  MOVFF  63,61
2FE4:  MOVFF  62,60
2FE8:  MOVFF  61,5F
2FEC:  MOVFF  60,5E
2FF0:  MOVFF  5F,5D
....................          solicitud_reset_gps=1; 
2FF4:  MOVWF  xED
....................          /* 
....................          XX[0] = 'B'; 
....................          XX[1] = 'O'; 
....................          XX[2] = 'R'; 
....................          XX[3] = 'R'; 
....................          XX[4] = 'A'; 
....................          XX[5] = 'R'; 
....................          XX[6] = '_'; 
....................          XX[7] = 'A'; 
....................          XX[8] = 'L'; 
....................          XX[9] = 'L'; 
....................          XX[10] = '\n'; 
....................          */ 
....................          strcpy(XX,"BORRAR_ALL\r");  //BORRAR_ALL\r   
2FF6:  MOVWF  FEA
2FF8:  MOVLW  8E
2FFA:  MOVWF  FE9
2FFC:  MOVLW  00
2FFE:  CALL   00DA
3002:  TBLRD*-
3004:  TBLRD*+
3006:  MOVF   FF5,W
3008:  MOVWF  FEE
300A:  IORLW  00
300C:  BNZ   3004
....................          output_low(HB); // se reinicia la espera de nuevo dato serial 
300E:  BCF    F96.0
3010:  BCF    F8D.0
....................          bandera_revision=1; 
3012:  MOVLW  01
3014:  MOVWF  xAE
3016:  MOVLB  1
....................      } 
....................   
....................   
.................... } 
....................  //------------------------------------------------------------------------------  
....................  
....................    if(j==1){//Revisa si hubo datos por cualquiera de los 2 puertos seriales 
3018:  DECFSZ 43,W
301A:  BRA    31DC
....................       rd_eeprom();//valida dato recibido para ver si es una palabra de control 
301C:  MOVLB  0
301E:  GOTO   0F0E
....................       caso_valor = evaluar_string(XX); 
3022:  MOVLW  01
3024:  MOVLB  1
3026:  MOVWF  xCE
3028:  MOVLW  8E
302A:  MOVWF  xCD
302C:  MOVLB  0
302E:  GOTO   1032
3032:  MOVFF  01,EC
....................       lcd_gotoxy(9,1); 
3036:  MOVLW  09
3038:  MOVLB  1
303A:  MOVWF  xD8
303C:  MOVLW  01
303E:  MOVWF  xD9
3040:  MOVLB  0
3042:  CALL   086E
....................       printf(lcd_putc,"%d ",caso_valor);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
3046:  MOVFF  EC,1CD
304A:  MOVLW  18
304C:  MOVLB  1
304E:  MOVWF  xCE
3050:  MOVLB  0
3052:  CALL   10EC
3056:  MOVLW  20
3058:  MOVLB  1
305A:  MOVWF  xD7
305C:  MOVLB  0
305E:  CALL   08C0
....................  
....................       switch (caso_valor) { 
3062:  MOVF   xEC,W
3064:  XORLW  01
3066:  BZ    3088
3068:  XORLW  03
306A:  BZ    30B4
306C:  XORLW  01
306E:  BZ    30BA
3070:  XORLW  07
3072:  BZ    30F8
3074:  XORLW  01
3076:  BZ    30FE
3078:  XORLW  03
307A:  BZ    3126
307C:  XORLW  01
307E:  BZ    3156
3080:  XORLW  0F
3082:  BTFSC  FD8.2
3084:  BRA    317A
3086:  BRA    319E
....................           case 1: {//Se pone en 0 la cuenta 
....................                   limpiar(); 
3088:  CALL   0D1C
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
308C:  DECFSZ 45,W
308E:  BRA    309C
3090:  MOVLW  96
3092:  MOVWF  FF6
3094:  MOVLW  02
3096:  MOVWF  FF7
3098:  CALL   0E3C
....................                   if(solicitud_reset_gps==1 && master==1){ 
309C:  DECFSZ xED,W
309E:  BRA    30B2
30A0:  DECFSZ 45,W
30A2:  BRA    30B2
....................                   solicitud_reset_gps=0; 
30A4:  CLRF   xED
....................                   fprintf(GPS,"RESET_OK\r\n");//confirma a gsm 
30A6:  MOVLW  A2
30A8:  MOVWF  FF6
30AA:  MOVLW  02
30AC:  MOVWF  FF7
30AE:  CALL   11FE
....................                   } 
....................                   break;} 
30B2:  BRA    31BA
....................           case 2: {//Se hace solicitud de cuenta del poste trasero 
....................                   solicitar(); 
30B4:  CALL   121E
....................                   break;} 
30B8:  BRA    31BA
....................           case 3: {//Se pone en 0 la cuenta por peticion del GPRS 
....................                   if(master==1) fprintf(GPS,"RESET_OK\r\n");//confirma a gsm  
30BA:  DECFSZ 45,W
30BC:  BRA    30CA
30BE:  MOVLW  AE
30C0:  MOVWF  FF6
30C2:  MOVLW  02
30C4:  MOVWF  FF7
30C6:  CALL   11FE
....................                   delay_ms(1000); 
30CA:  MOVLW  04
30CC:  MOVLB  1
30CE:  MOVWF  xCD
30D0:  MOVLW  FA
30D2:  MOVWF  xD8
30D4:  MOVLB  0
30D6:  CALL   040A
30DA:  MOVLB  1
30DC:  DECFSZ xCD,F
30DE:  BRA    30D0
....................                   limpiar(); 
30E0:  MOVLB  0
30E2:  CALL   0D1C
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
30E6:  DECFSZ 45,W
30E8:  BRA    30F6
30EA:  MOVLW  BA
30EC:  MOVWF  FF6
30EE:  MOVLW  02
30F0:  MOVWF  FF7
30F2:  CALL   0E3C
....................                   break;} 
30F6:  BRA    31BA
....................           case 4: {//ver pasaje total de este acceso (contador atras) 
....................                   envio_master(); 
30F8:  CALL   1236
....................                   break;} 
30FC:  BRA    31BA
....................           case 5: {//envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................                   flag_enviar=0; 
30FE:  CLRF   46
....................                   enviop1(); 
3100:  GOTO   16F4
....................                   transmitir=1; 
3104:  MOVLW  01
3106:  MOVWF  24
....................                   lcd_gotoxy(9,4); 
3108:  MOVLW  09
310A:  MOVLB  1
310C:  MOVWF  xD8
310E:  MOVLW  04
3110:  MOVWF  xD9
3112:  MOVLB  0
3114:  CALL   086E
....................                   lcd_putc("C2OK"); 
3118:  MOVLW  C6
311A:  MOVWF  FF6
311C:  MOVLW  02
311E:  MOVWF  FF7
3120:  CALL   0A44
....................                    
....................                   break;} 
3124:  BRA    31BA
....................           case 6: {//TEST DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
3126:  MOVLW  01
3128:  MOVWF  xAB
....................                   time_lcd1=0; 
312A:  CLRF   xAC
....................                   lcd_gotoxy(9,3); 
312C:  MOVLW  09
312E:  MOVLB  1
3130:  MOVWF  xD8
3132:  MOVLW  03
3134:  MOVWF  xD9
3136:  MOVLB  0
3138:  CALL   086E
....................                   lcd_putc("C1OK"); 
313C:  MOVLW  CC
313E:  MOVWF  FF6
3140:  MOVLW  02
3142:  MOVWF  FF7
3144:  CALL   0A44
....................                   fprintf(monitor,"SERIAL_TOK\r");// 
3148:  MOVLW  D2
314A:  MOVWF  FF6
314C:  MOVLW  02
314E:  MOVWF  FF7
3150:  CALL   0E3C
....................                   break;} 
3154:  BRA    31BA
....................           case 7: {//CONFIRMACION DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
3156:  MOVLW  01
3158:  MOVWF  xAB
....................                   time_lcd1=0; 
315A:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
315C:  MOVLW  09
315E:  MOVLB  1
3160:  MOVWF  xD8
3162:  MOVLW  04
3164:  MOVWF  xD9
3166:  MOVLB  0
3168:  CALL   086E
....................                   lcd_putc("C2OK"); 
316C:  MOVLW  DE
316E:  MOVWF  FF6
3170:  MOVLW  02
3172:  MOVWF  FF7
3174:  CALL   0A44
....................                   break;} 
3178:  BRA    31BA
....................           case 8: {//Suben por atras 
....................                   clear_lcd1=1; 
317A:  MOVLW  01
317C:  MOVWF  xAB
....................                   time_lcd1=0; 
317E:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
3180:  MOVLW  09
3182:  MOVLB  1
3184:  MOVWF  xD8
3186:  MOVLW  04
3188:  MOVWF  xD9
318A:  MOVLB  0
318C:  CALL   086E
....................                   lcd_putc("Sub2"); 
3190:  MOVLW  E4
3192:  MOVWF  FF6
3194:  MOVLW  02
3196:  MOVWF  FF7
3198:  CALL   0A44
....................                   break;} 
319C:  BRA    31BA
....................           default:{ 
....................                   lcd_gotoxy(9,2); 
319E:  MOVLW  09
31A0:  MOVLB  1
31A2:  MOVWF  xD8
31A4:  MOVLW  02
31A6:  MOVWF  xD9
31A8:  MOVLB  0
31AA:  CALL   086E
....................                   printf(lcd_putc,"c=0"); 
31AE:  MOVLW  EA
31B0:  MOVWF  FF6
31B2:  MOVLW  02
31B4:  MOVWF  FF7
31B6:  CALL   0A44
....................                   } 
....................       }//end switch 
....................  
....................       caso_valor=0; 
31BA:  CLRF   xEC
....................       memset(XX, 0, sizeof(XX) ); 
31BC:  MOVLW  01
31BE:  MOVWF  FEA
31C0:  MOVLW  8E
31C2:  MOVWF  FE9
31C4:  CLRF   00
31C6:  CLRF   02
31C8:  MOVLW  20
31CA:  MOVWF  01
31CC:  CALL   128C
....................       time_clr=0; 
31D0:  CLRF   3F
31D2:  CLRF   3E
....................       f_clr=1; 
31D4:  MOVLW  01
31D6:  MOVWF  47
....................       j=0; 
31D8:  CLRF   43
31DA:  MOVLB  1
....................    } 
....................     if( (time_envio>=180)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
31DC:  MOVLB  0
31DE:  MOVF   xAA,F
31E0:  BNZ   31E8
31E2:  MOVF   xA9,W
31E4:  SUBLW  B3
31E6:  BC    31F0
31E8:  MOVF   45,F
31EA:  BZ    31F0
....................          solicitar(); 
31EC:  CALL   121E
....................          
....................    } 
....................    if( (clear_lcd1)&&(time_lcd1>=10) ){//cronometro para limpiar notificaciones LCD 
31F0:  MOVF   xAB,F
31F2:  BZ    3250
31F4:  MOVF   xAC,W
31F6:  SUBLW  09
31F8:  BC    3250
....................       clear_lcd1=0; 
31FA:  CLRF   xAB
....................       lcd_gotoxy(9,1); 
31FC:  MOVLW  09
31FE:  MOVLB  1
3200:  MOVWF  xD8
3202:  MOVLW  01
3204:  MOVWF  xD9
3206:  MOVLB  0
3208:  CALL   086E
....................       lcd_putc("    "); 
320C:  MOVLW  EE
320E:  MOVWF  FF6
3210:  MOVLW  02
3212:  MOVWF  FF7
3214:  CALL   0A44
....................       lcd_gotoxy(9,3); 
3218:  MOVLW  09
321A:  MOVLB  1
321C:  MOVWF  xD8
321E:  MOVLW  03
3220:  MOVWF  xD9
3222:  MOVLB  0
3224:  CALL   086E
....................       lcd_putc("    "); 
3228:  MOVLW  F4
322A:  MOVWF  FF6
322C:  MOVLW  02
322E:  MOVWF  FF7
3230:  CALL   0A44
....................       lcd_gotoxy(9,4); 
3234:  MOVLW  09
3236:  MOVLB  1
3238:  MOVWF  xD8
323A:  MOVLW  04
323C:  MOVWF  xD9
323E:  MOVLB  0
3240:  CALL   086E
....................       lcd_putc("    "); 
3244:  MOVLW  FA
3246:  MOVWF  FF6
3248:  MOVLW  02
324A:  MOVWF  FF7
324C:  CALL   0A44
....................    } 
....................     
....................    if( (flag_enviar)&&(cta_enviar>=2000)&&(master) ) envia2();//Si el poste esclavo no contesta enviar sin conexion 
3250:  MOVF   46,F
3252:  BZ    326C
3254:  MOVF   4F,W
3256:  SUBLW  06
3258:  BC    326C
325A:  XORLW  FF
325C:  BNZ   3264
325E:  MOVF   4E,W
3260:  SUBLW  CF
3262:  BC    326C
3264:  MOVF   45,F
3266:  BTFSS  FD8.2
3268:  GOTO   1AC6
....................    if(transmitir) envio();//cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
326C:  MOVF   24,F
326E:  BTFSC  FD8.2
3270:  BRA    3276
3272:  GOTO   1C1C
....................     
....................    if( (bloq_p1)&&(tim_p1>=time_bloqueo)&&(!en_b1) ) {//bloqueo de par 1 por ms de X segundos 
3276:  MOVF   x9B,F
3278:  BZ    32E6
327A:  MOVF   xA2,W
327C:  SUBLW  00
327E:  BC    32E6
3280:  XORLW  FF
3282:  BNZ   328A
3284:  MOVF   xA1,W
3286:  SUBLW  F3
3288:  BC    32E6
328A:  MOVF   x9E,F
328C:  BNZ   32E6
....................        bloq_p1=0;//bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
328E:  CLRF   x9B
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){//si no habia un bloqueo antes 
3290:  MOVF   x9E,F
3292:  BNZ   32E2
3294:  MOVF   x9F,F
3296:  BNZ   32E2
3298:  MOVF   xA0,F
329A:  BNZ   32E2
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
329C:  MOVLW  0A
329E:  MOVLB  1
32A0:  MOVWF  xD8
32A2:  MOVLW  01
32A4:  MOVWF  xD9
32A6:  MOVLB  0
32A8:  CALL   086E
....................             lcd_putc("BL"); 
32AC:  MOVLW  00
32AE:  MOVWF  FF6
32B0:  MOVLW  03
32B2:  MOVWF  FF7
32B4:  CALL   0A44
....................             cta_bloq1++; 
32B8:  INCF   52,F
....................             write_ext_eeprom(9,cta_bloq1);//bloq1 
32BA:  MOVLB  1
32BC:  CLRF   xD2
32BE:  MOVLW  09
32C0:  MOVWF  xD1
32C2:  MOVFF  52,1D3
32C6:  MOVLB  0
32C8:  CALL   05B4
....................             if( (master==1)&&(j==0) ) solicitar(); 
32CC:  DECFSZ 45,W
32CE:  BRA    32DA
32D0:  MOVF   43,F
32D2:  BNZ   32DA
32D4:  CALL   121E
32D8:  BRA    32E2
....................             else if(j==0) envio_master(); 
32DA:  MOVF   43,F
32DC:  BTFSC  FD8.2
32DE:  CALL   1236
....................        } 
....................        en_b1=1;//bandera de bloqueo detectado en par 1 
32E2:  MOVLW  01
32E4:  MOVWF  x9E
....................    } 
....................    if( (bloq_p2)&&(tim_p2>=time_bloqueo)&&(!en_b2) ) {//bloqueo de par 2 por ms de X segundos 
32E6:  MOVF   x9C,F
32E8:  BZ    3356
32EA:  MOVF   xA4,W
32EC:  SUBLW  00
32EE:  BC    3356
32F0:  XORLW  FF
32F2:  BNZ   32FA
32F4:  MOVF   xA3,W
32F6:  SUBLW  F3
32F8:  BC    3356
32FA:  MOVF   x9F,F
32FC:  BNZ   3356
....................        bloq_p2=0; 
32FE:  CLRF   x9C
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3300:  MOVF   x9E,F
3302:  BNZ   3352
3304:  MOVF   x9F,F
3306:  BNZ   3352
3308:  MOVF   xA0,F
330A:  BNZ   3352
....................            lcd_gotoxy(10,1);//cronometro para limpiar 
330C:  MOVLW  0A
330E:  MOVLB  1
3310:  MOVWF  xD8
3312:  MOVLW  01
3314:  MOVWF  xD9
3316:  MOVLB  0
3318:  CALL   086E
....................            lcd_putc("BL"); 
331C:  MOVLW  04
331E:  MOVWF  FF6
3320:  MOVLW  03
3322:  MOVWF  FF7
3324:  CALL   0A44
....................            cta_bloq2++; 
3328:  INCF   53,F
....................            write_ext_eeprom(10,cta_bloq2);//bloq2 
332A:  MOVLB  1
332C:  CLRF   xD2
332E:  MOVLW  0A
3330:  MOVWF  xD1
3332:  MOVFF  53,1D3
3336:  MOVLB  0
3338:  CALL   05B4
....................            if( (master==1)&&(j==0) ) solicitar(); 
333C:  DECFSZ 45,W
333E:  BRA    334A
3340:  MOVF   43,F
3342:  BNZ   334A
3344:  CALL   121E
3348:  BRA    3352
....................            else if(j==0) envio_master(); 
334A:  MOVF   43,F
334C:  BTFSC  FD8.2
334E:  CALL   1236
....................        } 
....................        en_b2=1; 
3352:  MOVLW  01
3354:  MOVWF  x9F
....................    } 
....................    if( (bloq_p3)&&(tim_p3>=time_bloqueo)&&(!en_b3) ) {//bloqueo de par 3 por ms de X segundos 
3356:  MOVF   x9D,F
3358:  BZ    33C6
335A:  MOVF   xA6,W
335C:  SUBLW  00
335E:  BC    33C6
3360:  XORLW  FF
3362:  BNZ   336A
3364:  MOVF   xA5,W
3366:  SUBLW  F3
3368:  BC    33C6
336A:  MOVF   xA0,F
336C:  BNZ   33C6
....................        bloq_p3=0; 
336E:  CLRF   x9D
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3370:  MOVF   x9E,F
3372:  BNZ   33C2
3374:  MOVF   x9F,F
3376:  BNZ   33C2
3378:  MOVF   xA0,F
337A:  BNZ   33C2
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
337C:  MOVLW  0A
337E:  MOVLB  1
3380:  MOVWF  xD8
3382:  MOVLW  01
3384:  MOVWF  xD9
3386:  MOVLB  0
3388:  CALL   086E
....................             lcd_putc("BL"); 
338C:  MOVLW  08
338E:  MOVWF  FF6
3390:  MOVLW  03
3392:  MOVWF  FF7
3394:  CALL   0A44
....................             cta_bloq3++; 
3398:  INCF   54,F
....................             write_ext_eeprom(11,cta_bloq3);//bloq3 
339A:  MOVLB  1
339C:  CLRF   xD2
339E:  MOVLW  0B
33A0:  MOVWF  xD1
33A2:  MOVFF  54,1D3
33A6:  MOVLB  0
33A8:  CALL   05B4
....................             if( (master==1)&&(j==0) ) solicitar(); 
33AC:  DECFSZ 45,W
33AE:  BRA    33BA
33B0:  MOVF   43,F
33B2:  BNZ   33BA
33B4:  CALL   121E
33B8:  BRA    33C2
....................             else if(j==0) envio_master(); 
33BA:  MOVF   43,F
33BC:  BTFSC  FD8.2
33BE:  CALL   1236
....................        } 
....................        en_b3=1; 
33C2:  MOVLW  01
33C4:  MOVWF  xA0
....................    }//end deteccion 
....................    if( (!bloq_p3)&&(!bloq_p2)&&(!bloq_p1) ){//Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
33C6:  MOVF   x9D,F
33C8:  BNZ   33EE
33CA:  MOVF   x9C,F
33CC:  BNZ   33EE
33CE:  MOVF   x9B,F
33D0:  BNZ   33EE
....................       lcd_gotoxy(10,1); 
33D2:  MOVLW  0A
33D4:  MOVLB  1
33D6:  MOVWF  xD8
33D8:  MOVLW  01
33DA:  MOVWF  xD9
33DC:  MOVLB  0
33DE:  CALL   086E
....................       lcd_putc("  "); 
33E2:  MOVLW  0C
33E4:  MOVWF  FF6
33E6:  MOVLW  03
33E8:  MOVWF  FF7
33EA:  CALL   0A44
....................    } 
....................     
....................    if( (time_clr>=900)&&(f_clr) ){//refresca LCD 
33EE:  MOVF   3F,W
33F0:  SUBLW  02
33F2:  BC    3408
33F4:  XORLW  FF
33F6:  BNZ   33FE
33F8:  MOVF   3E,W
33FA:  SUBLW  83
33FC:  BC    3408
33FE:  MOVF   47,F
3400:  BZ    3408
....................         lcd_cuentas(); 
3402:  CALL   0A64
....................          f_clr=0; 
3406:  CLRF   47
....................    } 
....................    sensores();//Revisa estado de los sensores 
3408:  GOTO   285A
....................        
....................    restart_wdt(); 
340C:  CLRWDT
340E:  BRA    2F14
....................  }//end true 
.................... }//end main 
....................  
3410:  SLEEP 
.................... void solicitar(){//Solicita cuenta al poste esclavo 
....................    fprintf(monitor,"SOLICITADO\r");//4 
*
121E:  MOVLW  10
1220:  MOVWF  FF6
1222:  MOVLW  03
1224:  MOVWF  FF7
1226:  RCALL  0E3C
....................    time_envio=0; 
1228:  CLRF   xAA
122A:  CLRF   xA9
....................    flag_enviar=1; 
122C:  MOVLW  01
122E:  MOVWF  46
....................    cta_enviar=0; 
1230:  CLRF   4F
1232:  CLRF   4E
1234:  RETURN 0
.................... } 
....................  
.................... void envio_master(){//reporta al maestro 
....................     int16 envit; 
....................     envit=(entraront + salieront)/2; 
1236:  MOVF   x8C,W
1238:  ADDWF  x8A,W
123A:  MOVLB  1
123C:  MOVWF  xCF
123E:  MOVLB  0
1240:  MOVF   x8D,W
1242:  ADDWFC x8B,W
1244:  MOVLB  1
1246:  MOVWF  xD0
1248:  BCF    FD8.0
124A:  RRCF   xD0,W
124C:  MOVWF  xCE
124E:  RRCF   xCF,W
1250:  MOVWF  xCD
....................     cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1252:  MOVF   53,W
1254:  ADDWF  52,W
1256:  ADDWF  54,W
1258:  MOVWF  4C
125A:  CLRF   4D
....................     clear_lcd1=1; 
125C:  MOVLW  01
125E:  MOVLB  0
1260:  MOVWF  xAB
....................     time_lcd1=0; 
1262:  CLRF   xAC
....................     lcd_gotoxy(9,3);//cronometro para limpiar 
1264:  MOVLW  09
1266:  MOVLB  1
1268:  MOVWF  xD8
126A:  MOVLW  03
126C:  MOVWF  xD9
126E:  MOVLB  0
1270:  CALL   086E
....................     lcd_putc(0xAB); 
1274:  MOVLW  AB
1276:  MOVLB  1
1278:  MOVWF  xD7
127A:  MOVLB  0
127C:  CALL   08C0
....................     //fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
....................     fprintf(monitor,"PASAJEROS:\r"); 
1280:  MOVLW  1C
1282:  MOVWF  FF6
1284:  MOVLW  03
1286:  MOVWF  FF7
1288:  RCALL  0E3C
128A:  RETURN 0
.................... } 
....................  
.................... int convertir_to_entero(char *cadena) { 
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
....................    else if(cadena=='1') valor=1; 
....................    else if(cadena=='2') valor=2; 
....................    else if(cadena=='3') valor=3; 
....................    else if(cadena=='4') valor=4; 
....................    else if(cadena=='5') valor=5; 
....................    else if(cadena=='6') valor=6; 
....................    else if(cadena=='7') valor=7; 
....................    else if(cadena=='8') valor=8; 
....................    else if(cadena=='9') valor=9; 
....................    return valor; 
.................... } 
....................  
.................... void enviop1(){//Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
16F4:  BCF    F9D.5
....................    entran1=0; 
16F6:  CLRF   39
16F8:  CLRF   38
....................    salen1=0; 
16FA:  CLRF   3B
16FC:  CLRF   3A
....................    temporal1=0; 
16FE:  CLRF   2F
1700:  CLRF   2E
....................    temporal2=0; 
1702:  CLRF   31
1704:  CLRF   30
....................    temporal3=0; 
1706:  CLRF   x97
1708:  CLRF   x96
....................    tempo_tn=0; 
170A:  CLRF   33
170C:  CLRF   32
....................    pasajet=0; 
170E:  CLRF   x91
1710:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));//entran=0; 
1712:  MOVLW  01
1714:  MOVWF  FEA
1716:  MOVLW  AE
1718:  MOVWF  FE9
171A:  CLRF   00
171C:  CLRF   02
171E:  MOVLW  05
1720:  MOVWF  01
1722:  RCALL  128C
....................    memset(salen, 0, sizeof(salen));//salen=0; 
1724:  MOVLW  01
1726:  MOVWF  FEA
1728:  MOVLW  B3
172A:  MOVWF  FE9
172C:  CLRF   00
172E:  CLRF   02
1730:  MOVLW  05
1732:  MOVWF  01
1734:  RCALL  128C
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
1736:  MOVLW  01
1738:  MOVWF  FEA
173A:  MOVLW  B8
173C:  MOVWF  FE9
173E:  CLRF   00
1740:  CLRF   02
1742:  MOVLW  05
1744:  MOVWF  01
1746:  RCALL  128C
....................    memset(bloqueado, 0, sizeof(tempo_tc));//total 
1748:  MOVLW  01
174A:  MOVWF  FEA
174C:  MOVLW  B8
174E:  MOVWF  FE9
1750:  CLRF   00
1752:  CLRF   02
1754:  MOVLW  05
1756:  MOVWF  01
1758:  RCALL  128C
....................    i=10; 
175A:  MOVLW  0A
175C:  MOVWF  41
....................    ii=0; 
175E:  CLRF   42
....................    strcpy(term,":/"); 
1760:  CLRF   FEA
1762:  MOVLW  B1
1764:  MOVWF  FE9
1766:  MOVLW  00
1768:  CALL   00F6
176C:  TBLRD*-
176E:  TBLRD*+
1770:  MOVF   FF5,W
1772:  MOVWF  FEE
1774:  IORLW  00
1776:  BNZ   176E
....................    ptr = strtok(XX, term); 
1778:  MOVLW  01
177A:  MOVLB  1
177C:  MOVWF  xCF
177E:  MOVLW  8E
1780:  MOVWF  xCE
1782:  CLRF   xD1
1784:  MOVLW  B1
1786:  MOVWF  xD0
1788:  MOVLB  0
178A:  RCALL  13B0
178C:  MOVFF  02,B5
1790:  MOVFF  01,B4
....................  
....................     int conteo_wl=0; 
1794:  MOVLB  1
1796:  CLRF   xCD
....................     
....................          strcpy(data1,ptr);                        // 1ra Palabra 
1798:  CLRF   FEA
179A:  MOVLW  B6
179C:  MOVWF  FE9
179E:  MOVFF  B5,FE2
17A2:  MOVFF  B4,FE1
17A6:  MOVF   FE7,F
17A8:  MOVFF  FE6,FEE
17AC:  BNZ   17A6
....................          strcpy(data2, strtok(NULL , term));       // 2ra Palabra 
17AE:  CLRF   xCF
17B0:  CLRF   xCE
17B2:  CLRF   xD1
17B4:  MOVLW  B1
17B6:  MOVWF  xD0
17B8:  MOVLB  0
17BA:  RCALL  13B0
17BC:  MOVFF  02,1CF
17C0:  MOVFF  01,1CE
17C4:  CLRF   FEA
17C6:  MOVLW  C4
17C8:  MOVWF  FE9
17CA:  MOVFF  02,FE2
17CE:  MOVFF  01,FE1
17D2:  MOVF   FE7,F
17D4:  MOVFF  FE6,FEE
17D8:  BNZ   17D2
....................          strcpy(data3, strtok(NULL , term));       // 3ra Palabra 
17DA:  MOVLB  1
17DC:  CLRF   xCF
17DE:  CLRF   xCE
17E0:  CLRF   xD1
17E2:  MOVLW  B1
17E4:  MOVWF  xD0
17E6:  MOVLB  0
17E8:  RCALL  13B0
17EA:  MOVFF  02,1CF
17EE:  MOVFF  01,1CE
17F2:  CLRF   FEA
17F4:  MOVLW  CE
17F6:  MOVWF  FE9
17F8:  MOVFF  02,FE2
17FC:  MOVFF  01,FE1
1800:  MOVF   FE7,F
1802:  MOVFF  FE6,FEE
1806:  BNZ   1800
....................          strcpy(data4, strtok(NULL , term));       // 4ra Palabra 
1808:  MOVLB  1
180A:  CLRF   xCF
180C:  CLRF   xCE
180E:  CLRF   xD1
1810:  MOVLW  B1
1812:  MOVWF  xD0
1814:  MOVLB  0
1816:  RCALL  13B0
1818:  MOVFF  02,1CF
181C:  MOVFF  01,1CE
1820:  CLRF   FEA
1822:  MOVLW  D8
1824:  MOVWF  FE9
1826:  MOVFF  02,FE2
182A:  MOVFF  01,FE1
182E:  MOVF   FE7,F
1830:  MOVFF  FE6,FEE
1834:  BNZ   182E
....................          strcpy(data5, strtok(NULL , term));       // 5ra Palabra 
1836:  MOVLB  1
1838:  CLRF   xCF
183A:  CLRF   xCE
183C:  CLRF   xD1
183E:  MOVLW  B1
1840:  MOVWF  xD0
1842:  MOVLB  0
1844:  RCALL  13B0
1846:  MOVFF  02,1CF
184A:  MOVFF  01,1CE
184E:  CLRF   FEA
1850:  MOVLW  E2
1852:  MOVWF  FE9
1854:  MOVFF  02,FE2
1858:  MOVFF  01,FE1
185C:  MOVF   FE7,F
185E:  MOVFF  FE6,FEE
1862:  BNZ   185C
....................          ptr = strtok(0, term); 
1864:  MOVLB  1
1866:  CLRF   xCF
1868:  CLRF   xCE
186A:  CLRF   xD1
186C:  MOVLW  B1
186E:  MOVWF  xD0
1870:  MOVLB  0
1872:  RCALL  13B0
1874:  MOVFF  02,B5
1878:  MOVFF  01,B4
....................           
....................           
....................          conteo_wl++; 
187C:  MOVLB  1
187E:  INCF   xCD,F
....................          sub_atras = atoi32(data2); 
1880:  CLRF   xCF
1882:  MOVLW  C4
1884:  MOVWF  xCE
1886:  MOVLB  0
1888:  RCALL  1460
188A:  MOVFF  01,35
188E:  MOVFF  00,34
....................          baj_atras = atoi32(data3); 
1892:  MOVLB  1
1894:  CLRF   xCF
1896:  MOVLW  CE
1898:  MOVWF  xCE
189A:  MOVLB  0
189C:  RCALL  1460
189E:  MOVFF  01,37
18A2:  MOVFF  00,36
....................          temporal3 = atoi32(data4); 
18A6:  MOVLB  1
18A8:  CLRF   xCF
18AA:  MOVLW  D8
18AC:  MOVWF  xCE
18AE:  MOVLB  0
18B0:  RCALL  1460
18B2:  MOVFF  01,97
18B6:  MOVFF  00,96
....................          tempo_tn  = atoi32(data5); 
18BA:  MOVLB  1
18BC:  CLRF   xCF
18BE:  MOVLW  E2
18C0:  MOVWF  xCE
18C2:  MOVLB  0
18C4:  RCALL  1460
18C6:  MOVFF  01,33
18CA:  MOVFF  00,32
....................          /* 
....................          printf(lcd_putc,"\f"); 
....................          lcd_gotoxy(1,1); 
....................          printf(lcd_putc,"%s->%ld",data2,sub_atras); 
....................          lcd_gotoxy(1,2); 
....................          printf(lcd_putc,"%s->%ld",data3,baj_atras); 
....................          lcd_gotoxy(1,3); 
....................          printf(lcd_putc,"%s->%ld",data4,temporal3); 
....................          lcd_gotoxy(1,4); 
....................          printf(lcd_putc,"%s->%ld",data5,tempo_tn); 
....................         delay_ms(4000); 
....................         */ 
....................           
....................          lcd_gotoxy(14,3); 
18CE:  MOVLW  0E
18D0:  MOVLB  1
18D2:  MOVWF  xD8
18D4:  MOVLW  03
18D6:  MOVWF  xD9
18D8:  MOVLB  0
18DA:  CALL   086E
....................          printf(lcd_putc,"S2:%Ld ",sub_atras); 
18DE:  MOVLW  28
18E0:  MOVWF  FF6
18E2:  MOVLW  03
18E4:  MOVWF  FF7
18E6:  MOVLW  03
18E8:  MOVLB  1
18EA:  MOVWF  xCE
18EC:  MOVLB  0
18EE:  CALL   0920
18F2:  MOVLW  10
18F4:  MOVWF  FE9
18F6:  MOVFF  35,1CF
18FA:  MOVFF  34,1CE
18FE:  CALL   0948
1902:  MOVLW  20
1904:  MOVLB  1
1906:  MOVWF  xD7
1908:  MOVLB  0
190A:  CALL   08C0
....................          lcd_gotoxy(14,4); 
190E:  MOVLW  0E
1910:  MOVLB  1
1912:  MOVWF  xD8
1914:  MOVLW  04
1916:  MOVWF  xD9
1918:  MOVLB  0
191A:  CALL   086E
....................          printf(lcd_putc,"B2:%Ld ",baj_atras); 
191E:  MOVLW  30
1920:  MOVWF  FF6
1922:  MOVLW  03
1924:  MOVWF  FF7
1926:  MOVLW  03
1928:  MOVLB  1
192A:  MOVWF  xCE
192C:  MOVLB  0
192E:  CALL   0920
1932:  MOVLW  10
1934:  MOVWF  FE9
1936:  MOVFF  37,1CF
193A:  MOVFF  36,1CE
193E:  CALL   0948
1942:  MOVLW  20
1944:  MOVLB  1
1946:  MOVWF  xD7
1948:  MOVLB  0
194A:  CALL   08C0
194E:  GOTO   3104 (RETURN)
....................           
....................  
.................... } 
....................  
.................... void envio(){//crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................    /* 
....................    if(convertir_to_entero(tempo_tc[0]) >0) for(i=0;i< convertir_to_entero(tempo_tc[0]);i++) tempo_tn=tempo_tn+1000; 
....................    if(convertir_to_entero(tempo_tc[1]) >0) for(i=0;i< convertir_to_entero(tempo_tc[1]);i++) tempo_tn=tempo_tn+100; 
....................    if(convertir_to_entero(tempo_tc[2]) >0) for(i=0;i< convertir_to_entero(tempo_tc[2]);i++) tempo_tn=tempo_tn+10; 
....................    tempo_tn=tempo_tn+convertir_to_entero(tempo_tc[3]); 
....................    */ 
....................    //////////////////////////////////////////////////// 
....................    /* 
....................    if(convertir_to_entero(entran[0]) >0) for(i=0;i< convertir_to_entero(entran[0]);i++) temporal1=temporal1+1000; 
....................    if(convertir_to_entero(entran[1]) >0) for(i=0;i< convertir_to_entero(entran[1]);i++) temporal1=temporal1+100; 
....................    if(convertir_to_entero(entran[2]) >0) for(i=0;i< convertir_to_entero(entran[2]);i++) temporal1=temporal1+10; 
....................    sub_atras=temporal1=temporal1+convertir_to_entero(entran[3]); 
....................     
....................    if(convertir_to_entero(salen[0]) >0) for(i=0;i< convertir_to_entero(salen[0]);i++) temporal2=temporal2+1000; 
....................    if(convertir_to_entero(salen[1]) >0) for(i=0;i< convertir_to_entero(salen[1]);i++) temporal2=temporal2+100; 
....................    if(convertir_to_entero(salen[2]) >0) for(i=0;i< convertir_to_entero(salen[2]);i++) temporal2=temporal2+10; 
....................    baj_atras=temporal2=temporal2+convertir_to_entero(salen[3]); 
....................    */ 
....................    /* 
....................    if(convertir_to_entero(bloqueado[0]) >0) for(i=0;i< convertir_to_entero(bloqueado[0]);i++) temporal3=temporal3+100; 
....................    if(convertir_to_entero(bloqueado[1]) >0) for(i=0;i< convertir_to_entero(bloqueado[1]);i++) temporal3=temporal3+10; 
....................    temporal3=temporal3+convertir_to_entero(bloqueado[2]); 
....................    */ 
....................     
....................    temporal1 = sub_atras; 
*
1C1C:  MOVFF  35,2F
1C20:  MOVFF  34,2E
....................    temporal2 = baj_atras; 
1C24:  MOVFF  37,31
1C28:  MOVFF  36,30
....................    entran1=(entraront+salieront)/2; 
1C2C:  MOVF   x8C,W
1C2E:  ADDWF  x8A,W
1C30:  MOVLB  1
1C32:  MOVWF  xCD
1C34:  MOVLB  0
1C36:  MOVF   x8D,W
1C38:  ADDWFC x8B,W
1C3A:  MOVLB  1
1C3C:  MOVWF  xCE
1C3E:  BCF    FD8.0
1C40:  RRCF   xCE,W
1C42:  MOVWF  39
1C44:  RRCF   xCD,W
1C46:  MOVWF  38
....................     
....................    total2_t=(temporal1+temporal2)/2; 
1C48:  MOVF   30,W
1C4A:  ADDWF  2E,W
1C4C:  MOVWF  xCD
1C4E:  MOVF   31,W
1C50:  ADDWFC 2F,W
1C52:  MOVWF  xCE
1C54:  BCF    FD8.0
1C56:  RRCF   xCE,W
1C58:  MOVWF  51
1C5A:  RRCF   xCD,W
1C5C:  MOVWF  50
....................  
....................    leer_conta2(); 
1C5E:  MOVLB  0
1C60:  CALL   081C
....................    if( total2_t== tempo_tn ) {//dato recibido correcto 
1C64:  MOVF   32,W
1C66:  SUBWF  50,W
1C68:  BNZ   1C88
1C6A:  MOVF   33,W
1C6C:  SUBWF  51,W
1C6E:  BNZ   1C88
....................          salian=salen1=total2_t; 
1C70:  MOVFF  51,3B
1C74:  MOVFF  50,3A
1C78:  MOVFF  3B,3D
1C7C:  MOVFF  3A,3C
....................          graba_conta2(); 
1C80:  CALL   06BA
....................          error=0; 
1C84:  CLRF   23
....................    } 
1C86:  BRA    1C8C
....................    else error=2; 
1C88:  MOVLW  02
1C8A:  MOVWF  23
....................    ///////////// 
....................    pasajet=entran1+salen1; 
1C8C:  MOVF   3A,W
1C8E:  ADDWF  38,W
1C90:  MOVWF  x90
1C92:  MOVF   3B,W
1C94:  ADDWFC 39,W
1C96:  MOVWF  x91
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1C98:  MOVF   53,W
1C9A:  ADDWF  52,W
1C9C:  ADDWF  54,W
1C9E:  MOVWF  4C
1CA0:  CLRF   4D
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entran1,salen1,cta_bloqueo,temporal3,error); 
1CA2:  MOVLW  38
1CA4:  MOVWF  FF6
1CA6:  MOVLW  03
1CA8:  MOVWF  FF7
1CAA:  MOVLW  07
1CAC:  MOVLB  1
1CAE:  MOVWF  xCD
1CB0:  MOVLB  0
1CB2:  RCALL  1952
1CB4:  MOVLW  09
1CB6:  MOVWF  FE9
1CB8:  MOVFF  91,1CE
1CBC:  MOVFF  90,1CD
1CC0:  RCALL  197A
1CC2:  MOVLW  2C
1CC4:  MOVLB  1
1CC6:  MOVWF  xD6
1CC8:  MOVLB  0
1CCA:  CALL   11B0
1CCE:  MOVLW  09
1CD0:  MOVWF  FE9
1CD2:  MOVFF  39,1CE
1CD6:  MOVFF  38,1CD
1CDA:  RCALL  197A
1CDC:  MOVLW  2C
1CDE:  MOVLB  1
1CE0:  MOVWF  xD6
1CE2:  MOVLB  0
1CE4:  CALL   11B0
1CE8:  MOVLW  09
1CEA:  MOVWF  FE9
1CEC:  MOVFF  3B,1CE
1CF0:  MOVFF  3A,1CD
1CF4:  RCALL  197A
1CF6:  MOVLW  2C
1CF8:  MOVLB  1
1CFA:  MOVWF  xD6
1CFC:  MOVLB  0
1CFE:  CALL   11B0
1D02:  MOVLW  0A
1D04:  MOVWF  FE9
1D06:  MOVFF  4D,1CE
1D0A:  MOVFF  4C,1CD
1D0E:  RCALL  197A
1D10:  MOVLW  2C
1D12:  MOVLB  1
1D14:  MOVWF  xD6
1D16:  MOVLB  0
1D18:  CALL   11B0
1D1C:  MOVLW  0A
1D1E:  MOVWF  FE9
1D20:  MOVFF  97,1CE
1D24:  MOVFF  96,1CD
1D28:  RCALL  197A
1D2A:  MOVLW  2C
1D2C:  MOVLB  1
1D2E:  MOVWF  xD6
1D30:  MOVLB  0
1D32:  CALL   11B0
1D36:  MOVFF  23,1CD
1D3A:  MOVLW  01
1D3C:  MOVLB  1
1D3E:  MOVWF  xCE
1D40:  MOVLB  0
1D42:  RCALL  1A40
1D44:  MOVLW  61
1D46:  MOVWF  FF6
1D48:  MOVLW  03
1D4A:  MOVWF  FF7
1D4C:  MOVLW  03
1D4E:  MOVLB  1
1D50:  MOVWF  xCD
1D52:  MOVLB  0
1D54:  RCALL  1952
....................    lcd_cuentas(); 
1D56:  CALL   0A64
....................  
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1D5A:  MOVLW  09
1D5C:  MOVLB  1
1D5E:  MOVWF  xD8
1D60:  MOVLW  03
1D62:  MOVWF  xD9
1D64:  MOVLB  0
1D66:  CALL   086E
....................    lcd_putc(0xAB); 
1D6A:  MOVLW  AB
1D6C:  MOVLB  1
1D6E:  MOVWF  xD7
1D70:  MOVLB  0
1D72:  CALL   08C0
....................  
....................    clear_lcd1=1; 
1D76:  MOVLW  01
1D78:  MOVWF  xAB
....................    time_lcd1=0; 
1D7A:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1D7C:  CLRF   xAA
1D7E:  CLRF   xA9
....................    transmitir=0; 
1D80:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1D82:  BSF    F9D.5
1D84:  GOTO   3276 (RETURN)
.................... } 
....................  
.................... void envia2(){//Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
1AC6:  BCF    F9D.5
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1AC8:  MOVF   53,W
1ACA:  ADDWF  52,W
1ACC:  ADDWF  54,W
1ACE:  MOVWF  4C
1AD0:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));//entran=0; 
1AD2:  MOVLW  01
1AD4:  MOVWF  FEA
1AD6:  MOVLW  AE
1AD8:  MOVWF  FE9
1ADA:  CLRF   00
1ADC:  CLRF   02
1ADE:  MOVLW  05
1AE0:  MOVWF  01
1AE2:  CALL   128C
....................    memset(salen, 0, sizeof(salen));//salen=0; 
1AE6:  MOVLW  01
1AE8:  MOVWF  FEA
1AEA:  MOVLW  B3
1AEC:  MOVWF  FE9
1AEE:  CLRF   00
1AF0:  CLRF   02
1AF2:  MOVLW  05
1AF4:  MOVWF  01
1AF6:  CALL   128C
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
1AFA:  MOVLW  01
1AFC:  MOVWF  FEA
1AFE:  MOVLW  B8
1B00:  MOVWF  FE9
1B02:  CLRF   00
1B04:  CLRF   02
1B06:  MOVLW  05
1B08:  MOVWF  01
1B0A:  CALL   128C
....................    i=10; 
1B0E:  MOVLW  0A
1B10:  MOVWF  41
....................    ii=0; 
1B12:  CLRF   42
....................    entran1=(entraront+salieront)/2; 
1B14:  MOVF   x8C,W
1B16:  ADDWF  x8A,W
1B18:  MOVLB  1
1B1A:  MOVWF  xCD
1B1C:  MOVLB  0
1B1E:  MOVF   x8D,W
1B20:  ADDWFC x8B,W
1B22:  MOVLB  1
1B24:  MOVWF  xCE
1B26:  BCF    FD8.0
1B28:  RRCF   xCE,W
1B2A:  MOVWF  39
1B2C:  RRCF   xCD,W
1B2E:  MOVWF  38
....................    leer_conta2(); 
1B30:  MOVLB  0
1B32:  CALL   081C
....................    pasajet=entran1+salian; 
1B36:  MOVF   3C,W
1B38:  ADDWF  38,W
1B3A:  MOVWF  x90
1B3C:  MOVF   3D,W
1B3E:  ADDWFC 39,W
1B40:  MOVWF  x91
....................    error=1; 
1B42:  MOVLW  01
1B44:  MOVWF  23
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n",pasajet,entran1,cta_bloqueo,error); 
1B46:  MOVLW  66
1B48:  MOVWF  FF6
1B4A:  MOVLW  03
1B4C:  MOVWF  FF7
1B4E:  MOVLW  07
1B50:  MOVLB  1
1B52:  MOVWF  xCD
1B54:  MOVLB  0
1B56:  RCALL  1952
1B58:  MOVLW  09
1B5A:  MOVWF  FE9
1B5C:  MOVFF  91,1CE
1B60:  MOVFF  90,1CD
1B64:  RCALL  197A
1B66:  MOVLW  2C
1B68:  MOVLB  1
1B6A:  MOVWF  xD6
1B6C:  MOVLB  0
1B6E:  CALL   11B0
1B72:  MOVLW  09
1B74:  MOVWF  FE9
1B76:  MOVFF  39,1CE
1B7A:  MOVFF  38,1CD
1B7E:  RCALL  197A
1B80:  MOVLW  78
1B82:  MOVWF  FF6
1B84:  MOVLW  03
1B86:  MOVWF  FF7
1B88:  MOVLW  06
1B8A:  MOVLB  1
1B8C:  MOVWF  xCD
1B8E:  MOVLB  0
1B90:  RCALL  1952
1B92:  MOVLW  0A
1B94:  MOVWF  FE9
1B96:  MOVFF  4D,1CE
1B9A:  MOVFF  4C,1CD
1B9E:  RCALL  197A
1BA0:  MOVLW  83
1BA2:  MOVWF  FF6
1BA4:  MOVLW  03
1BA6:  MOVWF  FF7
1BA8:  MOVLW  05
1BAA:  MOVLB  1
1BAC:  MOVWF  xCD
1BAE:  MOVLB  0
1BB0:  RCALL  1952
1BB2:  MOVFF  23,1CD
1BB6:  MOVLW  01
1BB8:  MOVLB  1
1BBA:  MOVWF  xCE
1BBC:  MOVLB  0
1BBE:  RCALL  1A40
1BC0:  MOVLW  8C
1BC2:  MOVWF  FF6
1BC4:  MOVLW  03
1BC6:  MOVWF  FF7
1BC8:  MOVLW  03
1BCA:  MOVLB  1
1BCC:  MOVWF  xCD
1BCE:  MOVLB  0
1BD0:  RCALL  1952
.................... //!   lcd_gotoxy(1,4); 
.................... //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1BD2:  MOVLW  09
1BD4:  MOVLB  1
1BD6:  MOVWF  xD8
1BD8:  MOVLW  03
1BDA:  MOVWF  xD9
1BDC:  MOVLB  0
1BDE:  CALL   086E
....................    lcd_putc(0xAB); 
1BE2:  MOVLW  AB
1BE4:  MOVLB  1
1BE6:  MOVWF  xD7
1BE8:  MOVLB  0
1BEA:  CALL   08C0
....................    lcd_gotoxy(9,4);//cronometro para limpiar 
1BEE:  MOVLW  09
1BF0:  MOVLB  1
1BF2:  MOVWF  xD8
1BF4:  MOVLW  04
1BF6:  MOVWF  xD9
1BF8:  MOVLB  0
1BFA:  CALL   086E
....................    lcd_putc("DESC"); 
1BFE:  MOVLW  90
1C00:  MOVWF  FF6
1C02:  MOVLW  03
1C04:  MOVWF  FF7
1C06:  CALL   0A44
....................    clear_lcd1=1; 
1C0A:  MOVLW  01
1C0C:  MOVWF  xAB
....................    time_lcd1=0; 
1C0E:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1C10:  CLRF   xAA
1C12:  CLRF   xA9
....................    flag_enviar=0; 
1C14:  CLRF   46
....................    enable_interrupts(INT_RDA); 
1C16:  BSF    F9D.5
1C18:  GOTO   326C (RETURN)
.................... } 
....................  
.................... void limpiar(){//borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront=0; 
*
0D1C:  CLRF   x93
0D1E:  CLRF   x92
....................    tem_salieront=0; 
0D20:  CLRF   x95
0D22:  CLRF   x94
....................    salian=0; 
0D24:  CLRF   3D
0D26:  CLRF   3C
....................    graba_conta2(); 
0D28:  RCALL  06BA
....................    leer_conta2(); 
0D2A:  RCALL  081C
....................    pasaje=0; 
0D2C:  CLRF   x8F
0D2E:  CLRF   x8E
....................    pasajet=0; 
0D30:  CLRF   x91
0D32:  CLRF   x90
....................    salieront=0; 
0D34:  CLRF   x8D
0D36:  CLRF   x8C
....................    entraront=0; 
0D38:  CLRF   x8B
0D3A:  CLRF   x8A
....................    write_ent(); 
0D3C:  RCALL  0CB0
....................    write_sal(); 
0D3E:  RCALL  0CE6
....................    cta_bloqueo=0; 
0D40:  CLRF   4D
0D42:  CLRF   4C
....................    cta_bloq1=0; 
0D44:  CLRF   52
....................    cta_bloq2=0; 
0D46:  CLRF   53
....................    cta_bloq3=0; 
0D48:  CLRF   54
....................    write_ext_eeprom(9,cta_bloq1);//bloq1 
0D4A:  MOVLB  1
0D4C:  CLRF   xD2
0D4E:  MOVLW  09
0D50:  MOVWF  xD1
0D52:  MOVFF  52,1D3
0D56:  MOVLB  0
0D58:  RCALL  05B4
....................    write_ext_eeprom(10,cta_bloq2);//bloq2 
0D5A:  MOVLB  1
0D5C:  CLRF   xD2
0D5E:  MOVLW  0A
0D60:  MOVWF  xD1
0D62:  MOVFF  53,1D3
0D66:  MOVLB  0
0D68:  RCALL  05B4
....................    write_ext_eeprom(11,cta_bloq3);//bloq3 
0D6A:  MOVLB  1
0D6C:  CLRF   xD2
0D6E:  MOVLW  0B
0D70:  MOVWF  xD1
0D72:  MOVFF  54,1D3
0D76:  MOVLB  0
0D78:  RCALL  05B4
....................    lcd_putc("\f"); 
0D7A:  MOVLW  96
0D7C:  MOVWF  FF6
0D7E:  MOVLW  03
0D80:  MOVWF  FF7
0D82:  RCALL  0A44
....................    lcd_cuentas(); 
0D84:  RCALL  0A64
0D86:  RETURN 0
.................... } 
....................  
.................... void detecta_suma(){//Realiza suma de entradas o salidas 
....................     if( (!detec1)&&(!detec2)&&(!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){//suma sin bloqueos 
*
2058:  MOVF   x69,F
205A:  BNZ   20C6
205C:  MOVF   x6A,F
205E:  BNZ   20C6
2060:  MOVF   x6B,F
2062:  BNZ   20C6
2064:  MOVF   x6C,F
2066:  BNZ   20C6
2068:  MOVF   x6D,F
206A:  BNZ   20C6
206C:  MOVF   x6E,F
206E:  BNZ   20C6
....................       sumae1=fse1+fse2+fse3; 
2070:  MOVF   29,W
2072:  ADDWF  28,W
2074:  ADDWF  2A,W
2076:  MOVWF  25
....................       sumas1=fss1+fss2+fss3; 
2078:  MOVF   2C,W
207A:  ADDWF  2B,W
207C:  ADDWF  2D,W
207E:  MOVWF  26
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if( (sumae1>=2)||(sumas1>=2) ){ 
2080:  MOVF   25,W
2082:  SUBLW  01
2084:  BNC   208C
2086:  MOVF   26,W
2088:  SUBLW  01
208A:  BC    20A8
....................          if(sumae1>sumas1) { 
208C:  MOVF   25,W
208E:  SUBWF  26,W
2090:  BC    209E
....................             entraront++; 
2092:  INCF   x8A,F
2094:  BTFSC  FD8.2
2096:  INCF   x8B,F
....................             write_ent(); 
2098:  CALL   0CB0
....................          } 
209C:  BRA    20A8
....................          else{ 
....................             salieront++; 
209E:  INCF   x8C,F
20A0:  BTFSC  FD8.2
20A2:  INCF   x8D,F
....................             write_sal(); 
20A4:  CALL   0CE6
....................          } 
....................       } 
....................       sumae1=fse1=fse2=fse3=0; 
20A8:  CLRF   2A
20AA:  MOVFF  2A,29
20AE:  MOVFF  29,28
20B2:  MOVFF  28,25
....................       sumas1=fss1=fss2=fss3=0; 
20B6:  CLRF   2D
20B8:  MOVFF  2D,2C
20BC:  MOVFF  2C,2B
20C0:  MOVFF  2B,26
....................       //envio_PC(); 
....................    }//fin suma sin bloqueos 
20C4:  BRA    21C4
....................    else if( (en_b1)||(en_b2)||(en_b3) ){//contar con bloqueos 
20C6:  MOVF   x9E,F
20C8:  BNZ   20D4
20CA:  MOVF   x9F,F
20CC:  BNZ   20D4
20CE:  MOVF   xA0,F
20D0:  BTFSC  FD8.2
20D2:  BRA    21C4
....................             lim_b= en_b1+ en_b2+ en_b3; 
20D4:  MOVF   x9F,W
20D6:  ADDWF  x9E,W
20D8:  ADDWF  xA0,W
20DA:  MOVWF  27
....................     
....................             if(lim_b==1){//un solo bloqueo 
20DC:  DECFSZ 27,W
20DE:  BRA    2170
....................                if(en_b1){ 
20E0:  MOVF   x9E,F
20E2:  BZ    2110
....................                   if( (!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){ 
20E4:  MOVF   x6B,F
20E6:  BNZ   210E
20E8:  MOVF   x6C,F
20EA:  BNZ   210E
20EC:  MOVF   x6D,F
20EE:  BNZ   210E
20F0:  MOVF   x6E,F
20F2:  BNZ   210E
....................                      if(sen_ent==1){ 
20F4:  DECFSZ 5B,W
20F6:  BRA    2104
....................                         entraront++; 
20F8:  INCF   x8A,F
20FA:  BTFSC  FD8.2
20FC:  INCF   x8B,F
....................                         write_ent(); 
20FE:  CALL   0CB0
....................                      } 
2102:  BRA    210E
....................                      else{ 
....................                         salieront++; 
2104:  INCF   x8C,F
2106:  BTFSC  FD8.2
2108:  INCF   x8D,F
....................                         write_sal(); 
210A:  CALL   0CE6
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin bloqueo par 1 
210E:  BRA    216E
....................                else if(en_b2){//bloqueo en par 2 
2110:  MOVF   x9F,F
2112:  BZ    2140
....................                   if( (!detec1)&&(!detec2)&&(!detec5)&&(!detec6) ){ 
2114:  MOVF   x69,F
2116:  BNZ   213E
2118:  MOVF   x6A,F
211A:  BNZ   213E
211C:  MOVF   x6D,F
211E:  BNZ   213E
2120:  MOVF   x6E,F
2122:  BNZ   213E
....................                      if(sen_ent){ 
2124:  MOVF   5B,F
2126:  BZ    2134
....................                         entraront++; 
2128:  INCF   x8A,F
212A:  BTFSC  FD8.2
212C:  INCF   x8B,F
....................                         write_ent(); 
212E:  CALL   0CB0
....................                      } 
2132:  BRA    213E
....................                      else{ 
....................                         salieront++; 
2134:  INCF   x8C,F
2136:  BTFSC  FD8.2
2138:  INCF   x8D,F
....................                         write_sal(); 
213A:  CALL   0CE6
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin par 2 
213E:  BRA    216E
....................                else if(en_b3){//bloqueao en par 3 
2140:  MOVF   xA0,F
2142:  BZ    216E
....................                   if( (!detec3)&&(!detec4)&&(!detec1)&&(!detec2) ){ 
2144:  MOVF   x6B,F
2146:  BNZ   216E
2148:  MOVF   x6C,F
214A:  BNZ   216E
214C:  MOVF   x69,F
214E:  BNZ   216E
2150:  MOVF   x6A,F
2152:  BNZ   216E
....................                      if(sen_ent){ 
2154:  MOVF   5B,F
2156:  BZ    2164
....................                         entraront++; 
2158:  INCF   x8A,F
215A:  BTFSC  FD8.2
215C:  INCF   x8B,F
....................                         write_ent(); 
215E:  CALL   0CB0
....................                      } 
2162:  BRA    216E
....................                      else{ 
....................                         salieront++; 
2164:  INCF   x8C,F
2166:  BTFSC  FD8.2
2168:  INCF   x8D,F
....................                         write_sal(); 
216A:  CALL   0CE6
....................                      } 
....................                   } 
....................                }//fin par 3 
....................             }//fin un solo bloqueo 
216E:  BRA    21A8
.................... //----------------------------------------------------------------------------- 
....................             else{//mas de un bloqueo 
....................                sumae1=fse1+fse2+fse3; 
2170:  MOVF   29,W
2172:  ADDWF  28,W
2174:  ADDWF  2A,W
2176:  MOVWF  25
....................                sumas1=fss1+fss2+fss3; 
2178:  MOVF   2C,W
217A:  ADDWF  2B,W
217C:  ADDWF  2D,W
217E:  MOVWF  26
....................                //lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................                //printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................                if( (sumae1>=1)||(sumas1>=1) ){ 
2180:  MOVF   25,W
2182:  SUBLW  00
2184:  BNC   218C
2186:  MOVF   26,W
2188:  SUBLW  00
218A:  BC    21A8
....................                   if(sumae1>sumas1) { 
218C:  MOVF   25,W
218E:  SUBWF  26,W
2190:  BC    219E
....................                      entraront++; 
2192:  INCF   x8A,F
2194:  BTFSC  FD8.2
2196:  INCF   x8B,F
....................                      write_ent(); 
2198:  CALL   0CB0
....................                   } 
219C:  BRA    21A8
....................                   else{ 
....................                      salieront++; 
219E:  INCF   x8C,F
21A0:  BTFSC  FD8.2
21A2:  INCF   x8D,F
....................                      write_sal(); 
21A4:  CALL   0CE6
....................                   } 
....................                } 
....................             }//fin mas de un bloqueo 
....................                sumae1=fse1=fse2=fse3=0; 
21A8:  CLRF   2A
21AA:  MOVFF  2A,29
21AE:  MOVFF  29,28
21B2:  MOVFF  28,25
....................                sumas1=fss1=fss2=fss3=0; 
21B6:  CLRF   2D
21B8:  MOVFF  2D,2C
21BC:  MOVFF  2C,2B
21C0:  MOVFF  2B,26
.................... //----------------------------------------------------------------------------- 
....................    }//end bloqueos 
21C4:  RETURN 0
.................... } 
....................  
.................... void finsuma(){//Pinta en LCD la nueva cifra de entrada o salida 
....................  
....................       pasaje=(entraront+salieront)/2; 
*
0C72:  MOVF   x8C,W
0C74:  ADDWF  x8A,W
0C76:  MOVLB  1
0C78:  MOVWF  xCD
0C7A:  MOVLB  0
0C7C:  MOVF   x8D,W
0C7E:  ADDWFC x8B,W
0C80:  MOVLB  1
0C82:  MOVWF  xCE
0C84:  BCF    FD8.0
0C86:  RRCF   xCE,W
0C88:  MOVLB  0
0C8A:  MOVWF  x8F
0C8C:  MOVLB  1
0C8E:  RRCF   xCD,W
0C90:  MOVLB  0
0C92:  MOVWF  x8E
....................       lcd_cuentas(); 
0C94:  RCALL  0A64
....................       sen_ent=0; 
0C96:  CLRF   5B
....................       sen_sal=0; 
0C98:  CLRF   5C
....................       fse1=fse2=fse3=0; 
0C9A:  CLRF   2A
0C9C:  MOVFF  2A,29
0CA0:  MOVFF  29,28
....................       fss1=fss2=fss3=0; 
0CA4:  CLRF   2D
0CA6:  MOVFF  2D,2C
0CAA:  MOVFF  2C,2B
0CAE:  RETURN 0
.................... } 
....................  
.................... void contando1(){//Revisa maquina de estados para par 1 
....................    if(entra_temp1!=edo1) { 
*
21C6:  MOVF   x76,W
21C8:  SUBWF  x7B,W
21CA:  BZ    21D4
....................       entra_temp1=edo1; 
21CC:  MOVFF  76,7B
....................       enable1=1; 
21D0:  MOVLW  01
21D2:  MOVWF  x7A
....................    } 
....................    if (enable1==1){ 
21D4:  DECFSZ x7A,W
21D6:  BRA    2214
....................          switch (edo1) { 
21D8:  MOVLW  01
21DA:  SUBWF  x76,W
21DC:  ADDLW  F4
21DE:  BC    2210
21E0:  ADDLW  0C
21E2:  GOTO   2216
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
21E6:  BRA    2210
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss1) fse1=1;//si no ha salido antes 
21E8:  MOVF   2B,F
21EA:  BNZ   21F2
21EC:  MOVLW  01
21EE:  MOVWF  28
21F0:  BRA    21F4
....................                      else fss1=0; 
21F2:  CLRF   2B
....................                      detecta_suma(); 
21F4:  RCALL  2058
....................                      break;} 
21F6:  BRA    2210
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
21F8:  RCALL  2058
....................                      break;} 
21FA:  BRA    2210
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
21FC:  BRA    2210
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse1) fss1=1;//si no ha entrado antes 
21FE:  MOVF   28,F
2200:  BNZ   2208
2202:  MOVLW  01
2204:  MOVWF  2B
2206:  BRA    220A
....................                      else fse1=0; 
2208:  CLRF   28
....................                      detecta_suma(); 
220A:  RCALL  2058
....................                      break;} 
220C:  BRA    2210
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
220E:  RCALL  2058
....................                      break;} 
....................          } 
....................       enable1=0; 
2210:  CLRF   x7A
....................       entra_act1=0; 
2212:  CLRF   x75
....................    } 
2214:  RETURN 0
.................... } 
....................  
.................... void contando2(){//Revisa maquina de estados para par 2 
....................    if(entra_temp2!=edo2) { 
*
24CE:  MOVF   x7D,W
24D0:  SUBWF  x82,W
24D2:  BZ    24DC
....................       entra_temp2=edo2; 
24D4:  MOVFF  7D,82
....................       enable2=1; 
24D8:  MOVLW  01
24DA:  MOVWF  x81
....................    } 
....................    if (enable2==1){ 
24DC:  DECFSZ x81,W
24DE:  BRA    251C
....................          switch (edo2) { 
24E0:  MOVLW  01
24E2:  SUBWF  x7D,W
24E4:  ADDLW  F4
24E6:  BC    2518
24E8:  ADDLW  0C
24EA:  GOTO   251E
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
24EE:  BRA    2518
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss2) fse2=1; 
24F0:  MOVF   2C,F
24F2:  BNZ   24FA
24F4:  MOVLW  01
24F6:  MOVWF  29
24F8:  BRA    24FC
....................                      else fss2=0; 
24FA:  CLRF   2C
....................                      detecta_suma(); 
24FC:  RCALL  2058
....................                      break;} 
24FE:  BRA    2518
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
2500:  RCALL  2058
....................                      break;} 
2502:  BRA    2518
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
2504:  BRA    2518
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse2) fss2=1; 
2506:  MOVF   29,F
2508:  BNZ   2510
250A:  MOVLW  01
250C:  MOVWF  2C
250E:  BRA    2512
....................                      else fse2=0; 
2510:  CLRF   29
....................                      detecta_suma(); 
2512:  RCALL  2058
....................                      break;} 
2514:  BRA    2518
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
2516:  RCALL  2058
....................                      break;} 
....................          } 
....................       enable2=0; 
2518:  CLRF   x81
....................       entra_act2=0; 
251A:  CLRF   x7C
....................    } 
251C:  RETURN 0
.................... } 
....................  
.................... void contando3(){//Revisa maquina de estados para par 3 
....................    if(entra_temp3!=edo3) { 
*
27D8:  MOVF   x84,W
27DA:  SUBWF  x89,W
27DC:  BZ    27E6
....................       entra_temp3=edo3; 
27DE:  MOVFF  84,89
....................       enable3=1; 
27E2:  MOVLW  01
27E4:  MOVWF  x88
....................    } 
....................    if (enable3==1){ 
27E6:  DECFSZ x88,W
27E8:  BRA    2826
....................          switch (edo3) { 
27EA:  MOVLW  01
27EC:  SUBWF  x84,W
27EE:  ADDLW  F4
27F0:  BC    2822
27F2:  ADDLW  0C
27F4:  GOTO   2828
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
27F8:  BRA    2822
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss3) fse3=1; 
27FA:  MOVF   2D,F
27FC:  BNZ   2804
27FE:  MOVLW  01
2800:  MOVWF  2A
2802:  BRA    2806
....................                      else fss3=0; 
2804:  CLRF   2D
....................                      detecta_suma(); 
2806:  RCALL  2058
....................                      break;} 
2808:  BRA    2822
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
280A:  RCALL  2058
....................                      break;} 
280C:  BRA    2822
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
280E:  BRA    2822
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse3) fss3=1; 
2810:  MOVF   2A,F
2812:  BNZ   281A
2814:  MOVLW  01
2816:  MOVWF  2D
2818:  BRA    281C
....................                      else fse3=0; 
281A:  CLRF   2A
....................                      detecta_suma(); 
281C:  RCALL  2058
....................                      break;} 
281E:  BRA    2822
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
2820:  RCALL  2058
....................                      break;} 
....................          } 
....................       enable3=0; 
2822:  CLRF   x88
....................       entra_act3=0; 
2824:  CLRF   x83
....................    } 
2826:  RETURN 0
.................... } 
....................  
.................... void sensando1(){//Define estados para la maquina de estados del par 1 
.................... /////normal/////// 
.................... if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==0)){//LLEGA PERSONA EN ENTRADA1 
*
1DD2:  MOVF   x75,F
1DD4:  BNZ   1E1A
1DD6:  DECFSZ x69,W
1DD8:  BRA    1E1A
1DDA:  MOVF   x6A,F
1DDC:  BNZ   1E1A
1DDE:  MOVF   x77,F
1DE0:  BNZ   1E1A
1DE2:  MOVF   x78,F
1DE4:  BNZ   1E1A
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1DE6:  MOVF   5B,F
1DE8:  BNZ   1DF0
1DEA:  MOVF   5C,F
1DEC:  BTFSC  FD8.2
1DEE:  RCALL  1D88
....................    lcd_gotoxy(8,2); 
1DF0:  MOVLW  08
1DF2:  MOVLB  1
1DF4:  MOVWF  xD8
1DF6:  MOVLW  02
1DF8:  MOVWF  xD9
1DFA:  MOVLB  0
1DFC:  CALL   086E
....................    lcd_putc(0x7F);//flecha del sentido 
1E00:  MOVLW  7F
1E02:  MOVLB  1
1E04:  MOVWF  xD7
1E06:  MOVLB  0
1E08:  CALL   08C0
....................    des1=1; 
1E0C:  MOVLW  01
1E0E:  MOVWF  x98
....................    //// 
....................    edo1=1; 
1E10:  MOVWF  x76
....................    entra1=1; 
1E12:  MOVWF  x77
....................    edoa1=1; 
1E14:  MOVWF  x79
....................    entra_act1=1;} 
1E16:  MOVWF  x75
1E18:  BRA    2056
.................... ///prioridad 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA ENTRANDO 
1E1A:  MOVF   x75,F
1E1C:  BNZ   1E3A
1E1E:  DECFSZ x69,W
1E20:  BRA    1E3A
1E22:  DECFSZ x6A,W
1E24:  BRA    1E3A
1E26:  DECFSZ x77,W
1E28:  BRA    1E3A
1E2A:  MOVF   x78,F
1E2C:  BNZ   1E3A
....................    edo1=3; 
1E2E:  MOVLW  03
1E30:  MOVWF  x76
....................    edoa1=0; 
1E32:  CLRF   x79
....................    entra_act1=1;} 
1E34:  MOVLW  01
1E36:  MOVWF  x75
1E38:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA CASI TERMINA DE ENTRAR 
1E3A:  MOVF   x75,F
1E3C:  BNZ   1E58
1E3E:  MOVF   x69,F
1E40:  BNZ   1E58
1E42:  DECFSZ x6A,W
1E44:  BRA    1E58
1E46:  DECFSZ x77,W
1E48:  BRA    1E58
1E4A:  MOVF   x78,F
1E4C:  BNZ   1E58
....................    edo1=4; 
1E4E:  MOVLW  04
1E50:  MOVWF  x76
....................    entra_act1=1;} 
1E52:  MOVLW  01
1E54:  MOVWF  x75
1E56:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==1)&&(sale1==0)){//PERSONA A ENTRADO 
1E58:  MOVF   x75,F
1E5A:  BNZ   1EB0
1E5C:  MOVF   x69,F
1E5E:  BNZ   1EB0
1E60:  MOVF   x6A,F
1E62:  BNZ   1EB0
1E64:  MOVF   x79,F
1E66:  BNZ   1EB0
1E68:  DECFSZ x77,W
1E6A:  BRA    1EB0
1E6C:  MOVF   x78,F
1E6E:  BNZ   1EB0
....................    lcd_gotoxy(8,2); 
1E70:  MOVLW  08
1E72:  MOVLB  1
1E74:  MOVWF  xD8
1E76:  MOVLW  02
1E78:  MOVWF  xD9
1E7A:  MOVLB  0
1E7C:  CALL   086E
....................    lcd_putc(" "); 
1E80:  MOVLW  98
1E82:  MOVWF  FF6
1E84:  MOVLW  03
1E86:  MOVWF  FF7
1E88:  CALL   0A44
....................    des1=0; 
1E8C:  CLRF   x98
....................    if(entra_temp1==4){ 
1E8E:  MOVF   x7B,W
1E90:  SUBLW  04
1E92:  BNZ   1EA0
....................       edo1=5; 
1E94:  MOVLW  05
1E96:  MOVWF  x76
....................       entra1=0; 
1E98:  CLRF   x77
....................       entra_act1=1; 
1E9A:  MOVLW  01
1E9C:  MOVWF  x75
....................    } 
1E9E:  BRA    1EAE
....................    else {//entraba y se regresa 
....................       des1=0; 
1EA0:  CLRF   x98
....................       edo1=6; 
1EA2:  MOVLW  06
1EA4:  MOVWF  x76
....................       entra1=0; 
1EA6:  CLRF   x77
....................       edoa1=0; 
1EA8:  CLRF   x79
....................       entra_act1=1;   
1EAA:  MOVLW  01
1EAC:  MOVWF  x75
....................    } 
.................... } 
1EAE:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==1)&&(sale1==0)){//entraba y se regresa 
1EB0:  MOVF   x75,F
1EB2:  BNZ   1EF4
1EB4:  MOVF   x69,F
1EB6:  BNZ   1EF4
1EB8:  MOVF   x6A,F
1EBA:  BNZ   1EF4
1EBC:  DECFSZ x79,W
1EBE:  BRA    1EF4
1EC0:  DECFSZ x77,W
1EC2:  BRA    1EF4
1EC4:  MOVF   x78,F
1EC6:  BNZ   1EF4
....................    lcd_gotoxy(8,2); 
1EC8:  MOVLW  08
1ECA:  MOVLB  1
1ECC:  MOVWF  xD8
1ECE:  MOVLW  02
1ED0:  MOVWF  xD9
1ED2:  MOVLB  0
1ED4:  CALL   086E
....................    lcd_putc(" "); 
1ED8:  MOVLW  9A
1EDA:  MOVWF  FF6
1EDC:  MOVLW  03
1EDE:  MOVWF  FF7
1EE0:  CALL   0A44
....................    des1=0; 
1EE4:  CLRF   x98
....................    edo1=6; 
1EE6:  MOVLW  06
1EE8:  MOVWF  x76
....................    entra1=0; 
1EEA:  CLRF   x77
....................    edoa1=0; 
1EEC:  CLRF   x79
....................    entra_act1=1;} 
1EEE:  MOVLW  01
1EF0:  MOVWF  x75
1EF2:  BRA    2056
.................... ///// 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==1)&&(sale1==0)){ 
1EF4:  MOVF   x75,F
1EF6:  BNZ   1F14
1EF8:  DECFSZ x69,W
1EFA:  BRA    1F14
1EFC:  MOVF   x6A,F
1EFE:  BNZ   1F14
1F00:  DECFSZ x77,W
1F02:  BRA    1F14
1F04:  MOVF   x78,F
1F06:  BNZ   1F14
....................    edo1=2; 
1F08:  MOVLW  02
1F0A:  MOVWF  x76
....................    edoa1=1; 
1F0C:  MOVLW  01
1F0E:  MOVWF  x79
....................    entra_act1=1;}//checar prioridad 
1F10:  MOVWF  x75
1F12:  BRA    2056
.................... //////sentido inverso/// 
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
1F14:  MOVF   x75,F
1F16:  BNZ   1F5E
1F18:  MOVF   x69,F
1F1A:  BNZ   1F5E
1F1C:  DECFSZ x6A,W
1F1E:  BRA    1F5E
1F20:  MOVF   x77,F
1F22:  BNZ   1F5E
1F24:  MOVF   x78,F
1F26:  BNZ   1F5E
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1F28:  MOVF   5B,F
1F2A:  BNZ   1F32
1F2C:  MOVF   5C,F
1F2E:  BTFSC  FD8.2
1F30:  RCALL  1D88
....................    lcd_gotoxy(8,2); 
1F32:  MOVLW  08
1F34:  MOVLB  1
1F36:  MOVWF  xD8
1F38:  MOVLW  02
1F3A:  MOVWF  xD9
1F3C:  MOVLB  0
1F3E:  CALL   086E
....................    lcd_putc(0x7E);//flecha del sentido 
1F42:  MOVLW  7E
1F44:  MOVLB  1
1F46:  MOVWF  xD7
1F48:  MOVLB  0
1F4A:  CALL   08C0
....................    des1=1; 
1F4E:  MOVLW  01
1F50:  MOVWF  x98
....................    edo1=7; 
1F52:  MOVLW  07
1F54:  MOVWF  x76
....................    sale1=1; 
1F56:  MOVLW  01
1F58:  MOVWF  x78
....................    entra_act1=1;} 
1F5A:  MOVWF  x75
1F5C:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 1 
1F5E:  MOVF   x75,F
1F60:  BNZ   1F7E
1F62:  MOVF   x69,F
1F64:  BNZ   1F7E
1F66:  DECFSZ x6A,W
1F68:  BRA    1F7E
1F6A:  MOVF   x77,F
1F6C:  BNZ   1F7E
1F6E:  DECFSZ x78,W
1F70:  BRA    1F7E
....................    edo1=8; 
1F72:  MOVLW  08
1F74:  MOVWF  x76
....................    edoa1=1; 
1F76:  MOVLW  01
1F78:  MOVWF  x79
....................    entra_act1=1;} 
1F7A:  MOVWF  x75
1F7C:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 2 
1F7E:  MOVF   x75,F
1F80:  BNZ   1F9E
1F82:  DECFSZ x69,W
1F84:  BRA    1F9E
1F86:  DECFSZ x6A,W
1F88:  BRA    1F9E
1F8A:  MOVF   x77,F
1F8C:  BNZ   1F9E
1F8E:  DECFSZ x78,W
1F90:  BRA    1F9E
....................    edo1=9; 
1F92:  MOVLW  09
1F94:  MOVWF  x76
....................    edoa1=0; 
1F96:  CLRF   x79
....................    entra_act1=1;} 
1F98:  MOVLW  01
1F9A:  MOVWF  x75
1F9C:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==1)){//CASI TERMINA DE SALIR 
1F9E:  MOVF   x75,F
1FA0:  BNZ   1FBC
1FA2:  DECFSZ x69,W
1FA4:  BRA    1FBC
1FA6:  MOVF   x6A,F
1FA8:  BNZ   1FBC
1FAA:  MOVF   x77,F
1FAC:  BNZ   1FBC
1FAE:  DECFSZ x78,W
1FB0:  BRA    1FBC
....................    edo1=10; 
1FB2:  MOVLW  0A
1FB4:  MOVWF  x76
....................    entra_act1=1;} 
1FB6:  MOVLW  01
1FB8:  MOVWF  x75
1FBA:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==0)&&(sale1==1)){//PERSONA A SALIDO POR ENTRADA 
1FBC:  MOVF   x75,F
1FBE:  BNZ   2014
1FC0:  MOVF   x69,F
1FC2:  BNZ   2014
1FC4:  MOVF   x6A,F
1FC6:  BNZ   2014
1FC8:  MOVF   x79,F
1FCA:  BNZ   2014
1FCC:  MOVF   x77,F
1FCE:  BNZ   2014
1FD0:  DECFSZ x78,W
1FD2:  BRA    2014
....................    lcd_gotoxy(8,2); 
1FD4:  MOVLW  08
1FD6:  MOVLB  1
1FD8:  MOVWF  xD8
1FDA:  MOVLW  02
1FDC:  MOVWF  xD9
1FDE:  MOVLB  0
1FE0:  CALL   086E
....................    lcd_putc(" "); 
1FE4:  MOVLW  9C
1FE6:  MOVWF  FF6
1FE8:  MOVLW  03
1FEA:  MOVWF  FF7
1FEC:  CALL   0A44
....................    if(entra_temp1==10) { 
1FF0:  MOVF   x7B,W
1FF2:  SUBLW  0A
1FF4:  BNZ   2004
....................       des1=0; 
1FF6:  CLRF   x98
....................       edo1=11; 
1FF8:  MOVLW  0B
1FFA:  MOVWF  x76
....................       sale1=0; 
1FFC:  CLRF   x78
....................       entra_act1=1;} 
1FFE:  MOVLW  01
2000:  MOVWF  x75
2002:  BRA    2012
....................    else { 
....................       des1=0; 
2004:  CLRF   x98
....................       edo1=12; 
2006:  MOVLW  0C
2008:  MOVWF  x76
....................       sale1=0; 
200A:  CLRF   x78
....................       edoa1=0; 
200C:  CLRF   x79
....................       entra_act1=1; 
200E:  MOVLW  01
2010:  MOVWF  x75
....................    } 
.................... } 
2012:  BRA    2056
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==0)&&(sale1==1)){//SALIA y se regresa 
2014:  MOVF   x75,F
2016:  BNZ   2056
2018:  MOVF   x69,F
201A:  BNZ   2056
201C:  MOVF   x6A,F
201E:  BNZ   2056
2020:  DECFSZ x79,W
2022:  BRA    2056
2024:  MOVF   x77,F
2026:  BNZ   2056
2028:  DECFSZ x78,W
202A:  BRA    2056
....................    lcd_gotoxy(8,2); 
202C:  MOVLW  08
202E:  MOVLB  1
2030:  MOVWF  xD8
2032:  MOVLW  02
2034:  MOVWF  xD9
2036:  MOVLB  0
2038:  CALL   086E
....................    lcd_putc(" "); 
203C:  MOVLW  9E
203E:  MOVWF  FF6
2040:  MOVLW  03
2042:  MOVWF  FF7
2044:  CALL   0A44
....................    des1=0; 
2048:  CLRF   x98
....................    edo1=12; 
204A:  MOVLW  0C
204C:  MOVWF  x76
....................    sale1=0; 
204E:  CLRF   x78
....................    edoa1=0; 
2050:  CLRF   x79
....................    entra_act1=1;} 
2052:  MOVLW  01
2054:  MOVWF  x75
2056:  RETURN 0
.................... } 
....................  
.................... void sensando2(){//Define estados para la maquina de estados del par 2 
.................... /////normal/////// 
.................... if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==0)){//LLEGA PERSONA EN ENTRADA1 
*
2248:  MOVF   x7C,F
224A:  BNZ   2290
224C:  DECFSZ x6B,W
224E:  BRA    2290
2250:  MOVF   x6C,F
2252:  BNZ   2290
2254:  MOVF   x7E,F
2256:  BNZ   2290
2258:  MOVF   x7F,F
225A:  BNZ   2290
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
225C:  MOVF   5B,F
225E:  BNZ   2266
2260:  MOVF   5C,F
2262:  BTFSC  FD8.2
2264:  RCALL  1D88
....................    lcd_gotoxy(8,3); 
2266:  MOVLW  08
2268:  MOVLB  1
226A:  MOVWF  xD8
226C:  MOVLW  03
226E:  MOVWF  xD9
2270:  MOVLB  0
2272:  CALL   086E
....................    lcd_putc(0x7F); 
2276:  MOVLW  7F
2278:  MOVLB  1
227A:  MOVWF  xD7
227C:  MOVLB  0
227E:  CALL   08C0
....................    des2=1; 
2282:  MOVLW  01
2284:  MOVWF  x99
....................    edo2=1; 
2286:  MOVWF  x7D
....................    entra2=1; 
2288:  MOVWF  x7E
....................    edoa2=1; 
228A:  MOVWF  x80
....................    entra_act2=1;} 
228C:  MOVWF  x7C
228E:  BRA    24CC
.................... ///prioridad 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA ENTRANDO 
2290:  MOVF   x7C,F
2292:  BNZ   22B0
2294:  DECFSZ x6B,W
2296:  BRA    22B0
2298:  DECFSZ x6C,W
229A:  BRA    22B0
229C:  DECFSZ x7E,W
229E:  BRA    22B0
22A0:  MOVF   x7F,F
22A2:  BNZ   22B0
....................    edo2=3; 
22A4:  MOVLW  03
22A6:  MOVWF  x7D
....................    edoa2=0; 
22A8:  CLRF   x80
....................    entra_act2=1;} 
22AA:  MOVLW  01
22AC:  MOVWF  x7C
22AE:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA CASI TERMINA DE ENTRAR 
22B0:  MOVF   x7C,F
22B2:  BNZ   22CE
22B4:  MOVF   x6B,F
22B6:  BNZ   22CE
22B8:  DECFSZ x6C,W
22BA:  BRA    22CE
22BC:  DECFSZ x7E,W
22BE:  BRA    22CE
22C0:  MOVF   x7F,F
22C2:  BNZ   22CE
....................    edo2=4; 
22C4:  MOVLW  04
22C6:  MOVWF  x7D
....................    entra_act2=1;} 
22C8:  MOVLW  01
22CA:  MOVWF  x7C
22CC:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==1)&&(sale2==0)){//PERSONA A ENTRADO 
22CE:  MOVF   x7C,F
22D0:  BNZ   2326
22D2:  MOVF   x6B,F
22D4:  BNZ   2326
22D6:  MOVF   x6C,F
22D8:  BNZ   2326
22DA:  MOVF   x80,F
22DC:  BNZ   2326
22DE:  DECFSZ x7E,W
22E0:  BRA    2326
22E2:  MOVF   x7F,F
22E4:  BNZ   2326
....................    lcd_gotoxy(8,3); 
22E6:  MOVLW  08
22E8:  MOVLB  1
22EA:  MOVWF  xD8
22EC:  MOVLW  03
22EE:  MOVWF  xD9
22F0:  MOVLB  0
22F2:  CALL   086E
....................    lcd_putc(" "); 
22F6:  MOVLW  A0
22F8:  MOVWF  FF6
22FA:  MOVLW  03
22FC:  MOVWF  FF7
22FE:  CALL   0A44
....................    if(entra_temp2==4){ 
2302:  MOVF   x82,W
2304:  SUBLW  04
2306:  BNZ   2316
....................       des2=0; 
2308:  CLRF   x99
....................       edo2=5; 
230A:  MOVLW  05
230C:  MOVWF  x7D
....................       entra2=0; 
230E:  CLRF   x7E
....................       entra_act2=1;} 
2310:  MOVLW  01
2312:  MOVWF  x7C
2314:  BRA    2324
....................    else{ 
....................       des2=0; 
2316:  CLRF   x99
....................       edo2=6; 
2318:  MOVLW  06
231A:  MOVWF  x7D
....................       entra2=0; 
231C:  CLRF   x7E
....................       edoa2=0; 
231E:  CLRF   x80
....................       entra_act2=1;} 
2320:  MOVLW  01
2322:  MOVWF  x7C
.................... } 
2324:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==1)&&(sale2==0)){//entraba y se regresa 
2326:  MOVF   x7C,F
2328:  BNZ   236A
232A:  MOVF   x6B,F
232C:  BNZ   236A
232E:  MOVF   x6C,F
2330:  BNZ   236A
2332:  DECFSZ x80,W
2334:  BRA    236A
2336:  DECFSZ x7E,W
2338:  BRA    236A
233A:  MOVF   x7F,F
233C:  BNZ   236A
....................    lcd_gotoxy(8,3); 
233E:  MOVLW  08
2340:  MOVLB  1
2342:  MOVWF  xD8
2344:  MOVLW  03
2346:  MOVWF  xD9
2348:  MOVLB  0
234A:  CALL   086E
....................    lcd_putc(" "); 
234E:  MOVLW  A2
2350:  MOVWF  FF6
2352:  MOVLW  03
2354:  MOVWF  FF7
2356:  CALL   0A44
....................    des2=0; 
235A:  CLRF   x99
....................    edo2=6; 
235C:  MOVLW  06
235E:  MOVWF  x7D
....................    entra2=0; 
2360:  CLRF   x7E
....................    edoa2=0; 
2362:  CLRF   x80
....................    entra_act2=1;} 
2364:  MOVLW  01
2366:  MOVWF  x7C
2368:  BRA    24CC
.................... ///// 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==1)&&(sale2==0)){ 
236A:  MOVF   x7C,F
236C:  BNZ   238A
236E:  DECFSZ x6B,W
2370:  BRA    238A
2372:  MOVF   x6C,F
2374:  BNZ   238A
2376:  DECFSZ x7E,W
2378:  BRA    238A
237A:  MOVF   x7F,F
237C:  BNZ   238A
....................    edo2=2; 
237E:  MOVLW  02
2380:  MOVWF  x7D
....................    edoa2=1; 
2382:  MOVLW  01
2384:  MOVWF  x80
....................    entra_act2=1;}//checar prioridad 
2386:  MOVWF  x7C
2388:  BRA    24CC
.................... //////sentido inverso/// 
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
238A:  MOVF   x7C,F
238C:  BNZ   23D4
238E:  MOVF   x6B,F
2390:  BNZ   23D4
2392:  DECFSZ x6C,W
2394:  BRA    23D4
2396:  MOVF   x7E,F
2398:  BNZ   23D4
239A:  MOVF   x7F,F
239C:  BNZ   23D4
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
239E:  MOVF   5B,F
23A0:  BNZ   23A8
23A2:  MOVF   5C,F
23A4:  BTFSC  FD8.2
23A6:  RCALL  1D88
....................    lcd_gotoxy(8,3); 
23A8:  MOVLW  08
23AA:  MOVLB  1
23AC:  MOVWF  xD8
23AE:  MOVLW  03
23B0:  MOVWF  xD9
23B2:  MOVLB  0
23B4:  CALL   086E
....................    lcd_putc(0x7E);//flecha del sentido 
23B8:  MOVLW  7E
23BA:  MOVLB  1
23BC:  MOVWF  xD7
23BE:  MOVLB  0
23C0:  CALL   08C0
....................    des2=1; 
23C4:  MOVLW  01
23C6:  MOVWF  x99
....................    edo2=7; 
23C8:  MOVLW  07
23CA:  MOVWF  x7D
....................    sale2=1; 
23CC:  MOVLW  01
23CE:  MOVWF  x7F
....................    entra_act2=1;} 
23D0:  MOVWF  x7C
23D2:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 1 
23D4:  MOVF   x7C,F
23D6:  BNZ   23F4
23D8:  MOVF   x6B,F
23DA:  BNZ   23F4
23DC:  DECFSZ x6C,W
23DE:  BRA    23F4
23E0:  MOVF   x7E,F
23E2:  BNZ   23F4
23E4:  DECFSZ x7F,W
23E6:  BRA    23F4
....................    edo2=8; 
23E8:  MOVLW  08
23EA:  MOVWF  x7D
....................    edoa2=1; 
23EC:  MOVLW  01
23EE:  MOVWF  x80
....................    entra_act2=1;} 
23F0:  MOVWF  x7C
23F2:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 2 
23F4:  MOVF   x7C,F
23F6:  BNZ   2414
23F8:  DECFSZ x6B,W
23FA:  BRA    2414
23FC:  DECFSZ x6C,W
23FE:  BRA    2414
2400:  MOVF   x7E,F
2402:  BNZ   2414
2404:  DECFSZ x7F,W
2406:  BRA    2414
....................    edo2=9; 
2408:  MOVLW  09
240A:  MOVWF  x7D
....................    edoa2=0; 
240C:  CLRF   x80
....................    entra_act2=1;} 
240E:  MOVLW  01
2410:  MOVWF  x7C
2412:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==1)){//CASI TERMINA DE SALIR 
2414:  MOVF   x7C,F
2416:  BNZ   2432
2418:  DECFSZ x6B,W
241A:  BRA    2432
241C:  MOVF   x6C,F
241E:  BNZ   2432
2420:  MOVF   x7E,F
2422:  BNZ   2432
2424:  DECFSZ x7F,W
2426:  BRA    2432
....................    edo2=10; 
2428:  MOVLW  0A
242A:  MOVWF  x7D
....................    entra_act2=1;} 
242C:  MOVLW  01
242E:  MOVWF  x7C
2430:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==0)&&(sale2==1)){//PERSONA A SALIDO POR ENTRADA 
2432:  MOVF   x7C,F
2434:  BNZ   248A
2436:  MOVF   x6B,F
2438:  BNZ   248A
243A:  MOVF   x6C,F
243C:  BNZ   248A
243E:  MOVF   x80,F
2440:  BNZ   248A
2442:  MOVF   x7E,F
2444:  BNZ   248A
2446:  DECFSZ x7F,W
2448:  BRA    248A
....................    lcd_gotoxy(8,3); 
244A:  MOVLW  08
244C:  MOVLB  1
244E:  MOVWF  xD8
2450:  MOVLW  03
2452:  MOVWF  xD9
2454:  MOVLB  0
2456:  CALL   086E
....................    lcd_putc(" "); 
245A:  MOVLW  A4
245C:  MOVWF  FF6
245E:  MOVLW  03
2460:  MOVWF  FF7
2462:  CALL   0A44
....................    if(entra_temp2==10){ 
2466:  MOVF   x82,W
2468:  SUBLW  0A
246A:  BNZ   247A
....................       des2=0; 
246C:  CLRF   x99
....................       edo2=11; 
246E:  MOVLW  0B
2470:  MOVWF  x7D
....................       sale2=0; 
2472:  CLRF   x7F
....................       entra_act2=1;} 
2474:  MOVLW  01
2476:  MOVWF  x7C
2478:  BRA    2488
....................    else{ 
....................       des2=0; 
247A:  CLRF   x99
....................       edo2=12; 
247C:  MOVLW  0C
247E:  MOVWF  x7D
....................       sale2=0; 
2480:  CLRF   x7F
....................       edoa2=0; 
2482:  CLRF   x80
....................       entra_act2=1;} 
2484:  MOVLW  01
2486:  MOVWF  x7C
.................... } 
2488:  BRA    24CC
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==0)&&(sale2==1)){//SALIA y se regresa 
248A:  MOVF   x7C,F
248C:  BNZ   24CC
248E:  MOVF   x6B,F
2490:  BNZ   24CC
2492:  MOVF   x6C,F
2494:  BNZ   24CC
2496:  DECFSZ x80,W
2498:  BRA    24CC
249A:  MOVF   x7E,F
249C:  BNZ   24CC
249E:  DECFSZ x7F,W
24A0:  BRA    24CC
....................    lcd_gotoxy(8,3); 
24A2:  MOVLW  08
24A4:  MOVLB  1
24A6:  MOVWF  xD8
24A8:  MOVLW  03
24AA:  MOVWF  xD9
24AC:  MOVLB  0
24AE:  CALL   086E
....................    lcd_putc(" "); 
24B2:  MOVLW  A6
24B4:  MOVWF  FF6
24B6:  MOVLW  03
24B8:  MOVWF  FF7
24BA:  CALL   0A44
....................    des2=0; 
24BE:  CLRF   x99
....................    edo2=12; 
24C0:  MOVLW  0C
24C2:  MOVWF  x7D
....................    sale2=0; 
24C4:  CLRF   x7F
....................    edoa2=0; 
24C6:  CLRF   x80
....................    entra_act2=1;} 
24C8:  MOVLW  01
24CA:  MOVWF  x7C
24CC:  RETURN 0
.................... } 
....................  
.................... void sensando3(){//Define estados para la maquina de estados del par 3 
.................... /////normal/////// 
.................... if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==0)){//LLEGA PERSONA EN ENTRADA1 
*
2550:  MOVF   x83,F
2552:  BNZ   2598
2554:  DECFSZ x6D,W
2556:  BRA    2598
2558:  MOVF   x6E,F
255A:  BNZ   2598
255C:  MOVF   x85,F
255E:  BNZ   2598
2560:  MOVF   x86,F
2562:  BNZ   2598
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2564:  MOVF   5B,F
2566:  BNZ   256E
2568:  MOVF   5C,F
256A:  BTFSC  FD8.2
256C:  RCALL  1D88
....................    lcd_gotoxy(8,4); 
256E:  MOVLW  08
2570:  MOVLB  1
2572:  MOVWF  xD8
2574:  MOVLW  04
2576:  MOVWF  xD9
2578:  MOVLB  0
257A:  CALL   086E
....................    lcd_putc(0x7F); 
257E:  MOVLW  7F
2580:  MOVLB  1
2582:  MOVWF  xD7
2584:  MOVLB  0
2586:  CALL   08C0
....................    des3=1; 
258A:  MOVLW  01
258C:  MOVWF  x9A
....................    edo3=1; 
258E:  MOVWF  x84
....................    entra3=1; 
2590:  MOVWF  x85
....................    edoa3=1; 
2592:  MOVWF  x87
....................    entra_act3=1;} 
2594:  MOVWF  x83
2596:  BRA    27D6
.................... ///prioridad 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA ENTRANDO 
2598:  MOVF   x83,F
259A:  BNZ   25B8
259C:  DECFSZ x6D,W
259E:  BRA    25B8
25A0:  DECFSZ x6E,W
25A2:  BRA    25B8
25A4:  DECFSZ x85,W
25A6:  BRA    25B8
25A8:  MOVF   x86,F
25AA:  BNZ   25B8
....................    edo3=3; 
25AC:  MOVLW  03
25AE:  MOVWF  x84
....................    edoa3=0; 
25B0:  CLRF   x87
....................    entra_act3=1;} 
25B2:  MOVLW  01
25B4:  MOVWF  x83
25B6:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA CASI TERMINA DE ENTRAR 
25B8:  MOVF   x83,F
25BA:  BNZ   25D6
25BC:  MOVF   x6D,F
25BE:  BNZ   25D6
25C0:  DECFSZ x6E,W
25C2:  BRA    25D6
25C4:  DECFSZ x85,W
25C6:  BRA    25D6
25C8:  MOVF   x86,F
25CA:  BNZ   25D6
....................    edo3=4; 
25CC:  MOVLW  04
25CE:  MOVWF  x84
....................    entra_act3=1;} 
25D0:  MOVLW  01
25D2:  MOVWF  x83
25D4:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==1)&&(sale3==0)){//PERSONA A ENTRADO 
25D6:  MOVF   x83,F
25D8:  BNZ   262E
25DA:  MOVF   x6D,F
25DC:  BNZ   262E
25DE:  MOVF   x6E,F
25E0:  BNZ   262E
25E2:  MOVF   x87,F
25E4:  BNZ   262E
25E6:  DECFSZ x85,W
25E8:  BRA    262E
25EA:  MOVF   x86,F
25EC:  BNZ   262E
....................    lcd_gotoxy(8,4); 
25EE:  MOVLW  08
25F0:  MOVLB  1
25F2:  MOVWF  xD8
25F4:  MOVLW  04
25F6:  MOVWF  xD9
25F8:  MOVLB  0
25FA:  CALL   086E
....................    lcd_putc(" "); 
25FE:  MOVLW  A8
2600:  MOVWF  FF6
2602:  MOVLW  03
2604:  MOVWF  FF7
2606:  CALL   0A44
....................    if(entra_temp3==4){ 
260A:  MOVF   x89,W
260C:  SUBLW  04
260E:  BNZ   261E
....................       des3=0; 
2610:  CLRF   x9A
....................       edo3=5; 
2612:  MOVLW  05
2614:  MOVWF  x84
....................       entra3=0; 
2616:  CLRF   x85
....................       entra_act3=1;} 
2618:  MOVLW  01
261A:  MOVWF  x83
261C:  BRA    262C
....................    else{ 
....................       des3=0; 
261E:  CLRF   x9A
....................       edo3=6; 
2620:  MOVLW  06
2622:  MOVWF  x84
....................       entra3=0; 
2624:  CLRF   x85
....................       edoa3=0; 
2626:  CLRF   x87
....................       entra_act3=1;} 
2628:  MOVLW  01
262A:  MOVWF  x83
.................... } 
262C:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==1)&&(sale3==0)){//entraba y se regresa 
262E:  MOVF   x83,F
2630:  BNZ   2672
2632:  MOVF   x6D,F
2634:  BNZ   2672
2636:  MOVF   x6E,F
2638:  BNZ   2672
263A:  DECFSZ x87,W
263C:  BRA    2672
263E:  DECFSZ x85,W
2640:  BRA    2672
2642:  MOVF   x86,F
2644:  BNZ   2672
....................    lcd_gotoxy(8,4); 
2646:  MOVLW  08
2648:  MOVLB  1
264A:  MOVWF  xD8
264C:  MOVLW  04
264E:  MOVWF  xD9
2650:  MOVLB  0
2652:  CALL   086E
....................    lcd_putc(" "); 
2656:  MOVLW  AA
2658:  MOVWF  FF6
265A:  MOVLW  03
265C:  MOVWF  FF7
265E:  CALL   0A44
....................    des3=0; 
2662:  CLRF   x9A
....................    edo3=6; 
2664:  MOVLW  06
2666:  MOVWF  x84
....................    entra3=0; 
2668:  CLRF   x85
....................    edoa3=0; 
266A:  CLRF   x87
....................    entra_act3=1;} 
266C:  MOVLW  01
266E:  MOVWF  x83
2670:  BRA    27D6
.................... ///// 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==1)&&(sale3==0)){ 
2672:  MOVF   x83,F
2674:  BNZ   2692
2676:  DECFSZ x6D,W
2678:  BRA    2692
267A:  MOVF   x6E,F
267C:  BNZ   2692
267E:  DECFSZ x85,W
2680:  BRA    2692
2682:  MOVF   x86,F
2684:  BNZ   2692
....................    //sentidos(); 
....................    edo3=2; 
2686:  MOVLW  02
2688:  MOVWF  x84
....................    edoa3=1; 
268A:  MOVLW  01
268C:  MOVWF  x87
....................    entra_act3=1;}//checar prioridad 
268E:  MOVWF  x83
2690:  BRA    27D6
.................... //////sentido inverso/// 
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
2692:  MOVF   x83,F
2694:  BNZ   26DE
2696:  MOVF   x6D,F
2698:  BNZ   26DE
269A:  DECFSZ x6E,W
269C:  BRA    26DE
269E:  MOVF   x85,F
26A0:  BNZ   26DE
26A2:  MOVF   x86,F
26A4:  BNZ   26DE
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
26A6:  MOVF   5B,F
26A8:  BNZ   26B2
26AA:  MOVF   5C,F
26AC:  BTFSC  FD8.2
26AE:  CALL   1D88
....................    lcd_gotoxy(8,4); 
26B2:  MOVLW  08
26B4:  MOVLB  1
26B6:  MOVWF  xD8
26B8:  MOVLW  04
26BA:  MOVWF  xD9
26BC:  MOVLB  0
26BE:  CALL   086E
....................    lcd_putc(0x7E);//flecha del sentido 
26C2:  MOVLW  7E
26C4:  MOVLB  1
26C6:  MOVWF  xD7
26C8:  MOVLB  0
26CA:  CALL   08C0
....................    des3=1; 
26CE:  MOVLW  01
26D0:  MOVWF  x9A
....................    edo3=7; 
26D2:  MOVLW  07
26D4:  MOVWF  x84
....................    sale3=1; 
26D6:  MOVLW  01
26D8:  MOVWF  x86
....................    entra_act3=1;} 
26DA:  MOVWF  x83
26DC:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 1 
26DE:  MOVF   x83,F
26E0:  BNZ   26FE
26E2:  MOVF   x6D,F
26E4:  BNZ   26FE
26E6:  DECFSZ x6E,W
26E8:  BRA    26FE
26EA:  MOVF   x85,F
26EC:  BNZ   26FE
26EE:  DECFSZ x86,W
26F0:  BRA    26FE
....................    edo3=8; 
26F2:  MOVLW  08
26F4:  MOVWF  x84
....................    edoa3=1; 
26F6:  MOVLW  01
26F8:  MOVWF  x87
....................    entra_act3=1;} 
26FA:  MOVWF  x83
26FC:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 2 
26FE:  MOVF   x83,F
2700:  BNZ   271E
2702:  DECFSZ x6D,W
2704:  BRA    271E
2706:  DECFSZ x6E,W
2708:  BRA    271E
270A:  MOVF   x85,F
270C:  BNZ   271E
270E:  DECFSZ x86,W
2710:  BRA    271E
....................    edo3=9; 
2712:  MOVLW  09
2714:  MOVWF  x84
....................    edoa3=0; 
2716:  CLRF   x87
....................    entra_act3=1;} 
2718:  MOVLW  01
271A:  MOVWF  x83
271C:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==1)){//CASI TERMINA DE SALIR 
271E:  MOVF   x83,F
2720:  BNZ   273C
2722:  DECFSZ x6D,W
2724:  BRA    273C
2726:  MOVF   x6E,F
2728:  BNZ   273C
272A:  MOVF   x85,F
272C:  BNZ   273C
272E:  DECFSZ x86,W
2730:  BRA    273C
....................    edo3=10; 
2732:  MOVLW  0A
2734:  MOVWF  x84
....................    entra_act3=1;} 
2736:  MOVLW  01
2738:  MOVWF  x83
273A:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==0)&&(sale3==1)){//PERSONA A SALIDO POR ENTRADA 
273C:  MOVF   x83,F
273E:  BNZ   2794
2740:  MOVF   x6D,F
2742:  BNZ   2794
2744:  MOVF   x6E,F
2746:  BNZ   2794
2748:  MOVF   x87,F
274A:  BNZ   2794
274C:  MOVF   x85,F
274E:  BNZ   2794
2750:  DECFSZ x86,W
2752:  BRA    2794
....................    lcd_gotoxy(8,4); 
2754:  MOVLW  08
2756:  MOVLB  1
2758:  MOVWF  xD8
275A:  MOVLW  04
275C:  MOVWF  xD9
275E:  MOVLB  0
2760:  CALL   086E
....................    lcd_putc(" "); 
2764:  MOVLW  AC
2766:  MOVWF  FF6
2768:  MOVLW  03
276A:  MOVWF  FF7
276C:  CALL   0A44
....................    if(entra_temp3==10){ 
2770:  MOVF   x89,W
2772:  SUBLW  0A
2774:  BNZ   2784
....................       des3=0; 
2776:  CLRF   x9A
....................       edo3=11; 
2778:  MOVLW  0B
277A:  MOVWF  x84
....................       sale3=0; 
277C:  CLRF   x86
....................       entra_act3=1;} 
277E:  MOVLW  01
2780:  MOVWF  x83
2782:  BRA    2792
....................    else{ 
....................       des3=0; 
2784:  CLRF   x9A
....................       edo3=12; 
2786:  MOVLW  0C
2788:  MOVWF  x84
....................       sale3=0; 
278A:  CLRF   x86
....................       edoa3=0; 
278C:  CLRF   x87
....................       entra_act3=1;} 
278E:  MOVLW  01
2790:  MOVWF  x83
.................... } 
2792:  BRA    27D6
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==0)&&(sale3==1)){//SALIA y se regresa 
2794:  MOVF   x83,F
2796:  BNZ   27D6
2798:  MOVF   x6D,F
279A:  BNZ   27D6
279C:  MOVF   x6E,F
279E:  BNZ   27D6
27A0:  DECFSZ x87,W
27A2:  BRA    27D6
27A4:  MOVF   x85,F
27A6:  BNZ   27D6
27A8:  DECFSZ x86,W
27AA:  BRA    27D6
....................    lcd_gotoxy(8,4); 
27AC:  MOVLW  08
27AE:  MOVLB  1
27B0:  MOVWF  xD8
27B2:  MOVLW  04
27B4:  MOVWF  xD9
27B6:  MOVLB  0
27B8:  CALL   086E
....................    lcd_putc(" "); 
27BC:  MOVLW  AE
27BE:  MOVWF  FF6
27C0:  MOVLW  03
27C2:  MOVWF  FF7
27C4:  CALL   0A44
....................    des3=0; 
27C8:  CLRF   x9A
....................    edo3=12; 
27CA:  MOVLW  0C
27CC:  MOVWF  x84
....................    sale3=0; 
27CE:  CLRF   x86
....................    edoa3=0; 
27D0:  CLRF   x87
....................    entra_act3=1;} 
27D2:  MOVLW  01
27D4:  MOVWF  x83
27D6:  RETURN 0
.................... } 
....................  
.................... void sensores(){//Detecta estado (bloqueado o libre) de los sensores 
.................... //sensor1 
.................... ent1=input(entrada01); 
*
285A:  BSF    F93.4
285C:  CLRF   55
285E:  BTFSC  F81.4
2860:  INCF   55,F
.................... if(ent1==1){ 
2862:  DECFSZ 55,W
2864:  BRA    287E
....................    sub_cta1=0; 
2866:  CLRF   5E
2868:  CLRF   5D
....................    detec1=0; 
286A:  CLRF   x69
....................    bloq_p1=0;//deshabilita bloqueo par1 
286C:  CLRF   x9B
....................    tim_p1=0; 
286E:  CLRF   xA2
2870:  CLRF   xA1
....................    if(en_b1) {//pregunta si esta sonando el par1 
2872:  MOVF   x9E,F
2874:  BZ    287C
....................       output_low(salida01);//apaga alarma bloqueo 
2876:  BCF    F94.3
2878:  BCF    F8B.3
....................       en_b1=0; 
287A:  CLRF   x9E
....................    } 
.................... } 
287C:  BRA    28D8
.................... else { 
....................    if(sub_cta1>=s_cta) detec1=1;//revisa si se interumpio la luz en (5ms*4) 
287E:  MOVF   5E,F
2880:  BNZ   2888
2882:  MOVF   5D,W
2884:  SUBLW  04
2886:  BC    288C
2888:  MOVLW  01
288A:  MOVWF  x69
....................    if(sub_d1!=detec1) {//si, cambia de estado el sensor 
288C:  MOVF   x69,W
288E:  SUBWF  x6F,W
2890:  BZ    28D8
....................       sub_d1=detec1; 
2892:  MOVFF  69,6F
....................       enable1=1; 
2896:  MOVLW  01
2898:  MOVWF  x7A
....................       lcd_gotoxy(5,2); 
289A:  MOVLW  05
289C:  MOVLB  1
289E:  MOVWF  xD8
28A0:  MOVLW  02
28A2:  MOVWF  xD9
28A4:  MOVLB  0
28A6:  CALL   086E
....................       printf(lcd_putc,"1:%d",sub_d1); 
28AA:  MOVLW  31
28AC:  MOVLB  1
28AE:  MOVWF  xD7
28B0:  MOVLB  0
28B2:  CALL   08C0
28B6:  MOVLW  3A
28B8:  MOVLB  1
28BA:  MOVWF  xD7
28BC:  MOVLB  0
28BE:  CALL   08C0
28C2:  MOVFF  6F,1CD
28C6:  MOVLW  18
28C8:  MOVLB  1
28CA:  MOVWF  xCE
28CC:  MOVLB  0
28CE:  CALL   10EC
....................       sensando1(); 
28D2:  CALL   1DD2
....................       contando1(); 
28D6:  RCALL  21C6
....................    } 
.................... } 
.................... //sensor2 
.................... ent2=input(entrada02); 
28D8:  BSF    F95.4
28DA:  CLRF   56
28DC:  BTFSC  F83.4
28DE:  INCF   56,F
.................... if(ent2==1){ 
28E0:  DECFSZ 56,W
28E2:  BRA    2900
....................    output_high(salida02);// 
28E4:  BCF    F94.4
28E6:  BSF    F8B.4
....................    sub_cta2=0; 
28E8:  CLRF   x60
28EA:  CLRF   5F
....................    detec2=0; 
28EC:  CLRF   x6A
....................    bloq_p1=0;//deshabilita bloqueo 
28EE:  CLRF   x9B
....................    tim_p1=0; 
28F0:  CLRF   xA2
28F2:  CLRF   xA1
....................    if(en_b1) { 
28F4:  MOVF   x9E,F
28F6:  BZ    28FE
....................       output_low(salida01);//apaga alarma bloqueo 
28F8:  BCF    F94.3
28FA:  BCF    F8B.3
....................       en_b1=0; 
28FC:  CLRF   x9E
....................    } 
.................... } 
28FE:  BRA    2968
.................... else { 
....................    output_low(salida02); 
2900:  BCF    F94.4
2902:  BCF    F8B.4
....................    if(sub_cta2>=s_cta) detec2=1; 
2904:  MOVF   x60,F
2906:  BNZ   290E
2908:  MOVF   5F,W
290A:  SUBLW  04
290C:  BC    2912
290E:  MOVLW  01
2910:  MOVWF  x6A
....................    if(sub_d2!=detec2) { 
2912:  MOVF   x6A,W
2914:  SUBWF  x70,W
2916:  BZ    2968
....................       sub_d2=detec2; 
2918:  MOVFF  6A,70
....................       enable1=1; 
291C:  MOVLW  01
291E:  MOVWF  x7A
....................       lcd_gotoxy(1,2); 
2920:  MOVLB  1
2922:  MOVWF  xD8
2924:  MOVLW  02
2926:  MOVWF  xD9
2928:  MOVLB  0
292A:  CALL   086E
....................       printf(lcd_putc,"2:%d ",sub_d2); 
292E:  MOVLW  32
2930:  MOVLB  1
2932:  MOVWF  xD7
2934:  MOVLB  0
2936:  CALL   08C0
293A:  MOVLW  3A
293C:  MOVLB  1
293E:  MOVWF  xD7
2940:  MOVLB  0
2942:  CALL   08C0
2946:  MOVFF  70,1CD
294A:  MOVLW  18
294C:  MOVLB  1
294E:  MOVWF  xCE
2950:  MOVLB  0
2952:  CALL   10EC
2956:  MOVLW  20
2958:  MOVLB  1
295A:  MOVWF  xD7
295C:  MOVLB  0
295E:  CALL   08C0
....................       sensando1(); 
2962:  CALL   1DD2
....................       contando1(); 
2966:  RCALL  21C6
....................    } 
.................... } 
.................... //sensor3 
.................... ent3=input(entrada03); 
2968:  BSF    F93.2
296A:  CLRF   57
296C:  BTFSC  F81.2
296E:  INCF   57,F
.................... if(ent3==1){ 
2970:  DECFSZ 57,W
2972:  BRA    298C
....................    sub_cta3=0; 
2974:  CLRF   x62
2976:  CLRF   x61
....................    detec3=0; 
2978:  CLRF   x6B
....................    bloq_p2=0;//deshabilita bloqueo 
297A:  CLRF   x9C
....................    tim_p2=0; 
297C:  CLRF   xA4
297E:  CLRF   xA3
....................    if(en_b2) { 
2980:  MOVF   x9F,F
2982:  BZ    298A
....................       output_low(salida01);//apaga alarma bloqueo 
2984:  BCF    F94.3
2986:  BCF    F8B.3
....................       en_b2=0; 
2988:  CLRF   x9F
....................    } 
.................... } 
298A:  BRA    29E4
.................... else { 
....................    if(sub_cta3>=s_cta) detec3=1; 
298C:  MOVF   x62,F
298E:  BNZ   2996
2990:  MOVF   x61,W
2992:  SUBLW  04
2994:  BC    299A
2996:  MOVLW  01
2998:  MOVWF  x6B
....................    if(sub_d3!=detec3) { 
299A:  MOVF   x6B,W
299C:  SUBWF  x71,W
299E:  BZ    29E4
....................       sub_d3=detec3; 
29A0:  MOVFF  6B,71
....................       enable2=1; 
29A4:  MOVLW  01
29A6:  MOVWF  x81
....................       lcd_gotoxy(5,3); 
29A8:  MOVLW  05
29AA:  MOVLB  1
29AC:  MOVWF  xD8
29AE:  MOVLW  03
29B0:  MOVWF  xD9
29B2:  MOVLB  0
29B4:  CALL   086E
....................       printf(lcd_putc,"3:%d",sub_d3); 
29B8:  MOVLW  33
29BA:  MOVLB  1
29BC:  MOVWF  xD7
29BE:  MOVLB  0
29C0:  CALL   08C0
29C4:  MOVLW  3A
29C6:  MOVLB  1
29C8:  MOVWF  xD7
29CA:  MOVLB  0
29CC:  CALL   08C0
29D0:  MOVFF  71,1CD
29D4:  MOVLW  18
29D6:  MOVLB  1
29D8:  MOVWF  xCE
29DA:  MOVLB  0
29DC:  CALL   10EC
....................       sensando2(); 
29E0:  RCALL  2248
....................       contando2(); 
29E2:  RCALL  24CE
....................    } 
.................... } 
.................... //sensor4 
.................... ent4=input(entrada04); 
29E4:  BSF    F93.3
29E6:  CLRF   58
29E8:  BTFSC  F81.3
29EA:  INCF   58,F
.................... if(ent4==1){ 
29EC:  DECFSZ 58,W
29EE:  BRA    2A0C
....................    output_high(salida02);// 
29F0:  BCF    F94.4
29F2:  BSF    F8B.4
....................    sub_cta4=0; 
29F4:  CLRF   x64
29F6:  CLRF   x63
....................    detec4=0; 
29F8:  CLRF   x6C
....................    bloq_p2=0;//deshabilita bloqueo 
29FA:  CLRF   x9C
....................    tim_p2=0; 
29FC:  CLRF   xA4
29FE:  CLRF   xA3
....................    if(en_b2) { 
2A00:  MOVF   x9F,F
2A02:  BZ    2A0A
....................       output_low(salida01);//apaga alarma bloqueo 
2A04:  BCF    F94.3
2A06:  BCF    F8B.3
....................       en_b2=0; 
2A08:  CLRF   x9F
....................    } 
.................... } 
2A0A:  BRA    2A74
.................... else { 
....................     output_low(salida02); 
2A0C:  BCF    F94.4
2A0E:  BCF    F8B.4
....................     if(sub_cta4>=s_cta) detec4=1; 
2A10:  MOVF   x64,F
2A12:  BNZ   2A1A
2A14:  MOVF   x63,W
2A16:  SUBLW  04
2A18:  BC    2A1E
2A1A:  MOVLW  01
2A1C:  MOVWF  x6C
....................     if(sub_d4!=detec4) { 
2A1E:  MOVF   x6C,W
2A20:  SUBWF  x72,W
2A22:  BZ    2A74
....................       sub_d4=detec4; 
2A24:  MOVFF  6C,72
....................       enable2=1; 
2A28:  MOVLW  01
2A2A:  MOVWF  x81
....................       lcd_gotoxy(1,3); 
2A2C:  MOVLB  1
2A2E:  MOVWF  xD8
2A30:  MOVLW  03
2A32:  MOVWF  xD9
2A34:  MOVLB  0
2A36:  CALL   086E
....................       printf(lcd_putc,"4:%d ",sub_d4); 
2A3A:  MOVLW  34
2A3C:  MOVLB  1
2A3E:  MOVWF  xD7
2A40:  MOVLB  0
2A42:  CALL   08C0
2A46:  MOVLW  3A
2A48:  MOVLB  1
2A4A:  MOVWF  xD7
2A4C:  MOVLB  0
2A4E:  CALL   08C0
2A52:  MOVFF  72,1CD
2A56:  MOVLW  18
2A58:  MOVLB  1
2A5A:  MOVWF  xCE
2A5C:  MOVLB  0
2A5E:  CALL   10EC
2A62:  MOVLW  20
2A64:  MOVLB  1
2A66:  MOVWF  xD7
2A68:  MOVLB  0
2A6A:  CALL   08C0
....................       sensando2(); 
2A6E:  CALL   2248
....................       contando2(); 
2A72:  RCALL  24CE
....................    } 
.................... } 
.................... //sensor5 
.................... ent5=input(entrada05); 
2A74:  BSF    F93.0
2A76:  CLRF   59
2A78:  BTFSC  F81.0
2A7A:  INCF   59,F
.................... if(ent5==1){ 
2A7C:  DECFSZ 59,W
2A7E:  BRA    2A98
....................    sub_cta5=0; 
2A80:  CLRF   x66
2A82:  CLRF   x65
....................    detec5=0; 
2A84:  CLRF   x6D
....................    bloq_p3=0;//deshabilita bloqueo 
2A86:  CLRF   x9D
....................    tim_p3=0; 
2A88:  CLRF   xA6
2A8A:  CLRF   xA5
....................    if(en_b3) { 
2A8C:  MOVF   xA0,F
2A8E:  BZ    2A96
....................       output_low(salida01);//apaga alarma bloqueo 
2A90:  BCF    F94.3
2A92:  BCF    F8B.3
....................       en_b3=0; 
2A94:  CLRF   xA0
....................    } 
.................... } 
2A96:  BRA    2AF0
.................... else { 
....................     if(sub_cta5>=s_cta) detec5=1; 
2A98:  MOVF   x66,F
2A9A:  BNZ   2AA2
2A9C:  MOVF   x65,W
2A9E:  SUBLW  04
2AA0:  BC    2AA6
2AA2:  MOVLW  01
2AA4:  MOVWF  x6D
....................     if(sub_d5!=detec5) { 
2AA6:  MOVF   x6D,W
2AA8:  SUBWF  x73,W
2AAA:  BZ    2AF0
....................       sub_d5=detec5; 
2AAC:  MOVFF  6D,73
....................       enable3=1; 
2AB0:  MOVLW  01
2AB2:  MOVWF  x88
....................       lcd_gotoxy(5,4); 
2AB4:  MOVLW  05
2AB6:  MOVLB  1
2AB8:  MOVWF  xD8
2ABA:  MOVLW  04
2ABC:  MOVWF  xD9
2ABE:  MOVLB  0
2AC0:  CALL   086E
....................       printf(lcd_putc,"5:%d",sub_d5); 
2AC4:  MOVLW  35
2AC6:  MOVLB  1
2AC8:  MOVWF  xD7
2ACA:  MOVLB  0
2ACC:  CALL   08C0
2AD0:  MOVLW  3A
2AD2:  MOVLB  1
2AD4:  MOVWF  xD7
2AD6:  MOVLB  0
2AD8:  CALL   08C0
2ADC:  MOVFF  73,1CD
2AE0:  MOVLW  18
2AE2:  MOVLB  1
2AE4:  MOVWF  xCE
2AE6:  MOVLB  0
2AE8:  CALL   10EC
....................       sensando3(); 
2AEC:  RCALL  2550
....................       contando3(); 
2AEE:  RCALL  27D8
....................    } 
.................... } 
.................... //sensor6 
.................... ent6=input(entrada06); 
2AF0:  BSF    F93.1
2AF2:  CLRF   5A
2AF4:  BTFSC  F81.1
2AF6:  INCF   5A,F
.................... if(ent6==1){ 
2AF8:  DECFSZ 5A,W
2AFA:  BRA    2B18
....................    output_high(salida02);// 
2AFC:  BCF    F94.4
2AFE:  BSF    F8B.4
....................    sub_cta6=0; 
2B00:  CLRF   x68
2B02:  CLRF   x67
....................    detec6=0; 
2B04:  CLRF   x6E
....................    bloq_p3=0;//deshabilita bloqueo 
2B06:  CLRF   x9D
....................    tim_p3=0; 
2B08:  CLRF   xA6
2B0A:  CLRF   xA5
....................    if(en_b3) { 
2B0C:  MOVF   xA0,F
2B0E:  BZ    2B16
....................       output_low(salida01);//apaga alarma bloqueo 
2B10:  BCF    F94.3
2B12:  BCF    F8B.3
....................       en_b3=0; 
2B14:  CLRF   xA0
....................    } 
.................... } 
2B16:  BRA    2B7E
.................... else { 
....................    output_low(salida02);// 
2B18:  BCF    F94.4
2B1A:  BCF    F8B.4
....................    if(sub_cta6>=s_cta)   detec6=1; 
2B1C:  MOVF   x68,F
2B1E:  BNZ   2B26
2B20:  MOVF   x67,W
2B22:  SUBLW  04
2B24:  BC    2B2A
2B26:  MOVLW  01
2B28:  MOVWF  x6E
....................    if(sub_d6!=detec6) { 
2B2A:  MOVF   x6E,W
2B2C:  SUBWF  x74,W
2B2E:  BZ    2B7E
....................       sub_d6=detec6; 
2B30:  MOVFF  6E,74
....................       enable3=1; 
2B34:  MOVLW  01
2B36:  MOVWF  x88
....................       lcd_gotoxy(1,4); 
2B38:  MOVLB  1
2B3A:  MOVWF  xD8
2B3C:  MOVLW  04
2B3E:  MOVWF  xD9
2B40:  MOVLB  0
2B42:  CALL   086E
....................       printf(lcd_putc,"6:%d ",sub_d6); 
2B46:  MOVLW  36
2B48:  MOVLB  1
2B4A:  MOVWF  xD7
2B4C:  MOVLB  0
2B4E:  CALL   08C0
2B52:  MOVLW  3A
2B54:  MOVLB  1
2B56:  MOVWF  xD7
2B58:  MOVLB  0
2B5A:  CALL   08C0
2B5E:  MOVFF  74,1CD
2B62:  MOVLW  18
2B64:  MOVLB  1
2B66:  MOVWF  xCE
2B68:  MOVLB  0
2B6A:  CALL   10EC
2B6E:  MOVLW  20
2B70:  MOVLB  1
2B72:  MOVWF  xD7
2B74:  MOVLB  0
2B76:  CALL   08C0
....................       sensando3(); 
2B7A:  RCALL  2550
....................       contando3(); 
2B7C:  RCALL  27D8
....................    } 
.................... } 
.................... ////////////////////////// 
.................... if( (detec1==1)&&(detec2==1)&&(bloq_p1==0) ){ 
2B7E:  DECFSZ x69,W
2B80:  BRA    2B92
2B82:  DECFSZ x6A,W
2B84:  BRA    2B92
2B86:  MOVF   x9B,F
2B88:  BNZ   2B92
....................          bloq_p1=1; 
2B8A:  MOVLW  01
2B8C:  MOVWF  x9B
....................          tim_p1=0; 
2B8E:  CLRF   xA2
2B90:  CLRF   xA1
....................       } 
.................... if( (detec3==1)&&(detec4==1)&&(bloq_p2==0) ){ 
2B92:  DECFSZ x6B,W
2B94:  BRA    2BA6
2B96:  DECFSZ x6C,W
2B98:  BRA    2BA6
2B9A:  MOVF   x9C,F
2B9C:  BNZ   2BA6
....................          bloq_p2=1; 
2B9E:  MOVLW  01
2BA0:  MOVWF  x9C
....................          tim_p2=0; 
2BA2:  CLRF   xA4
2BA4:  CLRF   xA3
....................       } 
.................... if( (detec5==1)&&(detec6==1)&&(bloq_p3==0) ){ 
2BA6:  DECFSZ x6D,W
2BA8:  BRA    2BBA
2BAA:  DECFSZ x6E,W
2BAC:  BRA    2BBA
2BAE:  MOVF   x9D,F
2BB0:  BNZ   2BBA
....................          bloq_p3=1; 
2BB2:  MOVLW  01
2BB4:  MOVWF  x9D
....................          tim_p3=0; 
2BB6:  CLRF   xA6
2BB8:  CLRF   xA5
....................       } 
2BBA:  GOTO   340C (RETURN)
.................... }//end sensores 
....................  
.................... void sentidos(){//Define si la persona esta entrando o saliendo 
....................  if( (!sen_ent)&&(!sen_sal) ){ 
*
1D88:  MOVF   5B,F
1D8A:  BNZ   1DD0
1D8C:  MOVF   5C,F
1D8E:  BNZ   1DD0
....................    if ( ( (detec1==1)&&(detec3==1) )|| ( (detec1==1)&&(detec5==1) )|| ( (detec3==1)&&(detec5==1) ) ) { 
1D90:  DECFSZ x69,W
1D92:  BRA    1D9A
1D94:  DECFSZ x6B,W
1D96:  BRA    1D9A
1D98:  BRA    1DAC
1D9A:  DECFSZ x69,W
1D9C:  BRA    1DA4
1D9E:  DECFSZ x6D,W
1DA0:  BRA    1DA4
1DA2:  BRA    1DAC
1DA4:  DECFSZ x6B,W
1DA6:  BRA    1DB0
1DA8:  DECFSZ x6D,W
1DAA:  BRA    1DB0
....................       sen_ent=1; 
1DAC:  MOVLW  01
1DAE:  MOVWF  5B
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Sub"); 
....................    } 
....................    if ( ( (detec2==1)&&(detec4==1) )|| ( (detec2==1)&&(detec6==1) )|| ( (detec4==1)&&(detec6==1) ) ) { 
1DB0:  DECFSZ x6A,W
1DB2:  BRA    1DBA
1DB4:  DECFSZ x6C,W
1DB6:  BRA    1DBA
1DB8:  BRA    1DCC
1DBA:  DECFSZ x6A,W
1DBC:  BRA    1DC4
1DBE:  DECFSZ x6E,W
1DC0:  BRA    1DC4
1DC2:  BRA    1DCC
1DC4:  DECFSZ x6C,W
1DC6:  BRA    1DD0
1DC8:  DECFSZ x6E,W
1DCA:  BRA    1DD0
....................       sen_sal=1; 
1DCC:  MOVLW  01
1DCE:  MOVWF  5C
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Baj"); 
....................    } 
....................  } 
1DD0:  RETURN 0
.................... } 
....................  
.................... void rd_eeprom(){//Revisa si cadena recibida es un instruccion 
....................    a=b=0; 
*
0F0E:  CLRF   49
0F10:  CLRF   48
0F12:  MOVFF  48,44
....................    n=word_size;// 
0F16:  CLRF   4B
0F18:  MOVLW  0A
0F1A:  MOVWF  4A
....................    //i=0; 
....................    //i=2; 
....................    while ((b <=data_set)&&(a==0)){//NUMERO TOTAL DE INSTRUCCIONES 
0F1C:  MOVF   49,F
0F1E:  BNZ   0FB4
0F20:  MOVF   48,W
0F22:  SUBLW  09
0F24:  BNC   0FB4
0F26:  MOVF   44,F
0F28:  BNZ   0FB4
....................        i=0; 
0F2A:  CLRF   41
....................        b++; 
0F2C:  INCF   48,F
0F2E:  BTFSC  FD8.2
0F30:  INCF   49,F
....................        while (i < word_size) {//word_size=10 
0F32:  MOVF   41,W
0F34:  SUBLW  09
0F36:  BNC   0FA8
....................            memory[i] = read_eeprom(n+i); 
0F38:  CLRF   03
0F3A:  MOVF   41,W
0F3C:  ADDLW  BD
0F3E:  MOVWF  FE9
0F40:  MOVLW  01
0F42:  ADDWFC 03,W
0F44:  MOVWF  FEA
0F46:  MOVF   41,W
0F48:  ADDWF  4A,W
0F4A:  MOVLB  1
0F4C:  MOVWF  xCF
0F4E:  MOVLW  00
0F50:  ADDWFC 4B,W
0F52:  MOVWF  xD0
0F54:  MOVFF  FF2,1D1
0F58:  BCF    FF2.7
0F5A:  MOVFF  1CF,FA9
0F5E:  BCF    FA6.6
0F60:  BCF    FA6.7
0F62:  BSF    FA6.0
0F64:  MOVF   FA8,W
0F66:  BTFSC  xD1.7
0F68:  BSF    FF2.7
0F6A:  MOVWF  FEF
....................             
....................            if (memory[i] != XX[i]) 
0F6C:  CLRF   03
0F6E:  MOVF   41,W
0F70:  ADDLW  BD
0F72:  MOVWF  FE9
0F74:  MOVLW  01
0F76:  ADDWFC 03,W
0F78:  MOVWF  FEA
0F7A:  MOVFF  FEF,1CD
0F7E:  CLRF   03
0F80:  MOVF   41,W
0F82:  ADDLW  8E
0F84:  MOVWF  FE9
0F86:  MOVLW  01
0F88:  ADDWFC 03,W
0F8A:  MOVWF  FEA
0F8C:  MOVF   FEF,W
0F8E:  SUBWF  xCD,W
0F90:  BZ    0F98
....................                break; 
0F92:  MOVLB  0
0F94:  BRA    0FA8
0F96:  MOVLB  1
....................            i++; 
0F98:  INCF   41,F
....................            if (i==word_size) a=1; 
0F9A:  MOVF   41,W
0F9C:  SUBLW  0A
0F9E:  BNZ   0FA4
0FA0:  MOVLW  01
0FA2:  MOVWF  44
0FA4:  MOVLB  0
0FA6:  BRA    0F32
....................        } 
....................        //fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
0FA8:  MOVLW  0A
0FAA:  ADDWF  4A,F
0FAC:  MOVLW  00
0FAE:  ADDWFC 4B,F
....................        restart_wdt(); 
0FB0:  CLRWDT
0FB2:  BRA    0F1C
....................    } 
0FB4:  GOTO   3022 (RETURN)
.................... } 
....................  
.................... void rd_eeprom_inicio(){// 
....................    a=b=0; 
....................    n=word_size;// 
....................     
....................    while (b <=data_set){//NUMERO TOTAL DE INSTRUCCIONES 
....................        i=0; 
....................        b++; 
....................        while (i < word_size) {//word_size=10 
....................            memory[i] = read_eeprom(n+i); 
....................            i++; 
....................            if (i==word_size) a=1; 
....................        } 
....................        fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
....................    } 
.................... } 
....................  
.................... void lcd_cuentas(){//Escribe las cuenta en LCD  
....................     lcd_gotoxy(1,1); 
*
0A64:  MOVLW  01
0A66:  MOVLB  1
0A68:  MOVWF  xD8
0A6A:  MOVWF  xD9
0A6C:  MOVLB  0
0A6E:  RCALL  086E
....................     if(master) { 
0A70:  MOVF   45,F
0A72:  BTFSC  FD8.2
0A74:  BRA    0B94
....................        printf(lcd_putc,"1 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0A76:  MOVLW  31
0A78:  MOVLB  1
0A7A:  MOVWF  xD7
0A7C:  MOVLB  0
0A7E:  RCALL  08C0
0A80:  MOVLW  20
0A82:  MOVLB  1
0A84:  MOVWF  xD7
0A86:  MOVLB  0
0A88:  RCALL  08C0
0A8A:  MOVFF  188,1D7
0A8E:  RCALL  08C0
0A90:  MOVFF  189,1D7
0A94:  RCALL  08C0
0A96:  MOVFF  18A,1D7
0A9A:  RCALL  08C0
0A9C:  MOVFF  18B,1D7
0AA0:  RCALL  08C0
0AA2:  MOVFF  18C,1D7
0AA6:  RCALL  08C0
0AA8:  MOVLW  20
0AAA:  MOVLB  1
0AAC:  MOVWF  xD7
0AAE:  MOVLB  0
0AB0:  RCALL  08C0
....................        lcd_gotoxy(14,1); 
0AB2:  MOVLW  0E
0AB4:  MOVLB  1
0AB6:  MOVWF  xD8
0AB8:  MOVLW  01
0ABA:  MOVWF  xD9
0ABC:  MOVLB  0
0ABE:  RCALL  086E
....................        printf(lcd_putc,"S1:%Ld ",entraront); 
0AC0:  MOVLW  BC
0AC2:  MOVWF  FF6
0AC4:  MOVLW  03
0AC6:  MOVWF  FF7
0AC8:  MOVLW  03
0ACA:  MOVLB  1
0ACC:  MOVWF  xCE
0ACE:  MOVLB  0
0AD0:  RCALL  0920
0AD2:  MOVLW  10
0AD4:  MOVWF  FE9
0AD6:  MOVFF  8B,1CF
0ADA:  MOVFF  8A,1CE
0ADE:  RCALL  0948
0AE0:  MOVLW  20
0AE2:  MOVLB  1
0AE4:  MOVWF  xD7
0AE6:  MOVLB  0
0AE8:  RCALL  08C0
....................        lcd_gotoxy(14,2); 
0AEA:  MOVLW  0E
0AEC:  MOVLB  1
0AEE:  MOVWF  xD8
0AF0:  MOVLW  02
0AF2:  MOVWF  xD9
0AF4:  MOVLB  0
0AF6:  RCALL  086E
....................        printf(lcd_putc,"B1:%Ld ",salieront); 
0AF8:  MOVLW  C4
0AFA:  MOVWF  FF6
0AFC:  MOVLW  03
0AFE:  MOVWF  FF7
0B00:  MOVLW  03
0B02:  MOVLB  1
0B04:  MOVWF  xCE
0B06:  MOVLB  0
0B08:  RCALL  0920
0B0A:  MOVLW  10
0B0C:  MOVWF  FE9
0B0E:  MOVFF  8D,1CF
0B12:  MOVFF  8C,1CE
0B16:  RCALL  0948
0B18:  MOVLW  20
0B1A:  MOVLB  1
0B1C:  MOVWF  xD7
0B1E:  MOVLB  0
0B20:  RCALL  08C0
....................        lcd_gotoxy(14,3); 
0B22:  MOVLW  0E
0B24:  MOVLB  1
0B26:  MOVWF  xD8
0B28:  MOVLW  03
0B2A:  MOVWF  xD9
0B2C:  MOVLB  0
0B2E:  RCALL  086E
....................        printf(lcd_putc,"S2:%Ld ",sub_atras); 
0B30:  MOVLW  CC
0B32:  MOVWF  FF6
0B34:  MOVLW  03
0B36:  MOVWF  FF7
0B38:  MOVLW  03
0B3A:  MOVLB  1
0B3C:  MOVWF  xCE
0B3E:  MOVLB  0
0B40:  RCALL  0920
0B42:  MOVLW  10
0B44:  MOVWF  FE9
0B46:  MOVFF  35,1CF
0B4A:  MOVFF  34,1CE
0B4E:  RCALL  0948
0B50:  MOVLW  20
0B52:  MOVLB  1
0B54:  MOVWF  xD7
0B56:  MOVLB  0
0B58:  RCALL  08C0
....................        lcd_gotoxy(14,4); 
0B5A:  MOVLW  0E
0B5C:  MOVLB  1
0B5E:  MOVWF  xD8
0B60:  MOVLW  04
0B62:  MOVWF  xD9
0B64:  MOVLB  0
0B66:  RCALL  086E
....................        printf(lcd_putc,"B2:%Ld ",baj_atras); 
0B68:  MOVLW  D4
0B6A:  MOVWF  FF6
0B6C:  MOVLW  03
0B6E:  MOVWF  FF7
0B70:  MOVLW  03
0B72:  MOVLB  1
0B74:  MOVWF  xCE
0B76:  MOVLB  0
0B78:  RCALL  0920
0B7A:  MOVLW  10
0B7C:  MOVWF  FE9
0B7E:  MOVFF  37,1CF
0B82:  MOVFF  36,1CE
0B86:  RCALL  0948
0B88:  MOVLW  20
0B8A:  MOVLB  1
0B8C:  MOVWF  xD7
0B8E:  MOVLB  0
0B90:  RCALL  08C0
....................     } 
0B92:  BRA    0C70
....................     else{ 
....................        printf(lcd_putc,"2 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0B94:  MOVLW  32
0B96:  MOVLB  1
0B98:  MOVWF  xD7
0B9A:  MOVLB  0
0B9C:  RCALL  08C0
0B9E:  MOVLW  20
0BA0:  MOVLB  1
0BA2:  MOVWF  xD7
0BA4:  MOVLB  0
0BA6:  RCALL  08C0
0BA8:  MOVFF  188,1D7
0BAC:  RCALL  08C0
0BAE:  MOVFF  189,1D7
0BB2:  RCALL  08C0
0BB4:  MOVFF  18A,1D7
0BB8:  RCALL  08C0
0BBA:  MOVFF  18B,1D7
0BBE:  RCALL  08C0
0BC0:  MOVFF  18C,1D7
0BC4:  RCALL  08C0
0BC6:  MOVLW  20
0BC8:  MOVLB  1
0BCA:  MOVWF  xD7
0BCC:  MOVLB  0
0BCE:  RCALL  08C0
....................        lcd_gotoxy(14,1); 
0BD0:  MOVLW  0E
0BD2:  MOVLB  1
0BD4:  MOVWF  xD8
0BD6:  MOVLW  01
0BD8:  MOVWF  xD9
0BDA:  MOVLB  0
0BDC:  RCALL  086E
....................        lcd_putc("S1:    "); 
0BDE:  MOVLW  DC
0BE0:  MOVWF  FF6
0BE2:  MOVLW  03
0BE4:  MOVWF  FF7
0BE6:  RCALL  0A44
....................        lcd_gotoxy(14,2); 
0BE8:  MOVLW  0E
0BEA:  MOVLB  1
0BEC:  MOVWF  xD8
0BEE:  MOVLW  02
0BF0:  MOVWF  xD9
0BF2:  MOVLB  0
0BF4:  RCALL  086E
....................        lcd_putc("B1:    "); 
0BF6:  MOVLW  E4
0BF8:  MOVWF  FF6
0BFA:  MOVLW  03
0BFC:  MOVWF  FF7
0BFE:  RCALL  0A44
....................        lcd_gotoxy(14,3); 
0C00:  MOVLW  0E
0C02:  MOVLB  1
0C04:  MOVWF  xD8
0C06:  MOVLW  03
0C08:  MOVWF  xD9
0C0A:  MOVLB  0
0C0C:  RCALL  086E
....................        printf(lcd_putc,"S2:%Ld ",entraront); 
0C0E:  MOVLW  EC
0C10:  MOVWF  FF6
0C12:  MOVLW  03
0C14:  MOVWF  FF7
0C16:  MOVLW  03
0C18:  MOVLB  1
0C1A:  MOVWF  xCE
0C1C:  MOVLB  0
0C1E:  RCALL  0920
0C20:  MOVLW  10
0C22:  MOVWF  FE9
0C24:  MOVFF  8B,1CF
0C28:  MOVFF  8A,1CE
0C2C:  RCALL  0948
0C2E:  MOVLW  20
0C30:  MOVLB  1
0C32:  MOVWF  xD7
0C34:  MOVLB  0
0C36:  RCALL  08C0
....................        lcd_gotoxy(14,4); 
0C38:  MOVLW  0E
0C3A:  MOVLB  1
0C3C:  MOVWF  xD8
0C3E:  MOVLW  04
0C40:  MOVWF  xD9
0C42:  MOVLB  0
0C44:  RCALL  086E
....................        printf(lcd_putc,"B2:%Ld ",salieront); 
0C46:  MOVLW  F4
0C48:  MOVWF  FF6
0C4A:  MOVLW  03
0C4C:  MOVWF  FF7
0C4E:  MOVLW  03
0C50:  MOVLB  1
0C52:  MOVWF  xCE
0C54:  MOVLB  0
0C56:  RCALL  0920
0C58:  MOVLW  10
0C5A:  MOVWF  FE9
0C5C:  MOVFF  8D,1CF
0C60:  MOVFF  8C,1CE
0C64:  RCALL  0948
0C66:  MOVLW  20
0C68:  MOVLB  1
0C6A:  MOVWF  xD7
0C6C:  MOVLB  0
0C6E:  RCALL  08C0
....................     } 
0C70:  RETURN 0
....................      
.................... } 
....................  
.................... void write_ent(){//Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0CB0:  BCF    FF2.6
0CB2:  BCF    FF2.7
0CB4:  BTFSC  FF2.7
0CB6:  BRA    0CB2
....................    write_ext_eeprom(2,entraront);//parte baja 
0CB8:  MOVLB  1
0CBA:  CLRF   xD2
0CBC:  MOVLW  02
0CBE:  MOVWF  xD1
0CC0:  MOVFF  8A,1D3
0CC4:  MOVLB  0
0CC6:  RCALL  05B4
....................    write_ext_eeprom(1,(entraront>>8) );//parte alta 
0CC8:  MOVFF  8B,1CD
0CCC:  MOVLB  1
0CCE:  CLRF   xCE
0CD0:  CLRF   xD2
0CD2:  MOVLW  01
0CD4:  MOVWF  xD1
0CD6:  MOVFF  8B,1D3
0CDA:  MOVLB  0
0CDC:  RCALL  05B4
....................    enable_interrupts(GLOBAL); 
0CDE:  MOVLW  C0
0CE0:  IORWF  FF2,F
....................    finsuma(); 
0CE2:  RCALL  0C72
0CE4:  RETURN 0
.................... } 
....................  
.................... void write_sal(){//Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0CE6:  BCF    FF2.6
0CE8:  BCF    FF2.7
0CEA:  BTFSC  FF2.7
0CEC:  BRA    0CE8
....................    write_ext_eeprom(4,salieront);//parte baja 
0CEE:  MOVLB  1
0CF0:  CLRF   xD2
0CF2:  MOVLW  04
0CF4:  MOVWF  xD1
0CF6:  MOVFF  8C,1D3
0CFA:  MOVLB  0
0CFC:  RCALL  05B4
....................    write_ext_eeprom(3,(salieront>>8) );//parte alta 
0CFE:  MOVFF  8D,1CD
0D02:  MOVLB  1
0D04:  CLRF   xCE
0D06:  CLRF   xD2
0D08:  MOVLW  03
0D0A:  MOVWF  xD1
0D0C:  MOVFF  8D,1D3
0D10:  MOVLB  0
0D12:  RCALL  05B4
....................    enable_interrupts(GLOBAL); 
0D14:  MOVLW  C0
0D16:  IORWF  FF2,F
....................    finsuma(); 
0D18:  RCALL  0C72
0D1A:  RETURN 0
.................... } 
....................  
.................... void entraron_total(){//Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D88:  BCF    FF2.6
0D8A:  BCF    FF2.7
0D8C:  BTFSC  FF2.7
0D8E:  BRA    0D8A
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0D90:  MOVLB  1
0D92:  CLRF   xCD
0D94:  CLRF   xCE
0D96:  CLRF   xD0
0D98:  CLRF   xCF
....................     
....................    reg_h=read_ext_eeprom(1); 
0D9A:  CLRF   xD2
0D9C:  MOVLW  01
0D9E:  MOVWF  xD1
0DA0:  MOVLB  0
0DA2:  RCALL  0774
0DA4:  MOVFF  01,1CD
....................    reg_l=read_ext_eeprom(2); 
0DA8:  MOVLB  1
0DAA:  CLRF   xD2
0DAC:  MOVLW  02
0DAE:  MOVWF  xD1
0DB0:  MOVLB  0
0DB2:  RCALL  0774
0DB4:  MOVFF  01,1CE
....................    total=reg_h; 
0DB8:  MOVLB  1
0DBA:  CLRF   xD0
0DBC:  MOVFF  1CD,1CF
....................    total=(total<<8)|reg_l; 
0DC0:  MOVFF  1CF,1D2
0DC4:  CLRF   xD1
0DC6:  MOVF   xD1,W
0DC8:  IORWF  xCE,W
0DCA:  MOVWF  xCF
0DCC:  MOVFF  1D2,1D0
....................    entraront=total; 
0DD0:  MOVFF  1D0,8B
0DD4:  MOVFF  1CF,8A
....................    enable_interrupts(GLOBAL); 
0DD8:  MOVLW  C0
0DDA:  IORWF  FF2,F
0DDC:  MOVLB  0
0DDE:  GOTO   2E14 (RETURN)
.................... } 
....................  
.................... void salieron_total(){//Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0DE2:  BCF    FF2.6
0DE4:  BCF    FF2.7
0DE6:  BTFSC  FF2.7
0DE8:  BRA    0DE4
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0DEA:  MOVLB  1
0DEC:  CLRF   xCD
0DEE:  CLRF   xCE
0DF0:  CLRF   xD0
0DF2:  CLRF   xCF
....................     
....................    reg_h=read_ext_eeprom(3); 
0DF4:  CLRF   xD2
0DF6:  MOVLW  03
0DF8:  MOVWF  xD1
0DFA:  MOVLB  0
0DFC:  RCALL  0774
0DFE:  MOVFF  01,1CD
....................    reg_l=read_ext_eeprom(4); 
0E02:  MOVLB  1
0E04:  CLRF   xD2
0E06:  MOVLW  04
0E08:  MOVWF  xD1
0E0A:  MOVLB  0
0E0C:  RCALL  0774
0E0E:  MOVFF  01,1CE
....................    total=reg_h; 
0E12:  MOVLB  1
0E14:  CLRF   xD0
0E16:  MOVFF  1CD,1CF
....................    total=(total<<8)|reg_l; 
0E1A:  MOVFF  1CF,1D2
0E1E:  CLRF   xD1
0E20:  MOVF   xD1,W
0E22:  IORWF  xCE,W
0E24:  MOVWF  xCF
0E26:  MOVFF  1D2,1D0
....................    salieront=total; 
0E2A:  MOVFF  1D0,8D
0E2E:  MOVFF  1CF,8C
....................    enable_interrupts(GLOBAL); 
0E32:  MOVLW  C0
0E34:  IORWF  FF2,F
0E36:  MOVLB  0
0E38:  GOTO   2E18 (RETURN)
.................... } 
....................  
.................... void graba_conta2(){//Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
06BA:  BCF    FF2.6
06BC:  BCF    FF2.7
06BE:  BTFSC  FF2.7
06C0:  BRA    06BC
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
06C2:  MOVLB  1
06C4:  CLRF   xCD
06C6:  CLRF   xCE
06C8:  CLRF   xD0
06CA:  CLRF   xCF
....................    totalc=0; 
06CC:  CLRF   xD0
06CE:  CLRF   xCF
....................    reg_lc=0; 
06D0:  CLRF   xCE
....................    reg_hc=0; 
06D2:  CLRF   xCD
....................     
....................    totalc=salian; 
06D4:  MOVFF  3D,1D0
06D8:  MOVFF  3C,1CF
....................    reg_lc=totalc; 
06DC:  MOVFF  1CF,1CE
....................    reg_hc=totalc>>8; 
06E0:  MOVFF  1D0,1CD
....................    write_ext_eeprom(20,reg_hc); 
06E4:  CLRF   xD2
06E6:  MOVLW  14
06E8:  MOVWF  xD1
06EA:  MOVFF  1CD,1D3
06EE:  MOVLB  0
06F0:  RCALL  05B4
....................    write_ext_eeprom(21,reg_lc); 
06F2:  MOVLB  1
06F4:  CLRF   xD2
06F6:  MOVLW  15
06F8:  MOVWF  xD1
06FA:  MOVFF  1CE,1D3
06FE:  MOVLB  0
0700:  RCALL  05B4
....................    enable_interrupts(GLOBAL); 
0702:  MOVLW  C0
0704:  IORWF  FF2,F
0706:  RETURN 0
.................... } 
....................  
.................... void leer_conta2(){//Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
081C:  BCF    FF2.6
081E:  BCF    FF2.7
0820:  BTFSC  FF2.7
0822:  BRA    081E
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
0824:  MOVLB  1
0826:  CLRF   xCD
0828:  CLRF   xCE
082A:  CLRF   xD0
082C:  CLRF   xCF
....................     
....................    reg_hc=read_ext_eeprom(20); 
082E:  CLRF   xD2
0830:  MOVLW  14
0832:  MOVWF  xD1
0834:  MOVLB  0
0836:  RCALL  0774
0838:  MOVFF  01,1CD
....................    reg_lc=read_ext_eeprom(21); 
083C:  MOVLB  1
083E:  CLRF   xD2
0840:  MOVLW  15
0842:  MOVWF  xD1
0844:  MOVLB  0
0846:  RCALL  0774
0848:  MOVFF  01,1CE
....................    totalc=reg_hc; 
084C:  MOVLB  1
084E:  CLRF   xD0
0850:  MOVFF  1CD,1CF
....................    totalc=totalc<<8; 
0854:  MOVFF  1CF,1D0
0858:  CLRF   xCF
....................    totalc=totalc|reg_lc; 
085A:  MOVF   xCE,W
085C:  IORWF  xCF,F
....................    salian=totalc; 
085E:  MOVFF  1D0,3D
0862:  MOVFF  1CF,3C
....................    enable_interrupts(GLOBAL); 
0866:  MOVLW  C0
0868:  IORWF  FF2,F
086A:  MOVLB  0
086C:  RETURN 0
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) { 
*
0E5E:  MOVF   FD0,W
0E60:  ANDLW  0F
0E62:  BTFSS  FD0.4
0E64:  MOVLW  00
0E66:  BSF    FD0.0
0E68:  BSF    FD0.1
0E6A:  BSF    FD0.4
0E6C:  BSF    FD8.3
0E6E:  BSF    FD8.4
0E70:  XORLW  07
0E72:  BZ    0E82
0E74:  XORLW  08
0E76:  BZ    0E84
0E78:  XORLW  01
0E7A:  BZ    0E90
0E7C:  XORLW  02
0E7E:  BZ    0E92
0E80:  BRA    0E92
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          break;} 
0E82:  BRA    0E92
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          fprintf(monitor,"SERIALTEST\r\n"); 
0E84:  MOVLW  FC
0E86:  MOVWF  FF6
0E88:  MOVLW  03
0E8A:  MOVWF  FF7
0E8C:  RCALL  0E3C
....................          break;} 
0E8E:  BRA    0E92
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          break; 
0E90:  BRA    0E92
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          break; 
....................       }//END MODO 
....................    } 
0E92:  GOTO   2EF6 (RETURN)
.................... } 
....................  
.................... //// evalua el comando obetenido del serial nato /////////////////// 
.................... int evaluar_string(char *command[]){ 
*
1032:  MOVLB  1
1034:  CLRF   xCF
....................    int conteo_command=0; 
....................    int iresult; 
.................... //// recorremos los 11 comandos definidos en textosearxch[] //////// 
....................    while(conteo_command<=10){ 
1036:  MOVF   xCF,W
1038:  SUBLW  0A
103A:  BNC   1082
....................    iresult=strcoll(textosearch[conteo_command],command); 
103C:  CLRF   03
103E:  MOVFF  1CF,02
1042:  BCF    FD8.0
1044:  RLCF   02,F
1046:  RLCF   03,F
1048:  MOVF   02,W
104A:  ADDLW  EE
104C:  MOVWF  FE9
104E:  MOVLW  00
1050:  ADDWFC 03,W
1052:  MOVWF  FEA
1054:  MOVFF  FEC,1D2
1058:  MOVF   FED,F
105A:  MOVFF  FEF,1D1
105E:  MOVFF  1D2,1D4
1062:  MOVFF  1D1,1D3
1066:  MOVFF  1CE,1D6
106A:  MOVFF  1CD,1D5
106E:  MOVLB  0
1070:  BRA    0FB8
1072:  MOVFF  01,1D0
.................... //// si se encontr el comando en la lista entonces deja de buscar // 
....................    if(iresult==0){ 
1076:  MOVLB  1
1078:  MOVF   xD0,F
107A:  BNZ   107E
....................    break; 
107C:  BRA    1082
....................    } 
....................    conteo_command++; 
107E:  INCF   xCF,F
1080:  BRA    1036
....................    } 
....................  
.................... //// si parte del comando es o empieza con "ASAJEROS" entra caso 5 // 
....................       if(XX[1]=='A' && XX[2]=='S' && XX[3]=='A' && XX[4]=='J' && XX[5]=='E' && XX[6]=='R' && XX[7]=='O' && XX[8]=='S') 
1082:  MOVF   x8F,W
1084:  SUBLW  41
1086:  BNZ   10B6
1088:  MOVF   x90,W
108A:  SUBLW  53
108C:  BNZ   10B6
108E:  MOVF   x91,W
1090:  SUBLW  41
1092:  BNZ   10B6
1094:  MOVF   x92,W
1096:  SUBLW  4A
1098:  BNZ   10B6
109A:  MOVF   x93,W
109C:  SUBLW  45
109E:  BNZ   10B6
10A0:  MOVF   x94,W
10A2:  SUBLW  52
10A4:  BNZ   10B6
10A6:  MOVF   x95,W
10A8:  SUBLW  4F
10AA:  BNZ   10B6
10AC:  MOVF   x96,W
10AE:  SUBLW  53
10B0:  BNZ   10B6
....................       { 
....................          conteo_command = 5; 
10B2:  MOVLW  05
10B4:  MOVWF  xCF
....................       } 
.................... /// retorna valor de comando para validar /////////////////////////// 
....................    return conteo_command; 
10B6:  MOVFF  1CF,01
10BA:  MOVLB  0
10BC:  GOTO   3032 (RETURN)
....................  
....................    } 
....................     

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
