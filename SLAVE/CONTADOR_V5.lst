CCS PCH C Compiler, Version 5.025, 24934               05-may.-22 09:31

               Filename:   D:\PROYECTOS\TRANSPORTE\ENCAPSULADO NUEVO\Contadores_V5.02\SLAVE\CONTADOR_V5.lst

               ROM used:   13148 bytes (40%)
                           Largest free fragment is 19616
               RAM used:   392 (26%) at main() level
                           415 (27%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   2B38
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   01E0
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00CE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... //2021/05/13 *V5.01 Se recalcula frecuencia de IR 
.................... //2020/03/31 *V4.A1 Se agrega etiqueta para identificar por LCD si hay comunicacion entre los postes 
.................... //2020/02/28 *V04.A Se modifica codigo para evitar que postes cuenten solos 
.................... //2019/12/09 Se modifica la forma de contar con sensores bloqueados 
.................... //2019/11/19 Se modifica codigo para detectar una recepcion serial de dato poste posterior erronea, asi como identificar error de conexion tambien, 
.................... //           Se quita funcion de boton silenciador que nunca se uso 
.................... //2019/11/14 Se modifica la escucha de la cuenta del poste secundario, se cambia limite a 20 para dato posterior recibido. 
.................... //D01.2 2019/03/28 Se agrega cambios para confirmar reset a nuevo GSM y enter al final de envio de cuenta 
.................... //                 Se discriminan los primneros 2 caracteres de validacion serial 
.................... // ultima modificacion; 
.................... /* 
.................... VER.  FECHA 
.................... D02.6 2019/12/09 Cambia la forma de contar 
.................... - Poste de datos esta identificado como 1, el esclavo como 2 
.................... */ 
....................  
.................... #include <18F4580.h> 
.................... //////////// Standard Header file for the PIC18F4580 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4580 
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 28,0C
00CC:  DATA 01,06
*
023A:  DATA 42,4F
023C:  DATA 52,52
023E:  DATA 41,52
0240:  DATA 5F,41
0242:  DATA 4C,4C
0244:  DATA 0D,00
0246:  DATA 0C,42
0248:  DATA 4F,52
024A:  DATA 52,41
024C:  DATA 52,5F
024E:  DATA 41,4C
0250:  DATA 4C,00
0252:  DATA 42,4F
0254:  DATA 52,52
0256:  DATA 41,52
0258:  DATA 5F,41
025A:  DATA 4C,4C
025C:  DATA 0D,00
025E:  DATA 52,45
0260:  DATA 53,45
0262:  DATA 54,5F
0264:  DATA 4F,4B
0266:  DATA 0D,0A
0268:  DATA 00,00
026A:  DATA 42,4F
026C:  DATA 52,52
026E:  DATA 41,52
0270:  DATA 5F,41
0272:  DATA 4C,4C
0274:  DATA 0D,00
0276:  DATA 43,32
0278:  DATA 4F,4B
027A:  DATA 00,00
027C:  DATA 43,31
027E:  DATA 4F,4B
0280:  DATA 00,00
0282:  DATA 53,45
0284:  DATA 52,49
0286:  DATA 41,4C
0288:  DATA 5F,54
028A:  DATA 4F,4B
028C:  DATA 0D,00
028E:  DATA 43,32
0290:  DATA 4F,4B
0292:  DATA 00,00
0294:  DATA 53,75
0296:  DATA 62,32
0298:  DATA 00,00
029A:  DATA 20,20
029C:  DATA 20,20
029E:  DATA 00,00
02A0:  DATA 20,20
02A2:  DATA 20,20
02A4:  DATA 00,00
02A6:  DATA 20,20
02A8:  DATA 20,20
02AA:  DATA 00,00
02AC:  DATA 42,4C
02AE:  DATA 00,00
02B0:  DATA 42,4C
02B2:  DATA 00,00
02B4:  DATA 42,4C
02B6:  DATA 00,00
02B8:  DATA 20,20
02BA:  DATA 00,00
02BC:  DATA 53,4F
02BE:  DATA 4C,49
02C0:  DATA 43,49
02C2:  DATA 54,41
02C4:  DATA 44,4F
02C6:  DATA 0D,00
02C8:  DATA 50,41
02CA:  DATA 53,41
02CC:  DATA 4A,45
02CE:  DATA 52,4F
02D0:  DATA 53,3A
02D2:  DATA 25,30
02D4:  DATA 34,4C
02D6:  DATA 64,2F
02D8:  DATA 25,30
02DA:  DATA 34,4C
02DC:  DATA 64,2F
02DE:  DATA 25,30
02E0:  DATA 33,4C
02E2:  DATA 64,2F
02E4:  DATA 25,30
02E6:  DATA 34,4C
02E8:  DATA 75,2F
02EA:  DATA 0D,00
02EC:  DATA 41,43
02EE:  DATA 43,2B
02F0:  DATA 30,31
02F2:  DATA 3A,25
02F4:  DATA 30,34
02F6:  DATA 4C,75
02F8:  DATA 2C,25
02FA:  DATA 30,34
02FC:  DATA 4C,75
02FE:  DATA 2C,25
0300:  DATA 30,34
0302:  DATA 4C,75
0304:  DATA 2C,25
0306:  DATA 30,33
0308:  DATA 4C,75
030A:  DATA 2C,25
030C:  DATA 30,33
030E:  DATA 4C,75
0310:  DATA 2C,25
0312:  DATA 30,32
0314:  DATA 75,2C
0316:  DATA 0D,0A
0318:  DATA 00,00
031A:  DATA 41,43
031C:  DATA 43,2B
031E:  DATA 30,31
0320:  DATA 3A,25
0322:  DATA 30,34
0324:  DATA 4C,75
0326:  DATA 2C,25
0328:  DATA 30,34
032A:  DATA 4C,75
032C:  DATA 2C,44
032E:  DATA 45,53
0330:  DATA 43,2C
0332:  DATA 25,30
0334:  DATA 33,4C
0336:  DATA 75,2C
0338:  DATA 30,30
033A:  DATA 30,2C
033C:  DATA 25,30
033E:  DATA 32,75
0340:  DATA 2C,0D
0342:  DATA 0A,00
0344:  DATA 44,45
0346:  DATA 53,43
0348:  DATA 00,00
034A:  DATA 0C,00
034C:  DATA 20,00
034E:  DATA 20,00
0350:  DATA 20,00
0352:  DATA 20,00
0354:  DATA 20,00
0356:  DATA 20,00
0358:  DATA 20,00
035A:  DATA 20,00
035C:  DATA 20,00
035E:  DATA 20,00
0360:  DATA 20,00
0362:  DATA 20,00
0364:  DATA 6D,65
0366:  DATA 6D,6F
0368:  DATA 72,79
036A:  DATA 3A,25
036C:  DATA 73,0D
036E:  DATA 00,00
0370:  DATA 53,31
0372:  DATA 3A,25
0374:  DATA 4C,64
0376:  DATA 20,00
0378:  DATA 42,31
037A:  DATA 3A,25
037C:  DATA 4C,64
037E:  DATA 20,00
0380:  DATA 53,32
0382:  DATA 3A,25
0384:  DATA 4C,64
0386:  DATA 20,00
0388:  DATA 42,32
038A:  DATA 3A,25
038C:  DATA 4C,64
038E:  DATA 20,00
0390:  DATA 53,31
0392:  DATA 3A,20
0394:  DATA 20,20
0396:  DATA 20,00
0398:  DATA 42,31
039A:  DATA 3A,20
039C:  DATA 20,20
039E:  DATA 20,00
03A0:  DATA 53,32
03A2:  DATA 3A,25
03A4:  DATA 4C,64
03A6:  DATA 20,00
03A8:  DATA 42,32
03AA:  DATA 3A,25
03AC:  DATA 4C,64
03AE:  DATA 20,00
03B0:  DATA 53,45
03B2:  DATA 52,49
03B4:  DATA 41,4C
03B6:  DATA 54,45
03B8:  DATA 53,54
03BA:  DATA 0D,0A
03BC:  DATA 00,00
*
08D4:  TBLRD*+
08D6:  MOVFF  FF6,187
08DA:  MOVFF  FF7,188
08DE:  MOVFF  FF5,18F
08E2:  RCALL  0874
08E4:  MOVFF  187,FF6
08E8:  MOVFF  188,FF7
08EC:  MOVLB  1
08EE:  DECFSZ x86,F
08F0:  BRA    08F4
08F2:  BRA    08F8
08F4:  MOVLB  0
08F6:  BRA    08D4
08F8:  MOVLB  0
08FA:  RETURN 0
08FC:  MOVFF  FEA,18E
0900:  MOVFF  FE9,18D
0904:  MOVLB  1
0906:  BTFSS  x87.7
0908:  BRA    091A
090A:  BSF    x8D.7
090C:  BTFSS  x8D.4
090E:  INCF   x8D,F
0910:  COMF   x86,F
0912:  COMF   x87,F
0914:  INCF   x86,F
0916:  BTFSC  FD8.2
0918:  INCF   x87,F
091A:  SWAPF  x87,W
091C:  IORLW  F0
091E:  MOVWF  x89
0920:  ADDWF  x89,F
0922:  ADDLW  E2
0924:  MOVWF  x8A
0926:  ADDLW  32
0928:  MOVWF  x8C
092A:  MOVF   x87,W
092C:  ANDLW  0F
092E:  ADDWF  x8A,F
0930:  ADDWF  x8A,F
0932:  ADDWF  x8C,F
0934:  ADDLW  E9
0936:  MOVWF  x8B
0938:  ADDWF  x8B,F
093A:  ADDWF  x8B,F
093C:  SWAPF  x86,W
093E:  ANDLW  0F
0940:  ADDWF  x8B,F
0942:  ADDWF  x8C,F
0944:  RLCF   x8B,F
0946:  RLCF   x8C,F
0948:  COMF   x8C,F
094A:  RLCF   x8C,F
094C:  MOVF   x86,W
094E:  ANDLW  0F
0950:  ADDWF  x8C,F
0952:  RLCF   x89,F
0954:  MOVLW  07
0956:  MOVWF  x88
0958:  MOVLW  0A
095A:  DECF   x8B,F
095C:  ADDWF  x8C,F
095E:  BNC   095A
0960:  DECF   x8A,F
0962:  ADDWF  x8B,F
0964:  BNC   0960
0966:  DECF   x89,F
0968:  ADDWF  x8A,F
096A:  BNC   0966
096C:  DECF   x88,F
096E:  ADDWF  x89,F
0970:  BNC   096C
0972:  MOVLW  01
0974:  MOVWF  FEA
0976:  MOVLW  88
0978:  MOVWF  FE9
097A:  MOVLW  07
097C:  ANDWF  x8D,W
097E:  BCF    x8D.6
0980:  MOVF   FED,F
0982:  ANDWF  x8D,W
0984:  BNZ   0994
0986:  BTFSC  x8D.4
0988:  MOVF   FEE,F
098A:  BTFSC  x8D.4
098C:  BRA    0994
098E:  MOVLW  20
0990:  MOVWF  00
0992:  BRA    09D4
0994:  ADDWF  FE9,F
0996:  MOVLW  00
0998:  ADDWFC FEA,F
099A:  MOVF   FE9,W
099C:  SUBLW  8C
099E:  BNZ   09A6
09A0:  DECFSZ FEA,W
09A2:  BRA    09A6
09A4:  BSF    x8D.6
09A6:  MOVF   FEF,W
09A8:  MOVWF  00
09AA:  BNZ   09BC
09AC:  BTFSC  x8D.6
09AE:  BRA    09BC
09B0:  BTFSC  x8D.4
09B2:  BRA    09EE
09B4:  BTFSC  x8D.3
09B6:  BRA    09BC
09B8:  MOVLW  20
09BA:  BRA    09D2
09BC:  BTFSS  x8D.7
09BE:  BRA    09CC
09C0:  MOVLW  2D
09C2:  MOVWF  00
09C4:  MOVF   FED,W
09C6:  BCF    x8D.6
09C8:  BCF    x8D.7
09CA:  BRA    09D4
09CC:  BSF    x8D.3
09CE:  BCF    x8D.4
09D0:  MOVLW  30
09D2:  ADDWF  00,F
09D4:  MOVFF  FEA,187
09D8:  MOVFF  FE9,186
09DC:  MOVFF  00,18F
09E0:  MOVLB  0
09E2:  RCALL  0874
09E4:  MOVFF  187,FEA
09E8:  MOVFF  186,FE9
09EC:  MOVLB  1
09EE:  MOVF   FEE,W
09F0:  BTFSS  x8D.6
09F2:  BRA    099A
09F4:  MOVLB  0
09F6:  RETURN 0
09F8:  TBLRD*+
09FA:  MOVF   FF5,F
09FC:  BZ    0A16
09FE:  MOVFF  FF6,186
0A02:  MOVFF  FF7,187
0A06:  MOVFF  FF5,18F
0A0A:  RCALL  0874
0A0C:  MOVFF  186,FF6
0A10:  MOVFF  187,FF7
0A14:  BRA    09F8
0A16:  RETURN 0
*
0DF0:  TBLRD*+
0DF2:  MOVF   FF5,F
0DF4:  BZ    0E10
0DF6:  MOVFF  FF6,186
0DFA:  MOVFF  FF7,187
0DFE:  MOVF   FF5,W
0E00:  BTFSS  F9E.4
0E02:  BRA    0E00
0E04:  MOVWF  FAD
0E06:  MOVFF  186,FF6
0E0A:  MOVFF  187,FF7
0E0E:  BRA    0DF0
0E10:  RETURN 0
*
103E:  MOVLB  1
1040:  MOVF   x8D,W
1042:  CLRF   01
1044:  SUBWF  x8C,W
1046:  BC    104E
1048:  MOVFF  18C,00
104C:  BRA    1066
104E:  CLRF   00
1050:  MOVLW  08
1052:  MOVWF  x8E
1054:  RLCF   x8C,F
1056:  RLCF   00,F
1058:  MOVF   x8D,W
105A:  SUBWF  00,W
105C:  BTFSC  FD8.0
105E:  MOVWF  00
1060:  RLCF   01,F
1062:  DECFSZ x8E,F
1064:  BRA    1054
1066:  MOVLB  0
1068:  RETURN 0
106A:  MOVLW  20
106C:  MOVLB  1
106E:  BTFSS  x87.4
1070:  MOVLW  30
1072:  MOVWF  x88
1074:  MOVFF  186,00
1078:  BTFSS  x86.7
107A:  BRA    108C
107C:  COMF   00,F
107E:  INCF   00,F
1080:  MOVFF  00,186
1084:  MOVLW  2D
1086:  MOVWF  x88
1088:  BSF    x87.7
108A:  BSF    x87.0
108C:  MOVF   01,W
108E:  MOVFF  186,18C
1092:  MOVLW  64
1094:  MOVWF  x8D
1096:  MOVLB  0
1098:  RCALL  103E
109A:  MOVFF  00,186
109E:  MOVLW  30
10A0:  ADDWF  01,W
10A2:  MOVLB  1
10A4:  MOVWF  x89
10A6:  MOVFF  186,18C
10AA:  MOVLW  0A
10AC:  MOVWF  x8D
10AE:  MOVLB  0
10B0:  RCALL  103E
10B2:  MOVLW  30
10B4:  ADDWF  00,W
10B6:  MOVLB  1
10B8:  MOVWF  x8B
10BA:  MOVLW  30
10BC:  ADDWF  01,W
10BE:  MOVWF  x8A
10C0:  MOVFF  188,00
10C4:  MOVLW  30
10C6:  SUBWF  x89,W
10C8:  BZ    10D2
10CA:  BSF    x87.1
10CC:  BTFSC  x87.7
10CE:  BSF    x87.2
10D0:  BRA    10F6
10D2:  MOVFF  188,189
10D6:  MOVLW  20
10D8:  MOVWF  x88
10DA:  MOVLW  30
10DC:  SUBWF  x8A,W
10DE:  BZ    10E8
10E0:  BSF    x87.0
10E2:  BTFSC  x87.7
10E4:  BSF    x87.1
10E6:  BRA    10F6
10E8:  BTFSS  FD8.2
10EA:  BSF    x87.0
10EC:  BNZ   10F6
10EE:  MOVFF  189,18A
10F2:  MOVLW  20
10F4:  MOVWF  x89
10F6:  BTFSC  x87.2
10F8:  BRA    1104
10FA:  BTFSC  x87.1
10FC:  BRA    110E
10FE:  BTFSC  x87.0
1100:  BRA    1118
1102:  BRA    1122
1104:  MOVFF  188,18F
1108:  MOVLB  0
110A:  CALL   0874
110E:  MOVFF  189,18F
1112:  MOVLB  0
1114:  CALL   0874
1118:  MOVFF  18A,18F
111C:  MOVLB  0
111E:  CALL   0874
1122:  MOVFF  18B,18F
1126:  MOVLB  0
1128:  CALL   0874
112C:  RETURN 0
*
1194:  TBLRD*+
1196:  MOVF   FF5,F
1198:  BZ    11B2
119A:  MOVFF  FF6,186
119E:  MOVFF  FF7,187
11A2:  MOVFF  FF5,18F
11A6:  RCALL  1146
11A8:  MOVFF  186,FF6
11AC:  MOVFF  187,FF7
11B0:  BRA    1194
11B2:  GOTO   2FF0 (RETURN)
11B6:  TBLRD*+
11B8:  MOVFF  FF6,189
11BC:  MOVFF  FF7,18A
11C0:  MOVF   FF5,W
11C2:  BTFSS  F9E.4
11C4:  BRA    11C2
11C6:  MOVWF  FAD
11C8:  MOVFF  189,FF6
11CC:  MOVFF  18A,FF7
11D0:  MOVLB  1
11D2:  DECFSZ x88,F
11D4:  BRA    11D8
11D6:  BRA    11DC
11D8:  MOVLB  0
11DA:  BRA    11B6
11DC:  MOVLB  0
11DE:  GOTO   13DC (RETURN)
11E2:  MOVFF  FEA,190
11E6:  MOVFF  FE9,18F
11EA:  MOVLB  1
11EC:  BTFSS  x89.7
11EE:  BRA    1200
11F0:  BSF    x8F.7
11F2:  BTFSS  x8F.4
11F4:  INCF   x8F,F
11F6:  COMF   x88,F
11F8:  COMF   x89,F
11FA:  INCF   x88,F
11FC:  BTFSC  FD8.2
11FE:  INCF   x89,F
1200:  SWAPF  x89,W
1202:  IORLW  F0
1204:  MOVWF  x8B
1206:  ADDWF  x8B,F
1208:  ADDLW  E2
120A:  MOVWF  x8C
120C:  ADDLW  32
120E:  MOVWF  x8E
1210:  MOVF   x89,W
1212:  ANDLW  0F
1214:  ADDWF  x8C,F
1216:  ADDWF  x8C,F
1218:  ADDWF  x8E,F
121A:  ADDLW  E9
121C:  MOVWF  x8D
121E:  ADDWF  x8D,F
1220:  ADDWF  x8D,F
1222:  SWAPF  x88,W
1224:  ANDLW  0F
1226:  ADDWF  x8D,F
1228:  ADDWF  x8E,F
122A:  RLCF   x8D,F
122C:  RLCF   x8E,F
122E:  COMF   x8E,F
1230:  RLCF   x8E,F
1232:  MOVF   x88,W
1234:  ANDLW  0F
1236:  ADDWF  x8E,F
1238:  RLCF   x8B,F
123A:  MOVLW  07
123C:  MOVWF  x8A
123E:  MOVLW  0A
1240:  DECF   x8D,F
1242:  ADDWF  x8E,F
1244:  BNC   1240
1246:  DECF   x8C,F
1248:  ADDWF  x8D,F
124A:  BNC   1246
124C:  DECF   x8B,F
124E:  ADDWF  x8C,F
1250:  BNC   124C
1252:  DECF   x8A,F
1254:  ADDWF  x8B,F
1256:  BNC   1252
1258:  MOVLW  01
125A:  MOVWF  FEA
125C:  MOVLW  8A
125E:  MOVWF  FE9
1260:  MOVLW  07
1262:  ANDWF  x8F,W
1264:  BCF    x8F.6
1266:  MOVF   FED,F
1268:  ANDWF  x8F,W
126A:  BNZ   127A
126C:  BTFSC  x8F.4
126E:  MOVF   FEE,F
1270:  BTFSC  x8F.4
1272:  BRA    127A
1274:  MOVLW  20
1276:  MOVWF  00
1278:  BRA    12BA
127A:  ADDWF  FE9,F
127C:  MOVLW  00
127E:  ADDWFC FEA,F
1280:  MOVF   FE9,W
1282:  SUBLW  8E
1284:  BNZ   128C
1286:  DECFSZ FEA,W
1288:  BRA    128C
128A:  BSF    x8F.6
128C:  MOVF   FEF,W
128E:  MOVWF  00
1290:  BNZ   12A2
1292:  BTFSC  x8F.6
1294:  BRA    12A2
1296:  BTFSC  x8F.4
1298:  BRA    12C2
129A:  BTFSC  x8F.3
129C:  BRA    12A2
129E:  MOVLW  20
12A0:  BRA    12B8
12A2:  BTFSS  x8F.7
12A4:  BRA    12B2
12A6:  MOVLW  2D
12A8:  MOVWF  00
12AA:  MOVF   FED,W
12AC:  BCF    x8F.6
12AE:  BCF    x8F.7
12B0:  BRA    12BA
12B2:  BSF    x8F.3
12B4:  BCF    x8F.4
12B6:  MOVLW  30
12B8:  ADDWF  00,F
12BA:  MOVF   00,W
12BC:  BTFSS  F9E.4
12BE:  BRA    12BC
12C0:  MOVWF  FAD
12C2:  MOVF   FEE,W
12C4:  BTFSS  x8F.6
12C6:  BRA    1280
12C8:  MOVLB  0
12CA:  RETURN 0
12CC:  MOVFF  FEA,190
12D0:  MOVFF  FE9,18F
12D4:  MOVLB  1
12D6:  SWAPF  x89,W
12D8:  IORLW  F0
12DA:  MOVWF  x8B
12DC:  ADDWF  x8B,F
12DE:  ADDLW  E2
12E0:  MOVWF  x8C
12E2:  ADDLW  32
12E4:  MOVWF  x8E
12E6:  MOVF   x89,W
12E8:  ANDLW  0F
12EA:  ADDWF  x8C,F
12EC:  ADDWF  x8C,F
12EE:  ADDWF  x8E,F
12F0:  ADDLW  E9
12F2:  MOVWF  x8D
12F4:  ADDWF  x8D,F
12F6:  ADDWF  x8D,F
12F8:  SWAPF  x88,W
12FA:  ANDLW  0F
12FC:  ADDWF  x8D,F
12FE:  ADDWF  x8E,F
1300:  RLCF   x8D,F
1302:  RLCF   x8E,F
1304:  COMF   x8E,F
1306:  RLCF   x8E,F
1308:  MOVF   x88,W
130A:  ANDLW  0F
130C:  ADDWF  x8E,F
130E:  RLCF   x8B,F
1310:  MOVLW  07
1312:  MOVWF  x8A
1314:  MOVLW  0A
1316:  DECF   x8D,F
1318:  ADDWF  x8E,F
131A:  BNC   1316
131C:  DECF   x8C,F
131E:  ADDWF  x8D,F
1320:  BNC   131C
1322:  DECF   x8B,F
1324:  ADDWF  x8C,F
1326:  BNC   1322
1328:  DECF   x8A,F
132A:  ADDWF  x8B,F
132C:  BNC   1328
132E:  MOVLW  01
1330:  MOVWF  FEA
1332:  MOVLW  8A
1334:  MOVWF  FE9
1336:  MOVLW  07
1338:  ANDWF  x8F,W
133A:  BCF    x8F.6
133C:  ADDWF  FE9,F
133E:  MOVLW  00
1340:  ADDWFC FEA,F
1342:  MOVF   FE9,W
1344:  SUBLW  8E
1346:  BNZ   134E
1348:  DECFSZ FEA,W
134A:  BRA    134E
134C:  BSF    x8F.6
134E:  MOVF   FEF,W
1350:  MOVWF  00
1352:  BNZ   1364
1354:  BTFSC  x8F.6
1356:  BRA    1364
1358:  BTFSC  x8F.4
135A:  BRA    1374
135C:  BTFSC  x8F.3
135E:  BRA    1364
1360:  MOVLW  20
1362:  BRA    136A
1364:  BSF    x8F.3
1366:  BCF    x8F.4
1368:  MOVLW  30
136A:  ADDWF  00,F
136C:  MOVF   00,W
136E:  BTFSS  F9E.4
1370:  BRA    136E
1372:  MOVWF  FAD
1374:  MOVF   FEE,W
1376:  BTFSS  x8F.6
1378:  BRA    1342
137A:  MOVLB  0
137C:  GOTO   142C (RETURN)
*
143E:  TSTFSZ 01
1440:  BRA    1448
1442:  TSTFSZ 02
1444:  BRA    144A
1446:  BRA    1456
1448:  INCF   02,F
144A:  MOVFF  00,FEE
144E:  DECFSZ 01,F
1450:  BRA    144A
1452:  DECFSZ 02,F
1454:  BRA    144A
1456:  RETURN 0
*
15D8:  TBLRD*+
15DA:  MOVFF  FF6,187
15DE:  MOVFF  FF7,188
15E2:  MOVFF  FF5,18F
15E6:  RCALL  1146
15E8:  MOVFF  187,FF6
15EC:  MOVFF  188,FF7
15F0:  MOVLB  1
15F2:  DECFSZ x86,F
15F4:  BRA    15F8
15F6:  BRA    15FC
15F8:  MOVLB  0
15FA:  BRA    15D8
15FC:  MOVLB  0
15FE:  RETURN 0
1600:  MOVFF  FEA,18E
1604:  MOVFF  FE9,18D
1608:  MOVLB  1
160A:  SWAPF  x87,W
160C:  IORLW  F0
160E:  MOVWF  x89
1610:  ADDWF  x89,F
1612:  ADDLW  E2
1614:  MOVWF  x8A
1616:  ADDLW  32
1618:  MOVWF  x8C
161A:  MOVF   x87,W
161C:  ANDLW  0F
161E:  ADDWF  x8A,F
1620:  ADDWF  x8A,F
1622:  ADDWF  x8C,F
1624:  ADDLW  E9
1626:  MOVWF  x8B
1628:  ADDWF  x8B,F
162A:  ADDWF  x8B,F
162C:  SWAPF  x86,W
162E:  ANDLW  0F
1630:  ADDWF  x8B,F
1632:  ADDWF  x8C,F
1634:  RLCF   x8B,F
1636:  RLCF   x8C,F
1638:  COMF   x8C,F
163A:  RLCF   x8C,F
163C:  MOVF   x86,W
163E:  ANDLW  0F
1640:  ADDWF  x8C,F
1642:  RLCF   x89,F
1644:  MOVLW  07
1646:  MOVWF  x88
1648:  MOVLW  0A
164A:  DECF   x8B,F
164C:  ADDWF  x8C,F
164E:  BNC   164A
1650:  DECF   x8A,F
1652:  ADDWF  x8B,F
1654:  BNC   1650
1656:  DECF   x89,F
1658:  ADDWF  x8A,F
165A:  BNC   1656
165C:  DECF   x88,F
165E:  ADDWF  x89,F
1660:  BNC   165C
1662:  MOVLW  01
1664:  MOVWF  FEA
1666:  MOVLW  88
1668:  MOVWF  FE9
166A:  MOVLW  07
166C:  ANDWF  x8D,W
166E:  BCF    x8D.6
1670:  ADDWF  FE9,F
1672:  MOVLW  00
1674:  ADDWFC FEA,F
1676:  MOVF   FE9,W
1678:  SUBLW  8C
167A:  BNZ   1682
167C:  DECFSZ FEA,W
167E:  BRA    1682
1680:  BSF    x8D.6
1682:  MOVF   FEF,W
1684:  MOVWF  00
1686:  BNZ   1698
1688:  BTFSC  x8D.6
168A:  BRA    1698
168C:  BTFSC  x8D.4
168E:  BRA    16BA
1690:  BTFSC  x8D.3
1692:  BRA    1698
1694:  MOVLW  20
1696:  BRA    169E
1698:  BSF    x8D.3
169A:  BCF    x8D.4
169C:  MOVLW  30
169E:  ADDWF  00,F
16A0:  MOVFF  FEA,187
16A4:  MOVFF  FE9,186
16A8:  MOVFF  00,18F
16AC:  MOVLB  0
16AE:  RCALL  1146
16B0:  MOVFF  187,FEA
16B4:  MOVFF  186,FE9
16B8:  MOVLB  1
16BA:  MOVF   FEE,W
16BC:  BTFSS  x8D.6
16BE:  BRA    1676
16C0:  MOVLB  0
16C2:  RETURN 0
16C4:  MOVF   01,W
16C6:  MOVFF  186,18C
16CA:  MOVLW  64
16CC:  MOVLB  1
16CE:  MOVWF  x8D
16D0:  MOVLB  0
16D2:  RCALL  103E
16D4:  MOVFF  00,186
16D8:  MOVF   01,W
16DA:  MOVLW  30
16DC:  BNZ   16EE
16DE:  MOVLB  1
16E0:  BTFSS  x87.1
16E2:  BRA    1702
16E4:  BTFSC  x87.3
16E6:  BRA    1702
16E8:  BTFSC  x87.4
16EA:  MOVLW  20
16EC:  BRA    16F6
16EE:  MOVLB  1
16F0:  BCF    x87.3
16F2:  BCF    x87.4
16F4:  BSF    x87.0
16F6:  ADDWF  01,F
16F8:  MOVFF  01,18F
16FC:  MOVLB  0
16FE:  RCALL  1146
1700:  MOVLB  1
1702:  MOVFF  186,18C
1706:  MOVLW  0A
1708:  MOVWF  x8D
170A:  MOVLB  0
170C:  RCALL  103E
170E:  MOVFF  00,186
1712:  MOVF   01,W
1714:  MOVLW  30
1716:  BNZ   1728
1718:  MOVLB  1
171A:  BTFSC  x87.3
171C:  BRA    1732
171E:  BTFSS  x87.0
1720:  BRA    1732
1722:  BTFSC  x87.4
1724:  MOVLW  20
1726:  MOVLB  0
1728:  ADDWF  01,F
172A:  MOVFF  01,18F
172E:  RCALL  1146
1730:  MOVLB  1
1732:  MOVLW  30
1734:  ADDWF  x86,F
1736:  MOVFF  186,18F
173A:  MOVLB  0
173C:  RCALL  1146
173E:  RETURN 0
*
2190:  ADDWF  FE8,W
2192:  CLRF   FF7
2194:  RLCF   FF7,F
2196:  ADDLW  AB
2198:  MOVWF  FF6
219A:  MOVLW  21
219C:  ADDWFC FF7,F
219E:  TBLRD*-
21A0:  MOVF   FF5,W
21A2:  MOVWF  FFA
21A4:  TBLRD*
21A6:  MOVF   FF5,W
21A8:  MOVWF  FF9
21AA:  DATA 60,21
21AC:  DATA 8A,21
21AE:  DATA 8A,21
21B0:  DATA 8A,21
21B2:  DATA 62,21
21B4:  DATA 72,21
21B6:  DATA 76,21
21B8:  DATA 8A,21
21BA:  DATA 8A,21
21BC:  DATA 8A,21
21BE:  DATA 78,21
21C0:  DATA 88,21
*
2498:  ADDWF  FE8,W
249A:  CLRF   FF7
249C:  RLCF   FF7,F
249E:  ADDLW  B3
24A0:  MOVWF  FF6
24A2:  MOVLW  24
24A4:  ADDWFC FF7,F
24A6:  TBLRD*-
24A8:  MOVF   FF5,W
24AA:  MOVWF  FFA
24AC:  TBLRD*
24AE:  MOVF   FF5,W
24B0:  MOVWF  FF9
24B2:  DATA 68,24
24B4:  DATA 92,24
24B6:  DATA 92,24
24B8:  DATA 92,24
24BA:  DATA 6A,24
24BC:  DATA 7A,24
24BE:  DATA 7E,24
24C0:  DATA 92,24
24C2:  DATA 92,24
24C4:  DATA 92,24
24C6:  DATA 80,24
24C8:  DATA 90,24
*
27A2:  ADDWF  FE8,W
27A4:  CLRF   FF7
27A6:  RLCF   FF7,F
27A8:  ADDLW  BD
27AA:  MOVWF  FF6
27AC:  MOVLW  27
27AE:  ADDWFC FF7,F
27B0:  TBLRD*-
27B2:  MOVF   FF5,W
27B4:  MOVWF  FFA
27B6:  TBLRD*
27B8:  MOVF   FF5,W
27BA:  MOVWF  FF9
27BC:  DATA 72,27
27BE:  DATA 9C,27
27C0:  DATA 9C,27
27C2:  DATA 9C,27
27C4:  DATA 74,27
27C6:  DATA 84,27
27C8:  DATA 88,27
27CA:  DATA 9C,27
27CC:  DATA 9C,27
27CE:  DATA 9C,27
27D0:  DATA 8A,27
27D2:  DATA 9A,27
*
3336:  ADDWF  FE8,W
3338:  CLRF   FF7
333A:  RLCF   FF7,F
333C:  ADDLW  51
333E:  MOVWF  FF6
3340:  MOVLW  33
3342:  ADDWFC FF7,F
3344:  TBLRD*-
3346:  MOVF   FF5,W
3348:  MOVWF  FFA
334A:  TBLRD*
334C:  MOVF   FF5,W
334E:  MOVWF  FF9
3350:  DATA BC,2F
3352:  DATA D6,2F
3354:  DATA E0,2F
3356:  DATA 22,30
3358:  DATA 2C,30
335A:  DATA 58,30
335C:  DATA 8C,30
335E:  DATA B4,30
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0F6A:  MOVLB  1
0F6C:  MOVFF  18C,FE9
0F70:  MOVFF  18D,FEA
0F74:  MOVFF  FEF,190
0F78:  MOVFF  18F,03
0F7C:  MOVFF  18E,FE9
0F80:  MOVFF  18F,FEA
0F84:  MOVF   FEF,W
0F86:  SUBWF  x90,W
0F88:  BNZ   0FB4
....................       if (*s1 == '\0') 
0F8A:  MOVFF  18D,03
0F8E:  MOVFF  18C,FE9
0F92:  MOVFF  03,FEA
0F96:  MOVF   FEF,F
0F98:  BNZ   0FA0
....................          return(0); 
0F9A:  MOVLW  00
0F9C:  MOVWF  01
0F9E:  BRA    0FDE
0FA0:  MOVFF  18D,03
0FA4:  MOVF   x8C,W
0FA6:  INCF   x8C,F
0FA8:  BTFSC  FD8.2
0FAA:  INCF   x8D,F
0FAC:  INCF   x8E,F
0FAE:  BTFSC  FD8.2
0FB0:  INCF   x8F,F
0FB2:  BRA    0F6C
....................    return((*s1 < *s2) ? -1: 1); 
0FB4:  MOVFF  18D,03
0FB8:  MOVFF  18C,FE9
0FBC:  MOVFF  18D,FEA
0FC0:  MOVFF  FEF,190
0FC4:  MOVFF  18F,03
0FC8:  MOVFF  18E,FE9
0FCC:  MOVFF  18F,FEA
0FD0:  MOVF   FEF,W
0FD2:  SUBWF  x90,W
0FD4:  BC    0FDA
0FD6:  MOVLW  FF
0FD8:  BRA    0FDC
0FDA:  MOVLW  01
0FDC:  MOVWF  01
0FDE:  MOVLB  0
0FE0:  GOTO   1024 (RETURN)
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=20000000) 
*
0182:  MOVLW  03
0184:  MOVLB  1
0186:  SUBWF  x9E,F
0188:  BNC   019E
018A:  MOVLW  01
018C:  MOVWF  FEA
018E:  MOVLW  9E
0190:  MOVWF  FE9
0192:  MOVF   FEF,W
0194:  BZ    019E
0196:  BRA    019A
0198:  BRA    019A
019A:  DECFSZ FEF,F
019C:  BRA    0198
019E:  MOVLB  0
01A0:  GOTO   01B6 (RETURN)
*
03BE:  MOVLW  01
03C0:  MOVWF  FEA
03C2:  MOVLW  90
03C4:  MOVWF  FE9
03C6:  MOVF   FEF,W
03C8:  BZ    03E4
03CA:  MOVLW  06
03CC:  MOVWF  01
03CE:  CLRF   00
03D0:  DECFSZ 00,F
03D2:  BRA    03D0
03D4:  DECFSZ 01,F
03D6:  BRA    03CE
03D8:  MOVLW  7B
03DA:  MOVWF  00
03DC:  DECFSZ 00,F
03DE:  BRA    03DC
03E0:  DECFSZ FEF,F
03E2:  BRA    03CA
03E4:  RETURN 0
.................... #use rs232(uart1, baud=9600,TIMEOUT=10,stream=monitor)//pic to pic 
*
01A4:  MOVLW  20
01A6:  MOVLB  1
01A8:  MOVWF  x9C
01AA:  MOVLW  02
01AC:  MOVWF  x9D
01AE:  MOVLW  9B
01B0:  MOVWF  x9E
01B2:  MOVLB  0
01B4:  BRA    0182
01B6:  MOVLB  1
01B8:  DECFSZ x9D,F
01BA:  BRA    01AE
01BC:  DECFSZ x9C,F
01BE:  BRA    01C6
01C0:  CLRF   1F
01C2:  CLRF   01
01C4:  BRA    01DA
01C6:  BTFSS  F9E.5
01C8:  BRA    01AA
01CA:  MOVF   FAB,W
01CC:  MOVWF  1F
01CE:  MOVF   FAE,W
01D0:  MOVWF  01
01D2:  BTFSS  1F.1
01D4:  BRA    01DA
01D6:  BCF    FAB.4
01D8:  BSF    FAB.4
01DA:  MOVLB  0
01DC:  GOTO   0208 (RETURN)
.................... #use rs232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C0,rcv=PIN_C1,TIMEOUT=40,stream=GPS,DISABLE_INTS)// 
*
0E4A:  MOVLW  10
0E4C:  MOVLB  1
0E4E:  MOVWF  x8B
0E50:  MOVLW  01
0E52:  MOVWF  x8A
0E54:  BSF    20.6
0E56:  BSF    F94.1
0E58:  MOVLW  10
0E5A:  MOVWF  00
0E5C:  DECFSZ 00,F
0E5E:  BRA    0E5C
0E60:  NOP   
0E62:  DECFSZ x8A,F
0E64:  BRA    0E70
0E66:  DECFSZ x8B,F
0E68:  BRA    0E70
0E6A:  CLRF   20
0E6C:  CLRF   01
0E6E:  BRA    0EB8
0E70:  BTFSC  F82.1
0E72:  BRA    0E58
0E74:  MOVLW  08
0E76:  MOVWF  00
0E78:  CLRF   x8C
0E7A:  MOVFF  FF2,18D
0E7E:  BCF    FF2.7
0E80:  BSF    00.7
0E82:  BRA    0EA0
0E84:  BCF    00.7
0E86:  BRA    0EA0
0E88:  BCF    FD8.0
0E8A:  BTFSC  F82.1
0E8C:  BSF    FD8.0
0E8E:  RRCF   x8C,F
0E90:  BSF    00.6
0E92:  BRA    0EA0
0E94:  BCF    00.6
0E96:  DECFSZ 00,F
0E98:  BRA    0E88
0E9A:  MOVF   x8C,W
0E9C:  MOVWF  01
0E9E:  BRA    0EB8
0EA0:  MOVLW  A7
0EA2:  BTFSC  00.7
0EA4:  MOVLW  2D
0EA6:  MOVWF  01
0EA8:  DECFSZ 01,F
0EAA:  BRA    0EA8
0EAC:  NOP   
0EAE:  BTFSC  00.7
0EB0:  BRA    0E84
0EB2:  BTFSC  00.6
0EB4:  BRA    0E94
0EB6:  BRA    0E88
0EB8:  BTFSC  x8D.7
0EBA:  BSF    FF2.7
0EBC:  MOVLB  0
0EBE:  RETURN 0
*
1146:  MOVFF  FF2,03
114A:  BCF    FF2.7
114C:  BCF    F94.0
114E:  BCF    F8B.0
1150:  MOVLW  08
1152:  MOVWF  01
1154:  BRA    1156
1156:  NOP   
1158:  BSF    01.7
115A:  BRA    117C
115C:  BCF    01.7
115E:  MOVLB  1
1160:  RRCF   x8F,F
1162:  MOVLB  0
1164:  BTFSC  FD8.0
1166:  BSF    F8B.0
1168:  BTFSS  FD8.0
116A:  BCF    F8B.0
116C:  BSF    01.6
116E:  BRA    117C
1170:  BCF    01.6
1172:  DECFSZ 01,F
1174:  BRA    115E
1176:  BRA    1178
1178:  NOP   
117A:  BSF    F8B.0
117C:  MOVLW  A7
117E:  MOVWF  FE9
1180:  DECFSZ FE9,F
1182:  BRA    1180
1184:  BRA    1186
1186:  BTFSC  01.7
1188:  BRA    115C
118A:  BTFSC  01.6
118C:  BRA    1170
118E:  BTFSC  03.7
1190:  BSF    FF2.7
1192:  RETURN 0
.................... #fuses HS,NOLVP,PUT,PROTECT,NODEBUG,NOWDT,WDT4096//pin D5 rx, tx_d0 
.................... #priority int_rda 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
03E6:  MOVLB  1
03E8:  BTFSC  x97.0
03EA:  BRA    03F0
03EC:  BCF    F89.4
03EE:  BRA    03F2
03F0:  BSF    F89.4
03F2:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
03F4:  BTFSC  x97.1
03F6:  BRA    03FC
03F8:  BCF    F89.2
03FA:  BRA    03FE
03FC:  BSF    F89.2
03FE:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0400:  BTFSC  x97.2
0402:  BRA    0408
0404:  BCF    F89.1
0406:  BRA    040A
0408:  BSF    F89.1
040A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
040C:  BTFSC  x97.3
040E:  BRA    0414
0410:  BCF    F89.0
0412:  BRA    0416
0414:  BSF    F89.0
0416:  BCF    F92.0
....................  
....................  delay_cycles(1);  
0418:  NOP   
....................  output_high(LCD_E);  
041A:  BCF    F92.3
041C:  BSF    F89.3
....................  delay_us(2);  
041E:  MOVLW  02
0420:  MOVWF  00
0422:  DECFSZ 00,F
0424:  BRA    0422
0426:  BRA    0428
0428:  NOP   
....................  output_low(LCD_E);  
042A:  BCF    F92.3
042C:  BCF    F89.3
042E:  MOVLB  0
0430:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0432:  BCF    F96.2
0434:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
0436:  MOVLW  63
0438:  MOVWF  00
043A:  DECFSZ 00,F
043C:  BRA    043A
043E:  BRA    0440
.................... #endif  
....................  
.................... if(address)  
0440:  MOVLB  1
0442:  MOVF   x94,F
0444:  BZ    044C
....................    output_high(LCD_RS);  
0446:  BCF    F96.2
0448:  BSF    F8D.2
044A:  BRA    0450
.................... else  
....................    output_low(LCD_RS);  
044C:  BCF    F96.2
044E:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0450:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0452:  BCF    F92.3
0454:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
0456:  SWAPF  x95,W
0458:  MOVWF  x96
045A:  MOVLW  0F
045C:  ANDWF  x96,F
045E:  MOVFF  196,197
0462:  MOVLB  0
0464:  RCALL  03E6
.................... lcd_send_nibble(n & 0xf);  
0466:  MOVLB  1
0468:  MOVF   x95,W
046A:  ANDLW  0F
046C:  MOVWF  x96
046E:  MOVWF  x97
0470:  MOVLB  0
0472:  RCALL  03E6
0474:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
0476:  MOVLW  01
0478:  MOVWF  21
....................  
....................    output_low(LCD_RS);  
047A:  BCF    F96.2
047C:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
047E:  BCF    F92.3
0480:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
0482:  MOVLW  23
0484:  MOVLB  1
0486:  MOVWF  x90
0488:  MOVLB  0
048A:  RCALL  03BE
....................  
....................    for(i=0 ;i < 3; i++)  
048C:  MOVLB  1
048E:  CLRF   x86
0490:  MOVF   x86,W
0492:  SUBLW  02
0494:  BNC   04AE
....................    {  
....................       lcd_send_nibble(0x03);  
0496:  MOVLW  03
0498:  MOVWF  x97
049A:  MOVLB  0
049C:  RCALL  03E6
....................       delay_ms(5);  
049E:  MOVLW  05
04A0:  MOVLB  1
04A2:  MOVWF  x90
04A4:  MOVLB  0
04A6:  RCALL  03BE
04A8:  MOVLB  1
04AA:  INCF   x86,F
04AC:  BRA    0490
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
04AE:  MOVLW  02
04B0:  MOVWF  x97
04B2:  MOVLB  0
04B4:  RCALL  03E6
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
04B6:  MOVLB  1
04B8:  CLRF   x86
04BA:  MOVF   x86,W
04BC:  SUBLW  03
04BE:  BNC   04E4
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
04C0:  CLRF   03
04C2:  MOVF   x86,W
04C4:  MOVLB  0
04C6:  RCALL  00BA
04C8:  MOVLB  1
04CA:  MOVWF  x87
04CC:  CLRF   x94
04CE:  MOVWF  x95
04D0:  MOVLB  0
04D2:  RCALL  0432
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
04D4:  MOVLW  05
04D6:  MOVLB  1
04D8:  MOVWF  x90
04DA:  MOVLB  0
04DC:  RCALL  03BE
....................       #endif  
04DE:  MOVLB  1
04E0:  INCF   x86,F
04E2:  BRA    04BA
....................    }  
04E4:  MOVLB  0
04E6:  GOTO   2CF2 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
0822:  MOVLB  1
0824:  MOVF   x91,W
0826:  XORLW  01
0828:  MOVLB  0
082A:  BZ    083A
082C:  XORLW  03
082E:  BZ    0840
0830:  XORLW  01
0832:  BZ    0848
0834:  XORLW  07
0836:  BZ    0850
0838:  BRA    085A
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
083A:  MOVLB  1
083C:  CLRF   x92
....................      break;  
083E:  BRA    085E
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0840:  MOVLW  40
0842:  MOVLB  1
0844:  MOVWF  x92
....................      break;  
0846:  BRA    085E
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0848:  MOVLW  14
084A:  MOVLB  1
084C:  MOVWF  x92
....................      break;  
084E:  BRA    085E
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0850:  MOVLW  54
0852:  MOVLB  1
0854:  MOVWF  x92
....................      break;  
0856:  BRA    085E
0858:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
085A:  MOVLB  1
085C:  CLRF   x92
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
085E:  MOVLW  01
0860:  SUBWF  x90,W
0862:  ADDWF  x92,F
.................... lcd_send_byte(0, 0x80 | address);  
0864:  MOVF   x92,W
0866:  IORLW  80
0868:  MOVWF  x93
086A:  CLRF   x94
086C:  MOVWF  x95
086E:  MOVLB  0
0870:  RCALL  0432
0872:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0874:  MOVLB  1
0876:  MOVF   x8F,W
0878:  XORLW  0C
087A:  MOVLB  0
087C:  BZ    0888
087E:  XORLW  06
0880:  BZ    08A4
0882:  XORLW  02
0884:  BZ    08B6
0886:  BRA    08C4
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0888:  MOVLB  1
088A:  CLRF   x94
088C:  MOVLW  01
088E:  MOVWF  x95
0890:  MOVLB  0
0892:  RCALL  0432
....................       lcd_line = 1;  
0894:  MOVLW  01
0896:  MOVWF  21
....................       delay_ms(2);  
0898:  MOVLW  02
089A:  MOVLB  1
089C:  MOVWF  x90
089E:  MOVLB  0
08A0:  RCALL  03BE
....................       break;  
08A2:  BRA    08D2
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
08A4:  INCF   21,F
08A6:  MOVLW  01
08A8:  MOVLB  1
08AA:  MOVWF  x90
08AC:  MOVFF  21,191
08B0:  MOVLB  0
08B2:  RCALL  0822
....................        break;  
08B4:  BRA    08D2
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
08B6:  MOVLB  1
08B8:  CLRF   x94
08BA:  MOVLW  10
08BC:  MOVWF  x95
08BE:  MOVLB  0
08C0:  RCALL  0432
....................        break;  
08C2:  BRA    08D2
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
08C4:  MOVLW  01
08C6:  MOVLB  1
08C8:  MOVWF  x94
08CA:  MOVFF  18F,195
08CE:  MOVLB  0
08D0:  RCALL  0432
....................        break;  
....................    }  
08D2:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_eeprom.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_D6//PIN_B7 
.................... #define EEPROM_SCL  PIN_D7//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
04F2:  MOVLW  08
04F4:  MOVWF  01
04F6:  MOVLW  05
04F8:  MOVWF  00
04FA:  DECFSZ 00,F
04FC:  BRA    04FA
04FE:  BCF    F8C.7
0500:  BCF    F95.7
0502:  MOVLW  06
0504:  MOVWF  00
0506:  DECFSZ 00,F
0508:  BRA    0506
050A:  MOVLB  1
050C:  RLCF   x90,F
050E:  BCF    F8C.6
0510:  BTFSC  FD8.0
0512:  BSF    F95.6
0514:  BTFSS  FD8.0
0516:  BCF    F95.6
0518:  BSF    F95.7
051A:  BTFSS  F83.7
051C:  BRA    051A
051E:  DECFSZ 01,F
0520:  BRA    0524
0522:  BRA    0528
0524:  MOVLB  0
0526:  BRA    04F6
0528:  MOVLW  05
052A:  MOVWF  00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  BCF    F8C.7
0532:  BCF    F95.7
0534:  NOP   
0536:  BSF    F95.6
0538:  MOVLW  06
053A:  MOVWF  00
053C:  DECFSZ 00,F
053E:  BRA    053C
0540:  MOVLW  06
0542:  MOVWF  00
0544:  DECFSZ 00,F
0546:  BRA    0544
0548:  BSF    F95.7
054A:  BTFSS  F83.7
054C:  BRA    054A
054E:  CLRF   01
0550:  MOVLW  06
0552:  MOVWF  00
0554:  DECFSZ 00,F
0556:  BRA    0554
0558:  BTFSC  F83.6
055A:  BSF    01.0
055C:  BCF    F8C.7
055E:  BCF    F95.7
0560:  BCF    F8C.6
0562:  BCF    F95.6
0564:  MOVLB  0
0566:  RETURN 0
*
06BC:  MOVLW  08
06BE:  MOVLB  1
06C0:  MOVWF  x8E
06C2:  MOVFF  00,18F
06C6:  BSF    F95.6
06C8:  MOVLW  06
06CA:  MOVWF  00
06CC:  DECFSZ 00,F
06CE:  BRA    06CC
06D0:  BSF    F95.7
06D2:  BTFSS  F83.7
06D4:  BRA    06D2
06D6:  BTFSC  F83.6
06D8:  BSF    FD8.0
06DA:  BTFSS  F83.6
06DC:  BCF    FD8.0
06DE:  RLCF   01,F
06E0:  MOVLW  05
06E2:  MOVWF  00
06E4:  DECFSZ 00,F
06E6:  BRA    06E4
06E8:  BCF    F95.7
06EA:  BCF    F8C.7
06EC:  DECFSZ x8E,F
06EE:  BRA    06C6
06F0:  BSF    F95.6
06F2:  MOVLW  06
06F4:  MOVWF  00
06F6:  DECFSZ 00,F
06F8:  BRA    06F6
06FA:  BCF    F8C.6
06FC:  MOVF   x8F,W
06FE:  BTFSS  FD8.2
0700:  BCF    F95.6
0702:  NOP   
0704:  BSF    F95.7
0706:  BTFSS  F83.7
0708:  BRA    0706
070A:  MOVLW  05
070C:  MOVWF  00
070E:  DECFSZ 00,F
0710:  BRA    070E
0712:  BCF    F8C.7
0714:  BCF    F95.7
0716:  MOVLW  06
0718:  MOVWF  00
071A:  DECFSZ 00,F
071C:  BRA    071A
071E:  BCF    F8C.6
0720:  BCF    F95.6
0722:  MOVLB  0
0724:  GOTO   07A2 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
04EA:  BSF    F95.7
....................    output_float(EEPROM_SDA); 
04EC:  BSF    F95.6
04EE:  GOTO   2CF6 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0568:  BSF    F95.6
056A:  MOVLW  05
056C:  MOVWF  00
056E:  DECFSZ 00,F
0570:  BRA    056E
0572:  BSF    F95.7
0574:  MOVLW  06
0576:  MOVWF  00
0578:  DECFSZ 00,F
057A:  BRA    0578
057C:  BCF    F8C.6
057E:  BCF    F95.6
0580:  MOVLW  05
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  BCF    F8C.7
058A:  BCF    F95.7
....................    i2c_write(0xa0); 
058C:  MOVLW  A0
058E:  MOVLB  1
0590:  MOVWF  x90
0592:  MOVLB  0
0594:  RCALL  04F2
....................    i2c_write(address>>8); 
0596:  MOVFF  18B,18E
059A:  MOVLB  1
059C:  CLRF   x8F
059E:  MOVFF  18B,190
05A2:  MOVLB  0
05A4:  RCALL  04F2
....................    i2c_write(address); 
05A6:  MOVFF  18A,190
05AA:  RCALL  04F2
....................    i2c_write(data); 
05AC:  MOVFF  18C,190
05B0:  RCALL  04F2
....................    i2c_stop(); 
05B2:  BCF    F95.6
05B4:  NOP   
05B6:  BSF    F95.7
05B8:  BTFSS  F83.7
05BA:  BRA    05B8
05BC:  MOVLW  05
05BE:  MOVWF  00
05C0:  DECFSZ 00,F
05C2:  BRA    05C0
05C4:  BRA    05C6
05C6:  NOP   
05C8:  BSF    F95.6
05CA:  MOVLW  05
05CC:  MOVWF  00
05CE:  DECFSZ 00,F
05D0:  BRA    05CE
....................    i2c_start(); 
05D2:  BSF    F95.6
05D4:  MOVLW  05
05D6:  MOVWF  00
05D8:  DECFSZ 00,F
05DA:  BRA    05D8
05DC:  BSF    F95.7
05DE:  MOVLW  06
05E0:  MOVWF  00
05E2:  DECFSZ 00,F
05E4:  BRA    05E2
05E6:  BCF    F8C.6
05E8:  BCF    F95.6
05EA:  MOVLW  05
05EC:  MOVWF  00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
05F2:  BCF    F8C.7
05F4:  BCF    F95.7
....................    status=i2c_write(0xa0); 
05F6:  MOVLW  A0
05F8:  MOVLB  1
05FA:  MOVWF  x90
05FC:  MOVLB  0
05FE:  RCALL  04F2
0600:  MOVF   01,W
0602:  MOVLB  1
0604:  BCF    x8D.0
0606:  BTFSC  01.0
0608:  BSF    x8D.0
....................    while(status==1) 
060A:  BTFSS  x8D.0
060C:  BRA    064A
....................    { 
....................    i2c_start(); 
060E:  BSF    F95.6
0610:  MOVLW  05
0612:  MOVWF  00
0614:  DECFSZ 00,F
0616:  BRA    0614
0618:  BSF    F95.7
061A:  MOVLW  06
061C:  MOVWF  00
061E:  DECFSZ 00,F
0620:  BRA    061E
0622:  BTFSS  F83.7
0624:  BRA    0622
0626:  BCF    F8C.6
0628:  BCF    F95.6
062A:  MOVLW  05
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
0632:  BCF    F8C.7
0634:  BCF    F95.7
....................    status=i2c_write(0xa0); 
0636:  MOVLW  A0
0638:  MOVWF  x90
063A:  MOVLB  0
063C:  RCALL  04F2
063E:  MOVF   01,W
0640:  MOVLB  1
0642:  BCF    x8D.0
0644:  BTFSC  01.0
0646:  BSF    x8D.0
0648:  BRA    060A
....................    } 
....................    i2c_stop(); 
064A:  BCF    F95.6
064C:  NOP   
064E:  BSF    F95.7
0650:  BTFSS  F83.7
0652:  BRA    0650
0654:  MOVLW  05
0656:  MOVWF  00
0658:  DECFSZ 00,F
065A:  BRA    0658
065C:  BRA    065E
065E:  NOP   
0660:  BSF    F95.6
0662:  MOVLW  05
0664:  MOVWF  00
0666:  DECFSZ 00,F
0668:  BRA    0666
066A:  MOVLB  0
066C:  RETURN 0
.................... } 
....................  
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
0728:  BSF    F95.6
072A:  MOVLW  05
072C:  MOVWF  00
072E:  DECFSZ 00,F
0730:  BRA    072E
0732:  BSF    F95.7
0734:  MOVLW  06
0736:  MOVWF  00
0738:  DECFSZ 00,F
073A:  BRA    0738
073C:  BCF    F8C.6
073E:  BCF    F95.6
0740:  MOVLW  05
0742:  MOVWF  00
0744:  DECFSZ 00,F
0746:  BRA    0744
0748:  BCF    F8C.7
074A:  BCF    F95.7
....................    i2c_write(0xa0); 
074C:  MOVLW  A0
074E:  MOVLB  1
0750:  MOVWF  x90
0752:  MOVLB  0
0754:  RCALL  04F2
....................    i2c_write(address>>8); 
0756:  MOVFF  18B,18D
075A:  MOVLB  1
075C:  CLRF   x8E
075E:  MOVFF  18B,190
0762:  MOVLB  0
0764:  RCALL  04F2
....................    i2c_write(address); 
0766:  MOVFF  18A,190
076A:  RCALL  04F2
....................    i2c_start(); 
076C:  BSF    F95.6
076E:  MOVLW  05
0770:  MOVWF  00
0772:  DECFSZ 00,F
0774:  BRA    0772
0776:  BSF    F95.7
0778:  MOVLW  06
077A:  MOVWF  00
077C:  DECFSZ 00,F
077E:  BRA    077C
0780:  BTFSS  F83.7
0782:  BRA    0780
0784:  BCF    F8C.6
0786:  BCF    F95.6
0788:  MOVLW  05
078A:  MOVWF  00
078C:  DECFSZ 00,F
078E:  BRA    078C
0790:  BCF    F8C.7
0792:  BCF    F95.7
....................    i2c_write(0xa1); 
0794:  MOVLW  A1
0796:  MOVLB  1
0798:  MOVWF  x90
079A:  MOVLB  0
079C:  RCALL  04F2
....................    data=i2c_read(0); 
079E:  CLRF   00
07A0:  BRA    06BC
07A2:  MOVFF  01,18C
....................    i2c_stop(); 
07A6:  BCF    F95.6
07A8:  NOP   
07AA:  BSF    F95.7
07AC:  BTFSS  F83.7
07AE:  BRA    07AC
07B0:  MOVLW  05
07B2:  MOVWF  00
07B4:  DECFSZ 00,F
07B6:  BRA    07B4
07B8:  BRA    07BA
07BA:  NOP   
07BC:  BSF    F95.6
07BE:  MOVLW  05
07C0:  MOVWF  00
07C2:  DECFSZ 00,F
07C4:  BRA    07C2
....................    return(data); 
07C6:  MOVLB  1
07C8:  MOVFF  18C,01
07CC:  MOVLB  0
07CE:  RETURN 0
.................... } 
....................  
.................... //****************************************************************************** 
.................... //entradas 
.................... #define entrada01  PIN_B4////SENSOR 1              2  1 
.................... #define entrada02  PIN_D4////SENSOR 2              4  3 
.................... #define entrada03  PIN_B2////SENSOR 3              6  5 
.................... #define entrada04  PIN_B3////SENSOR 4 
.................... #define entrada05  PIN_B0////SENSOR 5 
.................... #define entrada06  PIN_B1////SENSOR 6 
....................  
.................... #define rst_cta PIN_D3////REINICIAR CONTADOR 
.................... #define frente  PIN_D2///INDICADOR DE MAESTRO 
.................... #define B_silencio  PIN_D1///BOTON PARA SILENCIAR (eliminado) 
.................... //salidas 
.................... #define salida01  PIN_C3//Buzzer 
.................... #define salida02  PIN_C4//Indicador de Sensado 
.................... #define salida03  PIN_C5//Relay 
.................... const int s_cta=5;//numero de veces para verificar obsturbcion (sensibilidad de deteccion) 
.................... int size_s;//Tamao de trama que espera leer el puerto serial (se utiliza para agilizar la captura de datos) 
.................... ///////VARIABLES DE CONEXION///// 
.................... int error,transmitir;//variable para indicar un error al escuchar la cuenta del poste trasero, bandera para inciar transmision a gprs 
.................... ///////GENERALES////////////////////// 
.................... int sumae1,sumas1;//Variables temporales de suma de entradas y salidas 
.................... int lim_b;//cuenta de sensores bloqueados 
.................... int fse1,fse2,fse3,fss1,fss2,fss3;//banderas que indican si los pares de sensores detectaron entrada o salida 
.................... unsigned int16 temporal1,temporal2,tempo_tn,sub_atras,baj_atras;//variables temporales para hacer calculos. 
.................... int16 entran1,salen1;//variables temporales para hacer calculos. 
.................... ///////--------------------/////////// 
.................... int16 salian,time_clr;//variable temporal para guardar salidas 
.................... int ini,i,ii,j=0,a,master=0,flag_enviar,f_clr; 
.................... int16 b,n,cta_bloqueo,cta_enviar,total2_t;//,envia_ent,envia_sal; 
.................... int cta_bloq1=0,cta_bloq2=0,cta_bloq3=0;//variables para contar bloqueos por pares 
.................... int ent1=0,ent2=0,ent3=0,ent4=0,ent5=0,ent6=0;//variables de estado de sensores 
.................... int sen_ent=0,sen_sal=0;//variables para definir el sentido (subio o bajo) 
.................... int16 sub_cta1=0,sub_cta2=0,sub_cta3=0,sub_cta4=0,sub_cta5=0,sub_cta6=0;//variables para calculos de cuentas 
.................... int detec1,detec2,detec3,detec4,detec5,detec6;//variables para determinar el cambio de estado de los sensores 
.................... int sub_d1,sub_d2,sub_d3,sub_d4,sub_d5,sub_d6;//variables para determinar el cambio de estado de los sensores 
.................... int entra_act1=0,edo1=0,entra1=0,sale1=0,edoa1=0,enable1=0,entra_temp1=0;//variables para la maquina de estados de sensores par1 
.................... int entra_act2=0,edo2=0,entra2=0,sale2=0,edoa2=0,enable2=0,entra_temp2=0;//variables para la maquina de estados de sensores par2 
.................... int entra_act3=0,edo3=0,entra3=0,sale3=0,edoa3=0,enable3=0,entra_temp3=0;//variables para la maquina de estados de sensores par3 
.................... int16 entraront=0,salieront=0,pasaje=0,pasajet=0;//cuenta total de entradas y salidas 
.................... int16 tem_entraront=0,tem_salieront=0,temporal3;//cuenta total de entradas y salidas recibidas de cuentas del poste trasero. 
.................... int des1=0,des2=0,des3=0; 
.................... int bloq_p1,bloq_p2,bloq_p3,en_b1,en_b2,en_b3; 
.................... int16 tim_p1,tim_p2,tim_p3,segundoen,time_envio; 
.................... const int32 set_timer=59286;//10ms 
.................... const int16 time_bloqueo=500;//5seg. 100=1seg. 
.................... int clear_lcd1,time_lcd1; 
.................... int y=0; 
....................  
.................... /* 
.................... char texto1[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char texto2[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char texto3[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char texto4[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char texto5[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char texto6[]= "SERIALTEST"; // 
.................... char texto7[]= "SERIAL_TOK"; // 
.................... char texto8[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char texto9[]= "SINFUNCION"; // 
.................... char texto []= "          "; 
.................... char version[]="V5.01";//<---Version de codigo de contador 
....................  
....................  
.................... char grabar_historial_pic[]= "GRABAR_DAT"; //HISTORIAL pic-pic 
.................... char leer_historial_pic[]= "LEERCUENTA"; //LEE HISTORIAL pic-pic 
.................... char borrar_todo[]= "BORRAR_ALL"; //BORRA CONTADORES actuales pic-pic 
.................... char solicitar[]= "SOLICITADO"; //solicita AL OTRO SEGUINT LOS PASAJEROS CONTADOS(falta definir la condicion que la genera) pic-pic 
.................... char conteo_poste_trasero[]= "PASAJEROS:"; //recibe el dato del otro seguint, lo suma, reporta y guarda 
.................... char prueba_serial[]= "SERIALTEST"; // 
.................... char serial_ok[]= "SERIAL_TOK"; // 
.................... char suben_poste_trasero[]= "SUBIENDOC2"; //Notificacion que suben por atras 
.................... char sin_funcion[]= "SINFUNCION"; // 
.................... char espacios []= "          "; 
.................... char version_firmware[]="V5.01";//<---Version de codigo de contador 
.................... */ 
.................... //char textosearch[] = {"GRABAR_DAT","LEERCUENTA","BORRAR_ALL","SOLICITADO","PASAJEROS:","SERIALTEST","SERIAL_TOK","SUBIENDOC2","SINFUNCION","          ","V5.01"}; 
.................... /* 
.................... char *textosearch[11] =    { "GRABAR_DAT\r", 
....................                              "LEERCUENTA\r", 
....................                              "BORRAR_ALL\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r", 
....................                              "V5.01     \r" 
....................                            }; 
.................... */ 
....................  
.................... char *textosearch[11] =    { "V5.01     \r", 
....................                              "BORRAR_ALL\r", 
....................                              "GRABAR_DAT\r",//GRABAR_DAT 
....................                              "LEERCUENTA\r", 
....................                              "SOLICITADO\r", 
....................                              "PASAJEROS:\r", 
....................                              "SERIALTEST\r", 
....................                              "SERIAL_TOK\r", 
....................                              "SUBIENDOC2\r", 
....................                              "SINFUNCION\r", 
....................                              "          \r" 
....................                              
....................                            }; 
....................  
....................  
....................  
.................... char version[]="V5.02";//<---Version de codigo de contador 
....................  
....................  
.................... /////EEPROM/////////// 
.................... const int word_size =10;//TAMAO DE LOS DATOS EN EEPROM//antes 8 
.................... const int data_set=9; 
.................... char XX[word_size+19];// ARREGLO SERIAL 
.................... char entran[4]; 
.................... char salen[4]; 
.................... char bloqueado[3]; 
.................... char memory[word_size]; 
.................... //*******************************// 
.................... char tempo_tc[4]; 
.................... /////////////FUNCIONES///////////// 
.................... void rev_suben(); 
.................... void enviop1(); 
.................... void finsuma(); 
.................... void leer_conta2(); 
.................... void graba_conta2(); 
....................  
.................... int convertir_to_entero(char *cadena); 
.................... int evaluar_string(char *command[]); 
.................... void envia2(); 
.................... void solicitar(); 
.................... void envio_master(); 
.................... void envio(); 
.................... void limpiar(); 
.................... void detecta_suma(); 
.................... void write_ent(); 
.................... void write_sal(); 
.................... void entraron_total(); 
.................... void salieron_total(); 
.................... void rd_eeprom(); 
.................... void rd_eeprom_inicio(); 
.................... //void llaves(); 
....................  
.................... void lcd_cuentas(); 
.................... void sentidos(); 
.................... void sensores(); 
.................... void sensando1(); 
.................... void sensando2(); 
.................... void sensando3(); 
.................... void contando1(); 
.................... void contando2(); 
.................... void contando3(); 
.................... void dar_dato(); 
.................... void reset(); 
.................... //------------------------------------------------------------------------------ 
.................... // Rutina de gestin de interrupciones 
.................... //------------------------------------------------------------------------------ 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
....................    time_clr++; 
*
00CE:  INCF   3E,F
00D0:  BTFSC  FD8.2
00D2:  INCF   3F,F
....................    segundoen++; 
00D4:  INCF   xA7,F
00D6:  BTFSC  FD8.2
00D8:  INCF   xA8,F
....................    if(segundoen>=100) { 
00DA:  MOVF   xA8,F
00DC:  BNZ   00E4
00DE:  MOVF   xA7,W
00E0:  SUBLW  63
00E2:  BC    00F0
....................       segundoen=0; 
00E4:  CLRF   xA8
00E6:  CLRF   xA7
....................       time_envio++; 
00E8:  INCF   xA9,F
00EA:  BTFSC  FD8.2
00EC:  INCF   xAA,F
....................       time_lcd1++; 
00EE:  INCF   xAC,F
....................    } 
.................... //****Se definen los estados de los sensores (deteccion)***// 
....................    //sensor1 
....................    ent1=input(entrada01); 
00F0:  BSF    F93.4
00F2:  CLRF   55
00F4:  BTFSC  F81.4
00F6:  INCF   55,F
....................    if(ent1==0) sub_cta1++;//ent1 =0 (no pulso) 
00F8:  MOVF   55,F
00FA:  BNZ   0102
00FC:  INCF   5D,F
00FE:  BTFSC  FD8.2
0100:  INCF   5E,F
....................    //sensor2 
....................    ent2=input(entrada02); 
0102:  BSF    F95.4
0104:  CLRF   56
0106:  BTFSC  F83.4
0108:  INCF   56,F
....................    if(ent2==0) sub_cta2++; 
010A:  MOVF   56,F
010C:  BNZ   0114
010E:  INCF   5F,F
0110:  BTFSC  FD8.2
0112:  INCF   x60,F
....................    //sensor3 
....................    ent3=input(entrada03); 
0114:  BSF    F93.2
0116:  CLRF   57
0118:  BTFSC  F81.2
011A:  INCF   57,F
....................    if(ent3==0) sub_cta3++; 
011C:  MOVF   57,F
011E:  BNZ   0126
0120:  INCF   x61,F
0122:  BTFSC  FD8.2
0124:  INCF   x62,F
....................    //sensor4 
....................    ent4=input(entrada04); 
0126:  BSF    F93.3
0128:  CLRF   58
012A:  BTFSC  F81.3
012C:  INCF   58,F
....................    if(ent4==0) sub_cta4++; 
012E:  MOVF   58,F
0130:  BNZ   0138
0132:  INCF   x63,F
0134:  BTFSC  FD8.2
0136:  INCF   x64,F
....................    //sensor5 
....................    ent5=input(entrada05); 
0138:  BSF    F93.0
013A:  CLRF   59
013C:  BTFSC  F81.0
013E:  INCF   59,F
....................    if(ent5==0) sub_cta5++; 
0140:  MOVF   59,F
0142:  BNZ   014A
0144:  INCF   x65,F
0146:  BTFSC  FD8.2
0148:  INCF   x66,F
....................    //sensor6 
....................    ent6=input(entrada06); 
014A:  BSF    F93.1
014C:  CLRF   5A
014E:  BTFSC  F81.1
0150:  INCF   5A,F
....................    if(ent6==0) sub_cta6++; 
0152:  MOVF   5A,F
0154:  BNZ   015C
0156:  INCF   x67,F
0158:  BTFSC  FD8.2
015A:  INCF   x68,F
.................... //****************************************// 
....................    tim_p1++; 
015C:  INCF   xA1,F
015E:  BTFSC  FD8.2
0160:  INCF   xA2,F
....................    tim_p2++; 
0162:  INCF   xA3,F
0164:  BTFSC  FD8.2
0166:  INCF   xA4,F
....................    tim_p3++; 
0168:  INCF   xA5,F
016A:  BTFSC  FD8.2
016C:  INCF   xA6,F
....................    cta_enviar++; 
016E:  INCF   4E,F
0170:  BTFSC  FD8.2
0172:  INCF   4F,F
.................... set_timer1(set_timer);// 10ms 
0174:  MOVLW  E7
0176:  MOVWF  FCF
0178:  MOVLW  96
017A:  MOVWF  FCE
.................... } 
.................... //****************************************************************************// 
.................... /* 
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
....................    while (i <= size_s){ 
....................          XX[i] = fgetc(monitor);//se captura el dato del serial monitor(comunicacion entre pics) 
....................         i++; 
....................    } 
.................... j=1; 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
.................... */ 
017C:  BCF    F9E.0
017E:  GOTO   006C
.................... #int_rda 
.................... void isr_rs232(){ //escucha segundo poste 
.................... disable_interrupts(GLOBAL);//deshabilita interrupciones globales 
*
01E0:  BCF    FF2.6
01E2:  BCF    FF2.7
01E4:  BTFSC  FF2.7
01E6:  BRA    01E2
.................... i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
01E8:  CLRF   41
....................  
....................    while(i<=15){ 
01EA:  MOVF   41,W
01EC:  SUBLW  0F
01EE:  BNC   022E
....................    XX[i] = fgetc(monitor); 
01F0:  CLRF   03
01F2:  MOVF   41,W
01F4:  ADDLW  4E
01F6:  MOVWF  FE9
01F8:  MOVLW  01
01FA:  ADDWFC 03,W
01FC:  MOVWF  FEA
01FE:  MOVFF  FEA,19B
0202:  MOVFF  FE9,19A
0206:  BRA    01A4
0208:  MOVFF  19B,FEA
020C:  MOVFF  19A,FE9
0210:  MOVFF  01,FEF
....................    i++; 
0214:  INCF   41,F
....................    if(XX[i]==13)break; 
0216:  CLRF   03
0218:  MOVF   41,W
021A:  ADDLW  4E
021C:  MOVWF  FE9
021E:  MOVLW  01
0220:  ADDWFC 03,W
0222:  MOVWF  FEA
0224:  MOVF   FEF,W
0226:  SUBLW  0D
0228:  BTFSC  FD8.2
022A:  BRA    022E
022C:  BRA    01EA
....................    };//se captura el dato del serial monitor(comunicacion entre pics) 
....................     
....................     
....................   // XX[i]=fgetc(monitor); 
.................... j=1; 
022E:  MOVLW  01
0230:  MOVWF  43
.................... y=1; 
0232:  MOVWF  xAD
.................... //fprintf(monitor,"XX:%s",XX); 
.................... //sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0;//reinicia la cuenta para detectar sensores 
.................... } 
....................  
0234:  BCF    F9E.5
0236:  GOTO   006C
.................... #ZERO_RAM 
.................... void main(){ 
*
2B38:  CLRF   FF8
2B3A:  BCF    FD0.7
2B3C:  BSF    07.7
2B3E:  MOVLW  FE
2B40:  MOVWF  00
2B42:  MOVLW  06
2B44:  MOVWF  01
2B46:  MOVLW  02
2B48:  MOVWF  FE9
2B4A:  MOVLW  00
2B4C:  MOVWF  FEA
2B4E:  CLRF   FEE
2B50:  DECFSZ 00,F
2B52:  BRA    2B4E
2B54:  DECFSZ 01,F
2B56:  BRA    2B4E
2B58:  CLRF   1F
2B5A:  BSF    FB8.3
2B5C:  MOVLW  08
2B5E:  MOVWF  FAF
2B60:  MOVLW  02
2B62:  MOVWF  FB0
2B64:  MOVLW  A6
2B66:  MOVWF  FAC
2B68:  MOVLW  90
2B6A:  MOVWF  FAB
2B6C:  CLRF   20
2B6E:  BCF    F94.0
2B70:  BSF    F8B.0
2B72:  CLRF   43
2B74:  CLRF   45
2B76:  CLRF   52
2B78:  CLRF   53
2B7A:  CLRF   54
2B7C:  CLRF   55
2B7E:  CLRF   56
2B80:  CLRF   57
2B82:  CLRF   58
2B84:  CLRF   59
2B86:  CLRF   5A
2B88:  CLRF   5B
2B8A:  CLRF   5C
2B8C:  CLRF   5E
2B8E:  CLRF   5D
2B90:  CLRF   x60
2B92:  CLRF   5F
2B94:  CLRF   x62
2B96:  CLRF   x61
2B98:  CLRF   x64
2B9A:  CLRF   x63
2B9C:  CLRF   x66
2B9E:  CLRF   x65
2BA0:  CLRF   x68
2BA2:  CLRF   x67
2BA4:  CLRF   x75
2BA6:  CLRF   x76
2BA8:  CLRF   x77
2BAA:  CLRF   x78
2BAC:  CLRF   x79
2BAE:  CLRF   x7A
2BB0:  CLRF   x7B
2BB2:  CLRF   x7C
2BB4:  CLRF   x7D
2BB6:  CLRF   x7E
2BB8:  CLRF   x7F
2BBA:  CLRF   x80
2BBC:  CLRF   x81
2BBE:  CLRF   x82
2BC0:  CLRF   x83
2BC2:  CLRF   x84
2BC4:  CLRF   x85
2BC6:  CLRF   x86
2BC8:  CLRF   x87
2BCA:  CLRF   x88
2BCC:  CLRF   x89
2BCE:  CLRF   x8B
2BD0:  CLRF   x8A
2BD2:  CLRF   x8D
2BD4:  CLRF   x8C
2BD6:  CLRF   x8F
2BD8:  CLRF   x8E
2BDA:  CLRF   x91
2BDC:  CLRF   x90
2BDE:  CLRF   x93
2BE0:  CLRF   x92
2BE2:  CLRF   x95
2BE4:  CLRF   x94
2BE6:  CLRF   x98
2BE8:  CLRF   x99
2BEA:  CLRF   x9A
2BEC:  CLRF   xAD
2BEE:  MOVF   FC1,W
2BF0:  ANDLW  C0
2BF2:  IORLW  0F
2BF4:  MOVWF  FC1
2BF6:  MOVLW  07
2BF8:  MOVWF  FB4
2BFA:  BRA    2CA6
2BFC:  DATA 02,00
2BFE:  DATA 19,00
2C00:  DATA 00,05
2C02:  DATA 00,C4
2C04:  DATA 56,35
2C06:  DATA 2E,30
2C08:  DATA 31,05
2C0A:  DATA C0,20
2C0C:  DATA 6E,80
2C0E:  DATA 0D,00
2C10:  DATA 42,4F
2C12:  DATA 52,52
2C14:  DATA 41,52
2C16:  DATA 5F,41
2C18:  DATA 4C,4C
2C1A:  DATA 0D,00
2C1C:  DATA 47,52
2C1E:  DATA 41,42
2C20:  DATA 41,52
2C22:  DATA 5F,44
2C24:  DATA 41,54
2C26:  DATA 0D,00
2C28:  DATA 4C,45
2C2A:  DATA 45,52
2C2C:  DATA 43,55
2C2E:  DATA 45,4E
2C30:  DATA 54,41
2C32:  DATA 0D,00
2C34:  DATA 53,4F
2C36:  DATA 4C,49
2C38:  DATA 43,49
2C3A:  DATA 54,41
2C3C:  DATA 44,4F
2C3E:  DATA 0D,00
2C40:  DATA 50,41
2C42:  DATA 53,41
2C44:  DATA 4A,45
2C46:  DATA 52,4F
2C48:  DATA 53,3A
2C4A:  DATA 0D,00
2C4C:  DATA 53,45
2C4E:  DATA 52,49
2C50:  DATA 41,4C
2C52:  DATA 54,45
2C54:  DATA 53,54
2C56:  DATA 0D,00
2C58:  DATA 53,45
2C5A:  DATA 52,49
2C5C:  DATA 41,4C
2C5E:  DATA 5F,54
2C60:  DATA 4F,4B
2C62:  DATA 0D,00
2C64:  DATA 53,55
2C66:  DATA 42,49
2C68:  DATA 45,4E
2C6A:  DATA 44,4F
2C6C:  DATA 43,32
2C6E:  DATA 0D,00
2C70:  DATA 53,49
2C72:  DATA 4E,46
2C74:  DATA 55,4E
2C76:  DATA 43,49
2C78:  DATA 4F,4E
2C7A:  DATA 0D,00
2C7C:  DATA 0A,C0
2C7E:  DATA 20,02
2C80:  DATA 80,0D
2C82:  DATA 00,16
2C84:  DATA 00,AE
2C86:  DATA C4,00
2C88:  DATA D0,00
2C8A:  DATA DC,00
2C8C:  DATA E8,00
2C8E:  DATA F4,00
2C90:  DATA 00,01
2C92:  DATA 0C,01
2C94:  DATA 18,01
2C96:  DATA 24,01
2C98:  DATA 30,01
2C9A:  DATA 3C,01
2C9C:  DATA 06,01
2C9E:  DATA 48,56
2CA0:  DATA 35,2E
2CA2:  DATA 30,32
2CA4:  DATA 00,00
2CA6:  MOVLW  00
2CA8:  MOVWF  FF8
2CAA:  MOVLW  2B
2CAC:  MOVWF  FF7
2CAE:  MOVLW  FC
2CB0:  MOVWF  FF6
2CB2:  TBLRD*+
2CB4:  MOVF   FF5,W
2CB6:  MOVWF  00
2CB8:  XORLW  00
2CBA:  BZ    2CE2
2CBC:  TBLRD*+
2CBE:  MOVF   FF5,W
2CC0:  MOVWF  01
2CC2:  BTFSC  FE8.7
2CC4:  BRA    2CD0
2CC6:  ANDLW  0F
2CC8:  MOVWF  FEA
2CCA:  TBLRD*+
2CCC:  MOVFF  FF5,FE9
2CD0:  BTFSC  01.6
2CD2:  TBLRD*+
2CD4:  BTFSS  01.6
2CD6:  TBLRD*+
2CD8:  MOVFF  FF5,FEE
2CDC:  DCFSNZ 00,F
2CDE:  BRA    2CB2
2CE0:  BRA    2CD4
2CE2:  CLRF   FF8
.................... //Apaga entradas analogicas 
.................... setup_adc_ports(NO_ANALOGS); 
2CE4:  MOVF   FC1,W
2CE6:  ANDLW  C0
2CE8:  IORLW  0F
2CEA:  MOVWF  FC1
.................... setup_adc(ADC_OFF); 
2CEC:  BCF    FC2.0
.................... lcd_init();//inicia LCD 
2CEE:  GOTO   0476
.................... init_ext_eeprom();//Inicia EEPROM 
2CF2:  GOTO   04EA
.................... setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Configura timer1:Reloj interno, preescaler=8 
2CF6:  MOVLW  B5
2CF8:  MOVWF  FCD
.................... enable_interrupts(INT_TIMER1);//Habilito interrupcin particular del TIMER1 
2CFA:  BSF    F9D.0
.................... set_timer1(set_timer);//Setea cuenta para la interrupcion. 
2CFC:  MOVLW  E7
2CFE:  MOVWF  FCF
2D00:  MOVLW  96
2D02:  MOVWF  FCE
.................... disable_interrupts(INT_EXT);//desabilita interrupciones externas 
2D04:  BCF    FF2.4
.................... enable_interrupts(GLOBAL);//habilita interrupciones globales 
2D06:  MOVLW  C0
2D08:  IORWF  FF2,F
.................... ///**************************************************************************/// 
.................... ////////Confuguracion de PWM//////// 
.................... output_low(PIN_C2);//CCP1 
2D0A:  BCF    F94.2
2D0C:  BCF    F8B.2
.................... setup_ccp1(CCP_PWM); 
2D0E:  BCF    F94.2
2D10:  BCF    F8B.2
2D12:  MOVLW  0C
2D14:  MOVWF  FBD
.................... setup_timer_2(t2_div_By_1,131,1);//frecuencia 38khz 
2D16:  MOVLW  00
2D18:  IORLW  04
2D1A:  MOVWF  FCA
2D1C:  MOVLW  83
2D1E:  MOVWF  FCB
.................... //set_pwm1_duty(26);//(5%) alto 
.................... set_pwm1_duty(279);//(10%) Parte alta del ciclo  
2D20:  MOVLW  45
2D22:  MOVWF  FBE
2D24:  MOVF   FBD,W
2D26:  ANDLW  CF
2D28:  IORLW  30
2D2A:  MOVWF  FBD
.................... //////////////////////////////////// 
.................... ini=read_eeprom(100);//Carga estado de inicio 
2D2C:  MOVFF  FF2,186
2D30:  BCF    FF2.7
2D32:  MOVLW  64
2D34:  MOVWF  FA9
2D36:  BCF    FA6.6
2D38:  BCF    FA6.7
2D3A:  BSF    FA6.0
2D3C:  MOVF   FA8,W
2D3E:  MOVLB  1
2D40:  BTFSC  x86.7
2D42:  BSF    FF2.7
2D44:  MOVWF  40
.................... if(ini!=1){//Verifica si es la primera vez que se enciende el poste y graba configuracion inicial 
2D46:  DECFSZ 40,W
2D48:  BRA    2D4C
2D4A:  BRA    2D7E
....................    write_eeprom(100,1);//Graba inicio 
2D4C:  MOVF   FF2,W
2D4E:  MOVWF  00
2D50:  BCF    FF2.7
2D52:  MOVLW  64
2D54:  MOVWF  FA9
2D56:  MOVLW  01
2D58:  MOVWF  FA8
2D5A:  BCF    FA6.6
2D5C:  BCF    FA6.7
2D5E:  BSF    FA6.2
2D60:  MOVLB  F
2D62:  MOVLW  55
2D64:  MOVWF  FA7
2D66:  MOVLW  AA
2D68:  MOVWF  FA7
2D6A:  BSF    FA6.1
2D6C:  BTFSC  FA6.1
2D6E:  BRA    2D6C
2D70:  BCF    FA6.2
2D72:  MOVF   00,W
2D74:  IORWF  FF2,F
....................    limpiar();//pone en 0 el registro de cuentas almacenadas. 
2D76:  MOVLB  0
2D78:  CALL   0CD0
2D7C:  MOVLB  1
.................... } 
....................  
.................... //llaves();//Graba instrucciones de control en eeprom 
.................... ///////////////////////////////lee que tienen la memoria eeprom////////////////////////////////// 
.................... //rd_eeprom_inicio(); 
.................... ///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... entraron_total();//carga el total de entradas registradas 
2D7E:  MOVLB  0
2D80:  GOTO   0D3C
.................... salieron_total();//carga el total de salidas registradas 
2D84:  GOTO   0D96
.................... ent1=ent2=ent3=ent4=ent5=ent6=0;//inicia en 0 variables de estado de sensores 
2D88:  CLRF   5A
2D8A:  MOVFF  5A,59
2D8E:  MOVFF  59,58
2D92:  MOVFF  58,57
2D96:  MOVFF  57,56
2D9A:  MOVFF  56,55
.................... tim_p1=tim_p2=tim_p3=0;//inicia en 0 las cuentas para detectar sensores bloqueados 
2D9E:  CLRF   xA6
2DA0:  CLRF   xA5
2DA2:  MOVFF  A6,A4
2DA6:  MOVFF  A5,A3
2DAA:  MOVFF  A4,A2
2DAE:  MOVFF  A3,A1
.................... en_b1=en_b2=en_b3=0;//bandera de pares bloqueados 
2DB2:  CLRF   xA0
2DB4:  MOVFF  A0,9F
2DB8:  MOVFF  9F,9E
.................... time_envio=0;//inicia en 0 cuenta para transmitir datos 
2DBC:  CLRF   xAA
2DBE:  CLRF   xA9
.................... if(input(frente) ) {//revisa si es maestro (1) o escalvo (2) 
2DC0:  BSF    F95.2
2DC2:  BTFSS  F83.2
2DC4:  BRA    2DD0
....................    master=1; 
2DC6:  MOVLW  01
2DC8:  MOVWF  45
....................    size_s=29; 
2DCA:  MOVLW  1D
2DCC:  MOVWF  22
.................... } 
2DCE:  BRA    2DD6
.................... else { 
....................    master=0; 
2DD0:  CLRF   45
....................    size_s=15; 
2DD2:  MOVLW  0F
2DD4:  MOVWF  22
.................... } 
.................... lcd_cuentas();//Escribe texto base en LCD 
2DD6:  CALL   0A18
.................... cta_bloq1=read_ext_eeprom(9);//carga bloqueos acumulados en par1 
2DDA:  MOVLB  1
2DDC:  CLRF   x8B
2DDE:  MOVLW  09
2DE0:  MOVWF  x8A
2DE2:  MOVLB  0
2DE4:  CALL   0728
2DE8:  MOVFF  01,52
.................... cta_bloq2=read_ext_eeprom(10);//carga bloqueos acumulados en par2 
2DEC:  MOVLB  1
2DEE:  CLRF   x8B
2DF0:  MOVLW  0A
2DF2:  MOVWF  x8A
2DF4:  MOVLB  0
2DF6:  CALL   0728
2DFA:  MOVFF  01,53
.................... cta_bloq3=read_ext_eeprom(11);//carga bloqueos acumulados en par3 
2DFE:  MOVLB  1
2E00:  CLRF   x8B
2E02:  MOVLW  0B
2E04:  MOVWF  x8A
2E06:  MOVLB  0
2E08:  CALL   0728
2E0C:  MOVFF  01,54
.................... int tem_res; 
.................... tem_res=input(rst_cta);//inicializa variable de reset de cuenta fisico 
2E10:  BSF    F95.3
2E12:  MOVLB  1
2E14:  CLRF   x84
2E16:  BTFSC  F83.3
2E18:  INCF   x84,F
.................... j=0; 
2E1A:  CLRF   43
.................... flag_enviar=0; 
2E1C:  CLRF   46
.................... salian=0; 
2E1E:  CLRF   3D
2E20:  CLRF   3C
.................... enable_interrupts(INT_RDA);//habilita interrupcion serial 
2E22:  BSF    F9D.5
.................... setup_wdt(WDT_ON);//habilita watch dog 
2E24:  BSF    FD1.0
.................... sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
2E26:  MOVLB  0
2E28:  CLRF   x68
2E2A:  CLRF   x67
2E2C:  MOVFF  68,66
2E30:  MOVFF  67,65
2E34:  MOVFF  66,64
2E38:  MOVFF  65,63
2E3C:  MOVFF  64,62
2E40:  MOVFF  63,61
2E44:  MOVFF  62,60
2E48:  MOVFF  61,5F
2E4C:  MOVFF  60,5E
2E50:  MOVFF  5F,5D
.................... tem_entraront=tem_salieront=0; 
2E54:  CLRF   x95
2E56:  CLRF   x94
2E58:  MOVFF  95,93
2E5C:  MOVFF  94,92
.................... error=0; 
2E60:  CLRF   23
.................... reset();//Revisa causa de inicio del pic 
2E62:  GOTO   0E12
.................... transmitir=0; 
2E66:  CLRF   24
.................... output_low(salida02); 
2E68:  BCF    F94.4
2E6A:  BCF    F8B.4
.................... sub_atras=baj_atras=0; 
2E6C:  CLRF   37
2E6E:  CLRF   36
2E70:  MOVFF  37,35
2E74:  MOVFF  36,34
.................... clear_lcd1=0; 
2E78:  CLRF   xAB
.................... while(TRUE){ 
.................... ///////////////////////preuba comunicacion serial con poste trasero/////////////// 
....................  //fprintf(monitor,"SOLICITADO");//4 
....................  //delay_ms(100); 
....................  if(y==1){ 
2E7A:  DECFSZ xAD,W
2E7C:  BRA    2E84
....................   //fprintf(monitor,"XX=%c%c%c%c%c%c%c",XX[0],XX[1],XX[2],XX[3],XX[4],XX[5],XX[6]); 
....................   //fprintf(monitor,"XX=%s",XX); 
....................   enable_interrupts(GLOBAL);//habilita interrupciones globales 
2E7E:  MOVLW  C0
2E80:  IORWF  FF2,F
....................   y=0; 
2E82:  CLRF   xAD
....................  } 
....................   
.................... ////////////////////////////////////////////////////////////////////////////////// 
....................    if(tem_res!=input(rst_cta) ){//BOTON DE RESET DE CUENTA 
2E84:  BSF    F95.3
2E86:  MOVLW  00
2E88:  BTFSC  F83.3
2E8A:  MOVLW  01
2E8C:  MOVLB  1
2E8E:  SUBWF  x84,W
2E90:  BZ    2EDA
....................       delay_ms(50); 
2E92:  MOVLW  32
2E94:  MOVWF  x90
2E96:  MOVLB  0
2E98:  CALL   03BE
....................       if(tem_res!=input(rst_cta) ){ 
2E9C:  BSF    F95.3
2E9E:  MOVLW  00
2EA0:  BTFSC  F83.3
2EA2:  MOVLW  01
2EA4:  MOVLB  1
2EA6:  SUBWF  x84,W
2EA8:  BZ    2EDA
....................          tem_res=input(rst_cta); 
2EAA:  BSF    F95.3
2EAC:  CLRF   x84
2EAE:  BTFSC  F83.3
2EB0:  INCF   x84,F
....................          if( (master==1)&&(tem_res==0) ) { 
2EB2:  DECFSZ 45,W
2EB4:  BRA    2EDA
2EB6:  MOVF   x84,F
2EB8:  BNZ   2EDA
....................             fprintf(monitor,"BORRAR_ALL\r"); 
2EBA:  MOVLW  3A
2EBC:  MOVWF  FF6
2EBE:  MOVLW  02
2EC0:  MOVWF  FF7
2EC2:  MOVLB  0
2EC4:  CALL   0DF0
....................             printf(lcd_putc,"\fBORRAR_ALL"); 
2EC8:  MOVLW  46
2ECA:  MOVWF  FF6
2ECC:  MOVLW  02
2ECE:  MOVWF  FF7
2ED0:  CALL   09F8
....................             limpiar(); 
2ED4:  CALL   0CD0
2ED8:  MOVLB  1
....................          } 
....................       } 
....................    } 
.................... //!    
....................    if( kbhit(GPS) && master ){//escucha gsm 
2EDA:  BTFSC  F82.1
2EDC:  BRA    2F5E
2EDE:  MOVF   45,F
2EE0:  BZ    2F5E
....................        i=0; // CONTADOR DE ARREGLO SERIAL INICIADO 
2EE2:  CLRF   41
....................        XX[i] = fgetc(GPS); 
2EE4:  CLRF   03
2EE6:  MOVF   41,W
2EE8:  ADDLW  4E
2EEA:  MOVWF  FE9
2EEC:  MOVLW  01
2EEE:  ADDWFC 03,W
2EF0:  MOVWF  FEA
2EF2:  MOVFF  FEA,189
2EF6:  MOVFF  FE9,188
2EFA:  MOVLB  0
2EFC:  CALL   0E4A
2F00:  MOVFF  189,FEA
2F04:  MOVFF  188,FE9
2F08:  MOVFF  01,FEF
....................        i++; 
2F0C:  INCF   41,F
....................        if( (XX[0]>=65)&&(XX[0]<=90) ){//validar no sea ruido 
2F0E:  MOVLB  1
2F10:  MOVF   x4E,W
2F12:  SUBLW  40
2F14:  BC    2F5E
2F16:  MOVF   x4E,W
2F18:  SUBLW  5A
2F1A:  BNC   2F5E
....................           while (i <= word_size){ 
2F1C:  MOVF   41,W
2F1E:  SUBLW  0A
2F20:  BNC   2F50
....................                 XX[i] = fgetc(GPS); 
2F22:  CLRF   03
2F24:  MOVF   41,W
2F26:  ADDLW  4E
2F28:  MOVWF  FE9
2F2A:  MOVLW  01
2F2C:  ADDWFC 03,W
2F2E:  MOVWF  FEA
2F30:  MOVFF  FEA,189
2F34:  MOVFF  FE9,188
2F38:  MOVLB  0
2F3A:  CALL   0E4A
2F3E:  MOVFF  189,FEA
2F42:  MOVFF  188,FE9
2F46:  MOVFF  01,FEF
....................                 i++; 
2F4A:  INCF   41,F
2F4C:  MOVLB  1
2F4E:  BRA    2F1C
....................           } 
....................           if(XX[1]=='R') XX[0]='G'; 
2F50:  MOVF   x4F,W
2F52:  SUBLW  52
2F54:  BNZ   2F5A
2F56:  MOVLW  47
2F58:  MOVWF  x4E
....................           j=1; 
2F5A:  MOVLW  01
2F5C:  MOVWF  43
....................        }/// 
....................       // sub_cta1=sub_cta2=sub_cta3=sub_cta4=sub_cta5=sub_cta6=0; 
....................    }//end gps 
.................... //! 
....................    if(j==1){//Revisa si hubo datos por cualquiera de los 2 puertos seriales 
2F5E:  DECFSZ 43,W
2F60:  BRA    3100
....................        
....................       // fprintf(monitor,"%s",XX);//4 
....................        
....................       rd_eeprom();//valida dato recibido para ver si es una palabra de control 
2F62:  MOVLB  0
2F64:  GOTO   0EC0
....................       //int caso_valor = evaluar_string("BORRAR_ALL\r"); 
....................       //fprintf(monitor,"XX:%s",XX); 
....................       int caso_valor = evaluar_string(XX); 
2F68:  MOVLW  01
2F6A:  MOVLB  1
2F6C:  MOVWF  x87
2F6E:  MOVLW  4E
2F70:  MOVWF  x86
2F72:  MOVLB  0
2F74:  GOTO   0FE4
2F78:  MOVFF  01,185
....................       //int caso_valor; 
....................       //evaluar_string('B'); 
....................       //char textosearch[]= "PASAJEROS:"; 
....................      // fprintf(monitor,"compare = %s", strstr(XX,textosearch)); 
....................       //if((strstr(XX,textosearch))==0)b=5; 
....................       lcd_gotoxy(9,1); 
2F7C:  MOVLW  09
2F7E:  MOVLB  1
2F80:  MOVWF  x90
2F82:  MOVLW  01
2F84:  MOVWF  x91
2F86:  MOVLB  0
2F88:  CALL   0822
....................       //printf(lcd_putc,"%Ld ",b);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................       printf(lcd_putc,"%d ",caso_valor);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
2F8C:  MOVFF  185,186
2F90:  MOVLW  18
2F92:  MOVLB  1
2F94:  MOVWF  x87
2F96:  MOVLB  0
2F98:  CALL   106A
2F9C:  MOVLW  20
2F9E:  MOVLB  1
2FA0:  MOVWF  x8F
2FA2:  MOVLB  0
2FA4:  CALL   0874
....................  
....................        
....................       //switch (b) { 
....................       switch (caso_valor) { 
2FA8:  MOVLW  01
2FAA:  MOVLB  1
2FAC:  SUBWF  x85,W
2FAE:  ADDLW  F8
2FB0:  BTFSC  FD8.0
2FB2:  BRA    30DE
2FB4:  ADDLW  08
2FB6:  MOVLB  0
2FB8:  GOTO   3336
....................           case 1: {//Se pone en 0 la cuenta 
....................                   limpiar(); 
2FBC:  CALL   0CD0
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
2FC0:  DECFSZ 45,W
2FC2:  BRA    2FD0
2FC4:  MOVLW  52
2FC6:  MOVWF  FF6
2FC8:  MOVLW  02
2FCA:  MOVWF  FF7
2FCC:  CALL   0DF0
....................                   break;} 
2FD0:  MOVLB  1
2FD2:  BRA    30DE
2FD4:  MOVLB  0
....................           case 2: {//Se hace solicitud de cuenta del poste trasero 
....................                   solicitar(); 
2FD6:  CALL   112E
....................                   break;} 
2FDA:  MOVLB  1
2FDC:  BRA    30DE
2FDE:  MOVLB  0
....................           case 3: {//Se pone en 0 la cuenta por peticion del GPRS 
....................                   if(master==1) fprintf(GPS,"RESET_OK\r\n");//confirma a gsm  
2FE0:  DECFSZ 45,W
2FE2:  BRA    2FF0
2FE4:  MOVLW  5E
2FE6:  MOVWF  FF6
2FE8:  MOVLW  02
2FEA:  MOVWF  FF7
2FEC:  GOTO   1194
....................                   delay_ms(1000); 
2FF0:  MOVLW  04
2FF2:  MOVLB  1
2FF4:  MOVWF  x86
2FF6:  MOVLW  FA
2FF8:  MOVWF  x90
2FFA:  MOVLB  0
2FFC:  CALL   03BE
3000:  MOVLB  1
3002:  DECFSZ x86,F
3004:  BRA    2FF6
....................                   limpiar(); 
3006:  MOVLB  0
3008:  CALL   0CD0
....................                   if(master==1) fprintf(monitor,"BORRAR_ALL\r");//4 
300C:  DECFSZ 45,W
300E:  BRA    301C
3010:  MOVLW  6A
3012:  MOVWF  FF6
3014:  MOVLW  02
3016:  MOVWF  FF7
3018:  CALL   0DF0
....................                   break;} 
301C:  MOVLB  1
301E:  BRA    30DE
3020:  MOVLB  0
....................           case 4: {//ver pasaje total de este acceso (contador atras) 
....................                   envio_master(); 
3022:  CALL   1380
....................                   break;} 
3026:  MOVLB  1
3028:  BRA    30DE
302A:  MOVLB  0
....................           case 5: {//envia a GPS pasaje total actual de ambos accesos (recibe cuenta de atras y suma) 
....................                   flag_enviar=0; 
302C:  CLRF   46
....................                   enviop1(); 
302E:  GOTO   1458
....................                   transmitir=1; 
3032:  MOVLW  01
3034:  MOVWF  24
....................                   lcd_gotoxy(9,4); 
3036:  MOVLW  09
3038:  MOVLB  1
303A:  MOVWF  x90
303C:  MOVLW  04
303E:  MOVWF  x91
3040:  MOVLB  0
3042:  CALL   0822
....................                   lcd_putc("C2OK"); 
3046:  MOVLW  76
3048:  MOVWF  FF6
304A:  MOVLW  02
304C:  MOVWF  FF7
304E:  CALL   09F8
....................                   break;} 
3052:  MOVLB  1
3054:  BRA    30DE
3056:  MOVLB  0
....................           case 6: {//TEST DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
3058:  MOVLW  01
305A:  MOVWF  xAB
....................                   time_lcd1=0; 
305C:  CLRF   xAC
....................                   lcd_gotoxy(9,3); 
305E:  MOVLW  09
3060:  MOVLB  1
3062:  MOVWF  x90
3064:  MOVLW  03
3066:  MOVWF  x91
3068:  MOVLB  0
306A:  CALL   0822
....................                   lcd_putc("C1OK"); 
306E:  MOVLW  7C
3070:  MOVWF  FF6
3072:  MOVLW  02
3074:  MOVWF  FF7
3076:  CALL   09F8
....................                   fprintf(monitor,"SERIAL_TOK\r");// 
307A:  MOVLW  82
307C:  MOVWF  FF6
307E:  MOVLW  02
3080:  MOVWF  FF7
3082:  CALL   0DF0
....................                   break;} 
3086:  MOVLB  1
3088:  BRA    30DE
308A:  MOVLB  0
....................           case 7: {//CONFIRMACION DE COMUNICACION SERIAL 
....................                   clear_lcd1=1; 
308C:  MOVLW  01
308E:  MOVWF  xAB
....................                   time_lcd1=0; 
3090:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
3092:  MOVLW  09
3094:  MOVLB  1
3096:  MOVWF  x90
3098:  MOVLW  04
309A:  MOVWF  x91
309C:  MOVLB  0
309E:  CALL   0822
....................                   lcd_putc("C2OK"); 
30A2:  MOVLW  8E
30A4:  MOVWF  FF6
30A6:  MOVLW  02
30A8:  MOVWF  FF7
30AA:  CALL   09F8
....................                   break;} 
30AE:  MOVLB  1
30B0:  BRA    30DE
30B2:  MOVLB  0
....................           case 8: {//Suben por atras 
....................                   clear_lcd1=1; 
30B4:  MOVLW  01
30B6:  MOVWF  xAB
....................                   time_lcd1=0; 
30B8:  CLRF   xAC
....................                   lcd_gotoxy(9,4); 
30BA:  MOVLW  09
30BC:  MOVLB  1
30BE:  MOVWF  x90
30C0:  MOVLW  04
30C2:  MOVWF  x91
30C4:  MOVLB  0
30C6:  CALL   0822
....................                   lcd_putc("Sub2"); 
30CA:  MOVLW  94
30CC:  MOVWF  FF6
30CE:  MOVLW  02
30D0:  MOVWF  FF7
30D2:  CALL   09F8
....................                   break;} 
30D6:  MOVLB  1
30D8:  BRA    30DE
30DA:  MOVLB  0
30DC:  MOVLB  1
....................       }//end switch 
....................       memset(XX, 0, sizeof(XX) ); 
30DE:  MOVLW  01
30E0:  MOVWF  FEA
30E2:  MOVLW  4E
30E4:  MOVWF  FE9
30E6:  CLRF   00
30E8:  CLRF   02
30EA:  MOVLW  1D
30EC:  MOVWF  01
30EE:  MOVLB  0
30F0:  CALL   143E
....................       time_clr=0; 
30F4:  CLRF   3F
30F6:  CLRF   3E
....................       f_clr=1; 
30F8:  MOVLW  01
30FA:  MOVWF  47
....................       j=0; 
30FC:  CLRF   43
30FE:  MOVLB  1
....................    } 
....................    //if( (time_envio>=180)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
....................     if( (time_envio>=10)&&(master) ){//Revisa tiempo para transmitir por GPRS (time_envio esta en segundos, 180s/60 = 3min) 
3100:  MOVLB  0
3102:  MOVF   xAA,F
3104:  BNZ   310C
3106:  MOVF   xA9,W
3108:  SUBLW  09
310A:  BC    3114
310C:  MOVF   45,F
310E:  BZ    3114
....................          solicitar(); 
3110:  CALL   112E
....................          
....................    } 
....................    if( (clear_lcd1)&&(time_lcd1>=10) ){//cronometro para limpiar notificaciones LCD 
3114:  MOVF   xAB,F
3116:  BZ    3174
3118:  MOVF   xAC,W
311A:  SUBLW  09
311C:  BC    3174
....................       clear_lcd1=0; 
311E:  CLRF   xAB
....................       lcd_gotoxy(9,1); 
3120:  MOVLW  09
3122:  MOVLB  1
3124:  MOVWF  x90
3126:  MOVLW  01
3128:  MOVWF  x91
312A:  MOVLB  0
312C:  CALL   0822
....................       lcd_putc("    "); 
3130:  MOVLW  9A
3132:  MOVWF  FF6
3134:  MOVLW  02
3136:  MOVWF  FF7
3138:  CALL   09F8
....................       lcd_gotoxy(9,3); 
313C:  MOVLW  09
313E:  MOVLB  1
3140:  MOVWF  x90
3142:  MOVLW  03
3144:  MOVWF  x91
3146:  MOVLB  0
3148:  CALL   0822
....................       lcd_putc("    "); 
314C:  MOVLW  A0
314E:  MOVWF  FF6
3150:  MOVLW  02
3152:  MOVWF  FF7
3154:  CALL   09F8
....................       lcd_gotoxy(9,4); 
3158:  MOVLW  09
315A:  MOVLB  1
315C:  MOVWF  x90
315E:  MOVLW  04
3160:  MOVWF  x91
3162:  MOVLB  0
3164:  CALL   0822
....................       lcd_putc("    "); 
3168:  MOVLW  A6
316A:  MOVWF  FF6
316C:  MOVLW  02
316E:  MOVWF  FF7
3170:  CALL   09F8
....................    } 
....................     
....................    if( (flag_enviar)&&(cta_enviar>=2000)&&(master) ) envia2();//Si el poste esclavo no contesta enviar sin conexion 
3174:  MOVF   46,F
3176:  BZ    3190
3178:  MOVF   4F,W
317A:  SUBLW  06
317C:  BC    3190
317E:  XORLW  FF
3180:  BNZ   3188
3182:  MOVF   4E,W
3184:  SUBLW  CF
3186:  BC    3190
3188:  MOVF   45,F
318A:  BTFSS  FD8.2
318C:  GOTO   1740
....................    if(transmitir) envio();//cuando el esclavo reporto su cuenta, maestro prepara paquete para mandar a la nube 
3190:  MOVF   24,F
3192:  BTFSC  FD8.2
3194:  BRA    319A
3196:  GOTO   1936
....................     
....................    if( (bloq_p1)&&(tim_p1>=time_bloqueo)&&(!en_b1) ) {//bloqueo de par 1 por ms de X segundos 
319A:  MOVF   x9B,F
319C:  BZ    320A
319E:  MOVF   xA2,W
31A0:  SUBLW  00
31A2:  BC    320A
31A4:  XORLW  FF
31A6:  BNZ   31AE
31A8:  MOVF   xA1,W
31AA:  SUBLW  F3
31AC:  BC    320A
31AE:  MOVF   x9E,F
31B0:  BNZ   320A
....................        bloq_p1=0;//bandera de par de sensores bloqueados detectando, no significa contador bloqueado 
31B2:  CLRF   x9B
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){//si no habia un bloqueo antes 
31B4:  MOVF   x9E,F
31B6:  BNZ   3206
31B8:  MOVF   x9F,F
31BA:  BNZ   3206
31BC:  MOVF   xA0,F
31BE:  BNZ   3206
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
31C0:  MOVLW  0A
31C2:  MOVLB  1
31C4:  MOVWF  x90
31C6:  MOVLW  01
31C8:  MOVWF  x91
31CA:  MOVLB  0
31CC:  CALL   0822
....................             lcd_putc("BL"); 
31D0:  MOVLW  AC
31D2:  MOVWF  FF6
31D4:  MOVLW  02
31D6:  MOVWF  FF7
31D8:  CALL   09F8
....................             cta_bloq1++; 
31DC:  INCF   52,F
....................             write_ext_eeprom(9,cta_bloq1);//bloq1 
31DE:  MOVLB  1
31E0:  CLRF   x8B
31E2:  MOVLW  09
31E4:  MOVWF  x8A
31E6:  MOVFF  52,18C
31EA:  MOVLB  0
31EC:  CALL   0568
....................             if( (master==1)&&(j==0) ) solicitar(); 
31F0:  DECFSZ 45,W
31F2:  BRA    31FE
31F4:  MOVF   43,F
31F6:  BNZ   31FE
31F8:  CALL   112E
31FC:  BRA    3206
....................             else if(j==0) envio_master(); 
31FE:  MOVF   43,F
3200:  BTFSC  FD8.2
3202:  CALL   1380
....................        } 
....................        en_b1=1;//bandera de bloqueo detectado en par 1 
3206:  MOVLW  01
3208:  MOVWF  x9E
....................    } 
....................    if( (bloq_p2)&&(tim_p2>=time_bloqueo)&&(!en_b2) ) {//bloqueo de par 2 por ms de X segundos 
320A:  MOVF   x9C,F
320C:  BZ    327A
320E:  MOVF   xA4,W
3210:  SUBLW  00
3212:  BC    327A
3214:  XORLW  FF
3216:  BNZ   321E
3218:  MOVF   xA3,W
321A:  SUBLW  F3
321C:  BC    327A
321E:  MOVF   x9F,F
3220:  BNZ   327A
....................        bloq_p2=0; 
3222:  CLRF   x9C
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3224:  MOVF   x9E,F
3226:  BNZ   3276
3228:  MOVF   x9F,F
322A:  BNZ   3276
322C:  MOVF   xA0,F
322E:  BNZ   3276
....................            lcd_gotoxy(10,1);//cronometro para limpiar 
3230:  MOVLW  0A
3232:  MOVLB  1
3234:  MOVWF  x90
3236:  MOVLW  01
3238:  MOVWF  x91
323A:  MOVLB  0
323C:  CALL   0822
....................            lcd_putc("BL"); 
3240:  MOVLW  B0
3242:  MOVWF  FF6
3244:  MOVLW  02
3246:  MOVWF  FF7
3248:  CALL   09F8
....................            cta_bloq2++; 
324C:  INCF   53,F
....................            write_ext_eeprom(10,cta_bloq2);//bloq2 
324E:  MOVLB  1
3250:  CLRF   x8B
3252:  MOVLW  0A
3254:  MOVWF  x8A
3256:  MOVFF  53,18C
325A:  MOVLB  0
325C:  CALL   0568
....................            if( (master==1)&&(j==0) ) solicitar(); 
3260:  DECFSZ 45,W
3262:  BRA    326E
3264:  MOVF   43,F
3266:  BNZ   326E
3268:  CALL   112E
326C:  BRA    3276
....................            else if(j==0) envio_master(); 
326E:  MOVF   43,F
3270:  BTFSC  FD8.2
3272:  CALL   1380
....................        } 
....................        en_b2=1; 
3276:  MOVLW  01
3278:  MOVWF  x9F
....................    } 
....................    if( (bloq_p3)&&(tim_p3>=time_bloqueo)&&(!en_b3) ) {//bloqueo de par 3 por ms de X segundos 
327A:  MOVF   x9D,F
327C:  BZ    32EA
327E:  MOVF   xA6,W
3280:  SUBLW  00
3282:  BC    32EA
3284:  XORLW  FF
3286:  BNZ   328E
3288:  MOVF   xA5,W
328A:  SUBLW  F3
328C:  BC    32EA
328E:  MOVF   xA0,F
3290:  BNZ   32EA
....................        bloq_p3=0; 
3292:  CLRF   x9D
....................        if( (!en_b1)&&(!en_b2)&&(!en_b3) ){ 
3294:  MOVF   x9E,F
3296:  BNZ   32E6
3298:  MOVF   x9F,F
329A:  BNZ   32E6
329C:  MOVF   xA0,F
329E:  BNZ   32E6
....................             lcd_gotoxy(10,1);//cronometro para limpiar 
32A0:  MOVLW  0A
32A2:  MOVLB  1
32A4:  MOVWF  x90
32A6:  MOVLW  01
32A8:  MOVWF  x91
32AA:  MOVLB  0
32AC:  CALL   0822
....................             lcd_putc("BL"); 
32B0:  MOVLW  B4
32B2:  MOVWF  FF6
32B4:  MOVLW  02
32B6:  MOVWF  FF7
32B8:  CALL   09F8
....................             cta_bloq3++; 
32BC:  INCF   54,F
....................             write_ext_eeprom(11,cta_bloq3);//bloq3 
32BE:  MOVLB  1
32C0:  CLRF   x8B
32C2:  MOVLW  0B
32C4:  MOVWF  x8A
32C6:  MOVFF  54,18C
32CA:  MOVLB  0
32CC:  CALL   0568
....................             if( (master==1)&&(j==0) ) solicitar(); 
32D0:  DECFSZ 45,W
32D2:  BRA    32DE
32D4:  MOVF   43,F
32D6:  BNZ   32DE
32D8:  CALL   112E
32DC:  BRA    32E6
....................             else if(j==0) envio_master(); 
32DE:  MOVF   43,F
32E0:  BTFSC  FD8.2
32E2:  CALL   1380
....................        } 
....................        en_b3=1; 
32E6:  MOVLW  01
32E8:  MOVWF  xA0
....................    }//end deteccion 
....................    if( (!bloq_p3)&&(!bloq_p2)&&(!bloq_p1) ){//Si todos los pares estan desbloqueados limpia estado de bloqueo LCD 
32EA:  MOVF   x9D,F
32EC:  BNZ   3312
32EE:  MOVF   x9C,F
32F0:  BNZ   3312
32F2:  MOVF   x9B,F
32F4:  BNZ   3312
....................       lcd_gotoxy(10,1); 
32F6:  MOVLW  0A
32F8:  MOVLB  1
32FA:  MOVWF  x90
32FC:  MOVLW  01
32FE:  MOVWF  x91
3300:  MOVLB  0
3302:  CALL   0822
....................       lcd_putc("  "); 
3306:  MOVLW  B8
3308:  MOVWF  FF6
330A:  MOVLW  02
330C:  MOVWF  FF7
330E:  CALL   09F8
....................    } 
....................     
....................    if( (time_clr>=900)&&(f_clr) ){//refresca LCD 
3312:  MOVF   3F,W
3314:  SUBLW  02
3316:  BC    332C
3318:  XORLW  FF
331A:  BNZ   3322
331C:  MOVF   3E,W
331E:  SUBLW  83
3320:  BC    332C
3322:  MOVF   47,F
3324:  BZ    332C
....................         lcd_cuentas(); 
3326:  CALL   0A18
....................          f_clr=0; 
332A:  CLRF   47
....................    } 
....................    sensores();//Revisa estado de los sensores 
332C:  GOTO   27D4
....................        
....................    restart_wdt(); 
3330:  CLRWDT
3332:  BRA    2E7A
....................  }//end true 
.................... }//end main 
....................  
3334:  SLEEP 
.................... void solicitar(){//Solicita cuenta al poste esclavo 
....................    fprintf(monitor,"SOLICITADO\r");//4 
*
112E:  MOVLW  BC
1130:  MOVWF  FF6
1132:  MOVLW  02
1134:  MOVWF  FF7
1136:  RCALL  0DF0
....................    time_envio=0; 
1138:  CLRF   xAA
113A:  CLRF   xA9
....................    flag_enviar=1; 
113C:  MOVLW  01
113E:  MOVWF  46
....................    cta_enviar=0; 
1140:  CLRF   4F
1142:  CLRF   4E
1144:  RETURN 0
.................... } 
....................  
.................... void envio_master(){//reporta al maestro 
....................     int16 envit; 
....................     envit=(entraront + salieront)/2; 
*
1380:  MOVF   x8C,W
1382:  ADDWF  x8A,W
1384:  MOVLB  1
1386:  MOVWF  x88
1388:  MOVLB  0
138A:  MOVF   x8D,W
138C:  ADDWFC x8B,W
138E:  MOVLB  1
1390:  MOVWF  x89
1392:  BCF    FD8.0
1394:  RRCF   x89,W
1396:  MOVWF  x87
1398:  RRCF   x88,W
139A:  MOVWF  x86
....................     cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
139C:  MOVF   53,W
139E:  ADDWF  52,W
13A0:  ADDWF  54,W
13A2:  MOVWF  4C
13A4:  CLRF   4D
....................     clear_lcd1=1; 
13A6:  MOVLW  01
13A8:  MOVLB  0
13AA:  MOVWF  xAB
....................     time_lcd1=0; 
13AC:  CLRF   xAC
....................     lcd_gotoxy(9,3);//cronometro para limpiar 
13AE:  MOVLW  09
13B0:  MOVLB  1
13B2:  MOVWF  x90
13B4:  MOVLW  03
13B6:  MOVWF  x91
13B8:  MOVLB  0
13BA:  CALL   0822
....................     lcd_putc(0xAB); 
13BE:  MOVLW  AB
13C0:  MOVLB  1
13C2:  MOVWF  x8F
13C4:  MOVLB  0
13C6:  CALL   0874
....................     fprintf(monitor,"PASAJEROS:%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
13CA:  MOVLW  C8
13CC:  MOVWF  FF6
13CE:  MOVLW  02
13D0:  MOVWF  FF7
13D2:  MOVLW  0A
13D4:  MOVLB  1
13D6:  MOVWF  x88
13D8:  MOVLB  0
13DA:  BRA    11B6
13DC:  MOVLW  0A
13DE:  MOVWF  FE9
13E0:  MOVFF  8B,189
13E4:  MOVFF  8A,188
13E8:  RCALL  11E2
13EA:  MOVLW  2F
13EC:  BTFSS  F9E.4
13EE:  BRA    13EC
13F0:  MOVWF  FAD
13F2:  MOVLW  0A
13F4:  MOVWF  FE9
13F6:  MOVFF  8D,189
13FA:  MOVFF  8C,188
13FE:  RCALL  11E2
1400:  MOVLW  2F
1402:  BTFSS  F9E.4
1404:  BRA    1402
1406:  MOVWF  FAD
1408:  MOVLW  0B
140A:  MOVWF  FE9
140C:  MOVFF  4D,189
1410:  MOVFF  4C,188
1414:  RCALL  11E2
1416:  MOVLW  2F
1418:  BTFSS  F9E.4
141A:  BRA    1418
141C:  MOVWF  FAD
141E:  MOVLW  09
1420:  MOVWF  FE9
1422:  MOVFF  187,189
1426:  MOVFF  186,188
142A:  BRA    12CC
142C:  MOVLW  2F
142E:  BTFSS  F9E.4
1430:  BRA    142E
1432:  MOVWF  FAD
1434:  MOVLW  0D
1436:  BTFSS  F9E.4
1438:  BRA    1436
143A:  MOVWF  FAD
143C:  RETURN 0
....................      //fprintf(monitor,"PASAJEROS:\r"); 
....................      //fprintf(monitor,"PASAJERO\r-%04Ld/%04Ld/%03Ld/%04Lu/\r",entraront,salieront,cta_bloqueo,envit ); 
.................... } 
....................  
.................... int convertir_to_entero(char *cadena) { 
*
188E:  MOVLB  1
1890:  CLRF   x88
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
1892:  MOVF   x86,W
1894:  SUBLW  30
1896:  BNZ   18A0
1898:  MOVF   x87,F
189A:  BNZ   18A0
189C:  CLRF   x88
189E:  BRA    192E
....................    else if(cadena=='1') valor=1; 
18A0:  MOVF   x86,W
18A2:  SUBLW  31
18A4:  BNZ   18B0
18A6:  MOVF   x87,F
18A8:  BNZ   18B0
18AA:  MOVLW  01
18AC:  MOVWF  x88
18AE:  BRA    192E
....................    else if(cadena=='2') valor=2; 
18B0:  MOVF   x86,W
18B2:  SUBLW  32
18B4:  BNZ   18C0
18B6:  MOVF   x87,F
18B8:  BNZ   18C0
18BA:  MOVLW  02
18BC:  MOVWF  x88
18BE:  BRA    192E
....................    else if(cadena=='3') valor=3; 
18C0:  MOVF   x86,W
18C2:  SUBLW  33
18C4:  BNZ   18D0
18C6:  MOVF   x87,F
18C8:  BNZ   18D0
18CA:  MOVLW  03
18CC:  MOVWF  x88
18CE:  BRA    192E
....................    else if(cadena=='4') valor=4; 
18D0:  MOVF   x86,W
18D2:  SUBLW  34
18D4:  BNZ   18E0
18D6:  MOVF   x87,F
18D8:  BNZ   18E0
18DA:  MOVLW  04
18DC:  MOVWF  x88
18DE:  BRA    192E
....................    else if(cadena=='5') valor=5; 
18E0:  MOVF   x86,W
18E2:  SUBLW  35
18E4:  BNZ   18F0
18E6:  MOVF   x87,F
18E8:  BNZ   18F0
18EA:  MOVLW  05
18EC:  MOVWF  x88
18EE:  BRA    192E
....................    else if(cadena=='6') valor=6; 
18F0:  MOVF   x86,W
18F2:  SUBLW  36
18F4:  BNZ   1900
18F6:  MOVF   x87,F
18F8:  BNZ   1900
18FA:  MOVLW  06
18FC:  MOVWF  x88
18FE:  BRA    192E
....................    else if(cadena=='7') valor=7; 
1900:  MOVF   x86,W
1902:  SUBLW  37
1904:  BNZ   1910
1906:  MOVF   x87,F
1908:  BNZ   1910
190A:  MOVLW  07
190C:  MOVWF  x88
190E:  BRA    192E
....................    else if(cadena=='8') valor=8; 
1910:  MOVF   x86,W
1912:  SUBLW  38
1914:  BNZ   1920
1916:  MOVF   x87,F
1918:  BNZ   1920
191A:  MOVLW  08
191C:  MOVWF  x88
191E:  BRA    192E
....................    else if(cadena=='9') valor=9; 
1920:  MOVF   x86,W
1922:  SUBLW  39
1924:  BNZ   192E
1926:  MOVF   x87,F
1928:  BNZ   192E
192A:  MOVLW  09
192C:  MOVWF  x88
....................    return valor; 
192E:  MOVFF  188,01
1932:  MOVLB  0
1934:  RETURN 0
.................... } 
....................  
.................... void enviop1(){//Convierte a enteros la cadena recibida por el poste esclavo 
....................    disable_interrupts(INT_RDA); 
*
1458:  BCF    F9D.5
....................    entran1=0; 
145A:  CLRF   39
145C:  CLRF   38
....................    salen1=0; 
145E:  CLRF   3B
1460:  CLRF   3A
....................    temporal1=0; 
1462:  CLRF   2F
1464:  CLRF   2E
....................    temporal2=0; 
1466:  CLRF   31
1468:  CLRF   30
....................    temporal3=0; 
146A:  CLRF   x97
146C:  CLRF   x96
....................    tempo_tn=0; 
146E:  CLRF   33
1470:  CLRF   32
....................    pasajet=0; 
1472:  CLRF   x91
1474:  CLRF   x90
....................    memset(entran, 0, sizeof(entran));//entran=0; 
1476:  MOVLW  01
1478:  MOVWF  FEA
147A:  MOVLW  6B
147C:  MOVWF  FE9
147E:  CLRF   00
1480:  CLRF   02
1482:  MOVLW  04
1484:  MOVWF  01
1486:  RCALL  143E
....................    memset(salen, 0, sizeof(salen));//salen=0; 
1488:  MOVLW  01
148A:  MOVWF  FEA
148C:  MOVLW  6F
148E:  MOVWF  FE9
1490:  CLRF   00
1492:  CLRF   02
1494:  MOVLW  04
1496:  MOVWF  01
1498:  RCALL  143E
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
149A:  MOVLW  01
149C:  MOVWF  FEA
149E:  MOVLW  73
14A0:  MOVWF  FE9
14A2:  CLRF   00
14A4:  CLRF   02
14A6:  MOVLW  03
14A8:  MOVWF  01
14AA:  RCALL  143E
....................    memset(bloqueado, 0, sizeof(tempo_tc));//total 
14AC:  MOVLW  01
14AE:  MOVWF  FEA
14B0:  MOVLW  73
14B2:  MOVWF  FE9
14B4:  CLRF   00
14B6:  CLRF   02
14B8:  MOVLW  04
14BA:  MOVWF  01
14BC:  RCALL  143E
....................    i=10; 
14BE:  MOVLW  0A
14C0:  MOVWF  41
....................    ii=0; 
14C2:  CLRF   42
....................    for(ii=0;ii<=3;ii++)  entran[ii]=XX[10 +ii]; 
14C4:  CLRF   42
14C6:  MOVF   42,W
14C8:  SUBLW  03
14CA:  BNC   1508
14CC:  CLRF   03
14CE:  MOVF   42,W
14D0:  ADDLW  6B
14D2:  MOVWF  01
14D4:  MOVLW  01
14D6:  ADDWFC 03,F
14D8:  MOVFF  01,186
14DC:  MOVLB  1
14DE:  MOVFF  03,187
14E2:  MOVLW  0A
14E4:  ADDWF  42,W
14E6:  CLRF   03
14E8:  ADDLW  4E
14EA:  MOVWF  FE9
14EC:  MOVLW  01
14EE:  ADDWFC 03,W
14F0:  MOVWF  FEA
14F2:  MOVFF  FEF,188
14F6:  MOVFF  187,FEA
14FA:  MOVFF  01,FE9
14FE:  MOVFF  188,FEF
1502:  INCF   42,F
1504:  MOVLB  0
1506:  BRA    14C6
....................    for(ii=0;ii<=3;ii++)  salen[ii]=XX[15 +ii]; 
1508:  CLRF   42
150A:  MOVF   42,W
150C:  SUBLW  03
150E:  BNC   154C
1510:  CLRF   03
1512:  MOVF   42,W
1514:  ADDLW  6F
1516:  MOVWF  01
1518:  MOVLW  01
151A:  ADDWFC 03,F
151C:  MOVFF  01,186
1520:  MOVLB  1
1522:  MOVFF  03,187
1526:  MOVLW  0F
1528:  ADDWF  42,W
152A:  CLRF   03
152C:  ADDLW  4E
152E:  MOVWF  FE9
1530:  MOVLW  01
1532:  ADDWFC 03,W
1534:  MOVWF  FEA
1536:  MOVFF  FEF,188
153A:  MOVFF  187,FEA
153E:  MOVFF  01,FE9
1542:  MOVFF  188,FEF
1546:  INCF   42,F
1548:  MOVLB  0
154A:  BRA    150A
....................    for(ii=0;ii<=2;ii++)  bloqueado[ii]=XX[20 +ii]; 
154C:  CLRF   42
154E:  MOVF   42,W
1550:  SUBLW  02
1552:  BNC   1590
1554:  CLRF   03
1556:  MOVF   42,W
1558:  ADDLW  73
155A:  MOVWF  01
155C:  MOVLW  01
155E:  ADDWFC 03,F
1560:  MOVFF  01,186
1564:  MOVLB  1
1566:  MOVFF  03,187
156A:  MOVLW  14
156C:  ADDWF  42,W
156E:  CLRF   03
1570:  ADDLW  4E
1572:  MOVWF  FE9
1574:  MOVLW  01
1576:  ADDWFC 03,W
1578:  MOVWF  FEA
157A:  MOVFF  FEF,188
157E:  MOVFF  187,FEA
1582:  MOVFF  01,FE9
1586:  MOVFF  188,FEF
158A:  INCF   42,F
158C:  MOVLB  0
158E:  BRA    154E
....................    for(ii=0;ii<=3;ii++)  tempo_tc[ii]=XX[24 +ii]; 
1590:  CLRF   42
1592:  MOVF   42,W
1594:  SUBLW  03
1596:  BNC   15D4
1598:  CLRF   03
159A:  MOVF   42,W
159C:  ADDLW  80
159E:  MOVWF  01
15A0:  MOVLW  01
15A2:  ADDWFC 03,F
15A4:  MOVFF  01,186
15A8:  MOVLB  1
15AA:  MOVFF  03,187
15AE:  MOVLW  18
15B0:  ADDWF  42,W
15B2:  CLRF   03
15B4:  ADDLW  4E
15B6:  MOVWF  FE9
15B8:  MOVLW  01
15BA:  ADDWFC 03,W
15BC:  MOVWF  FEA
15BE:  MOVFF  FEF,188
15C2:  MOVFF  187,FEA
15C6:  MOVFF  01,FE9
15CA:  MOVFF  188,FEF
15CE:  INCF   42,F
15D0:  MOVLB  0
15D2:  BRA    1592
15D4:  GOTO   3032 (RETURN)
.................... //!   lcd_gotoxy(15,3);// 
.................... //!   printf(lcd_putc,"A:%c%c%c%c",tempo_tc[0],tempo_tc[1],tempo_tc[2],tempo_tc[3]); 
.................... } 
....................  
.................... void envio(){//crea paquete para enviar al modulo GPRS 
....................    ////////////// Detectando envio total 
....................    if(convertir_to_entero(tempo_tc[0]) >0) for(i=0;i< convertir_to_entero(tempo_tc[0]);i++) tempo_tn=tempo_tn+1000; 
*
1936:  MOVLB  1
1938:  CLRF   x87
193A:  MOVFF  180,186
193E:  MOVLB  0
1940:  RCALL  188E
1942:  MOVF   01,F
1944:  BZ    1966
1946:  CLRF   41
1948:  MOVLB  1
194A:  CLRF   x87
194C:  MOVFF  180,186
1950:  MOVLB  0
1952:  RCALL  188E
1954:  MOVF   01,W
1956:  SUBWF  41,W
1958:  BC    1966
195A:  MOVLW  E8
195C:  ADDWF  32,F
195E:  MOVLW  03
1960:  ADDWFC 33,F
1962:  INCF   41,F
1964:  BRA    1948
....................    if(convertir_to_entero(tempo_tc[1]) >0) for(i=0;i< convertir_to_entero(tempo_tc[1]);i++) tempo_tn=tempo_tn+100; 
1966:  MOVLB  1
1968:  CLRF   x87
196A:  MOVFF  181,186
196E:  MOVLB  0
1970:  RCALL  188E
1972:  MOVF   01,F
1974:  BZ    1996
1976:  CLRF   41
1978:  MOVLB  1
197A:  CLRF   x87
197C:  MOVFF  181,186
1980:  MOVLB  0
1982:  RCALL  188E
1984:  MOVF   01,W
1986:  SUBWF  41,W
1988:  BC    1996
198A:  MOVLW  64
198C:  ADDWF  32,F
198E:  MOVLW  00
1990:  ADDWFC 33,F
1992:  INCF   41,F
1994:  BRA    1978
....................    if(convertir_to_entero(tempo_tc[2]) >0) for(i=0;i< convertir_to_entero(tempo_tc[2]);i++) tempo_tn=tempo_tn+10; 
1996:  MOVLB  1
1998:  CLRF   x87
199A:  MOVFF  182,186
199E:  MOVLB  0
19A0:  RCALL  188E
19A2:  MOVF   01,F
19A4:  BZ    19C6
19A6:  CLRF   41
19A8:  MOVLB  1
19AA:  CLRF   x87
19AC:  MOVFF  182,186
19B0:  MOVLB  0
19B2:  RCALL  188E
19B4:  MOVF   01,W
19B6:  SUBWF  41,W
19B8:  BC    19C6
19BA:  MOVLW  0A
19BC:  ADDWF  32,F
19BE:  MOVLW  00
19C0:  ADDWFC 33,F
19C2:  INCF   41,F
19C4:  BRA    19A8
....................    tempo_tn=tempo_tn+convertir_to_entero(tempo_tc[3]); 
19C6:  MOVLB  1
19C8:  CLRF   x87
19CA:  MOVFF  183,186
19CE:  MOVLB  0
19D0:  RCALL  188E
19D2:  MOVF   01,W
19D4:  ADDWF  32,F
19D6:  MOVLW  00
19D8:  ADDWFC 33,F
....................    //////////////////////////////////////////////////// 
....................    if(convertir_to_entero(entran[0]) >0) for(i=0;i< convertir_to_entero(entran[0]);i++) temporal1=temporal1+1000; 
19DA:  MOVLB  1
19DC:  CLRF   x87
19DE:  MOVFF  16B,186
19E2:  MOVLB  0
19E4:  RCALL  188E
19E6:  MOVF   01,F
19E8:  BZ    1A0A
19EA:  CLRF   41
19EC:  MOVLB  1
19EE:  CLRF   x87
19F0:  MOVFF  16B,186
19F4:  MOVLB  0
19F6:  RCALL  188E
19F8:  MOVF   01,W
19FA:  SUBWF  41,W
19FC:  BC    1A0A
19FE:  MOVLW  E8
1A00:  ADDWF  2E,F
1A02:  MOVLW  03
1A04:  ADDWFC 2F,F
1A06:  INCF   41,F
1A08:  BRA    19EC
....................    if(convertir_to_entero(entran[1]) >0) for(i=0;i< convertir_to_entero(entran[1]);i++) temporal1=temporal1+100; 
1A0A:  MOVLB  1
1A0C:  CLRF   x87
1A0E:  MOVFF  16C,186
1A12:  MOVLB  0
1A14:  RCALL  188E
1A16:  MOVF   01,F
1A18:  BZ    1A3A
1A1A:  CLRF   41
1A1C:  MOVLB  1
1A1E:  CLRF   x87
1A20:  MOVFF  16C,186
1A24:  MOVLB  0
1A26:  RCALL  188E
1A28:  MOVF   01,W
1A2A:  SUBWF  41,W
1A2C:  BC    1A3A
1A2E:  MOVLW  64
1A30:  ADDWF  2E,F
1A32:  MOVLW  00
1A34:  ADDWFC 2F,F
1A36:  INCF   41,F
1A38:  BRA    1A1C
....................    if(convertir_to_entero(entran[2]) >0) for(i=0;i< convertir_to_entero(entran[2]);i++) temporal1=temporal1+10; 
1A3A:  MOVLB  1
1A3C:  CLRF   x87
1A3E:  MOVFF  16D,186
1A42:  MOVLB  0
1A44:  RCALL  188E
1A46:  MOVF   01,F
1A48:  BZ    1A6A
1A4A:  CLRF   41
1A4C:  MOVLB  1
1A4E:  CLRF   x87
1A50:  MOVFF  16D,186
1A54:  MOVLB  0
1A56:  RCALL  188E
1A58:  MOVF   01,W
1A5A:  SUBWF  41,W
1A5C:  BC    1A6A
1A5E:  MOVLW  0A
1A60:  ADDWF  2E,F
1A62:  MOVLW  00
1A64:  ADDWFC 2F,F
1A66:  INCF   41,F
1A68:  BRA    1A4C
....................    sub_atras=temporal1=temporal1+convertir_to_entero(entran[3]); 
1A6A:  MOVLB  1
1A6C:  CLRF   x87
1A6E:  MOVFF  16E,186
1A72:  MOVLB  0
1A74:  RCALL  188E
1A76:  MOVF   01,W
1A78:  ADDWF  2E,F
1A7A:  MOVLW  00
1A7C:  ADDWFC 2F,F
1A7E:  MOVFF  2F,35
1A82:  MOVFF  2E,34
....................     
....................    if(convertir_to_entero(salen[0]) >0) for(i=0;i< convertir_to_entero(salen[0]);i++) temporal2=temporal2+1000; 
1A86:  MOVLB  1
1A88:  CLRF   x87
1A8A:  MOVFF  16F,186
1A8E:  MOVLB  0
1A90:  RCALL  188E
1A92:  MOVF   01,F
1A94:  BZ    1AB6
1A96:  CLRF   41
1A98:  MOVLB  1
1A9A:  CLRF   x87
1A9C:  MOVFF  16F,186
1AA0:  MOVLB  0
1AA2:  RCALL  188E
1AA4:  MOVF   01,W
1AA6:  SUBWF  41,W
1AA8:  BC    1AB6
1AAA:  MOVLW  E8
1AAC:  ADDWF  30,F
1AAE:  MOVLW  03
1AB0:  ADDWFC 31,F
1AB2:  INCF   41,F
1AB4:  BRA    1A98
....................    if(convertir_to_entero(salen[1]) >0) for(i=0;i< convertir_to_entero(salen[1]);i++) temporal2=temporal2+100; 
1AB6:  MOVLB  1
1AB8:  CLRF   x87
1ABA:  MOVFF  170,186
1ABE:  MOVLB  0
1AC0:  RCALL  188E
1AC2:  MOVF   01,F
1AC4:  BZ    1AE6
1AC6:  CLRF   41
1AC8:  MOVLB  1
1ACA:  CLRF   x87
1ACC:  MOVFF  170,186
1AD0:  MOVLB  0
1AD2:  RCALL  188E
1AD4:  MOVF   01,W
1AD6:  SUBWF  41,W
1AD8:  BC    1AE6
1ADA:  MOVLW  64
1ADC:  ADDWF  30,F
1ADE:  MOVLW  00
1AE0:  ADDWFC 31,F
1AE2:  INCF   41,F
1AE4:  BRA    1AC8
....................    if(convertir_to_entero(salen[2]) >0) for(i=0;i< convertir_to_entero(salen[2]);i++) temporal2=temporal2+10; 
1AE6:  MOVLB  1
1AE8:  CLRF   x87
1AEA:  MOVFF  171,186
1AEE:  MOVLB  0
1AF0:  RCALL  188E
1AF2:  MOVF   01,F
1AF4:  BZ    1B16
1AF6:  CLRF   41
1AF8:  MOVLB  1
1AFA:  CLRF   x87
1AFC:  MOVFF  171,186
1B00:  MOVLB  0
1B02:  RCALL  188E
1B04:  MOVF   01,W
1B06:  SUBWF  41,W
1B08:  BC    1B16
1B0A:  MOVLW  0A
1B0C:  ADDWF  30,F
1B0E:  MOVLW  00
1B10:  ADDWFC 31,F
1B12:  INCF   41,F
1B14:  BRA    1AF8
....................    baj_atras=temporal2=temporal2+convertir_to_entero(salen[3]); 
1B16:  MOVLB  1
1B18:  CLRF   x87
1B1A:  MOVFF  172,186
1B1E:  MOVLB  0
1B20:  RCALL  188E
1B22:  MOVF   01,W
1B24:  ADDWF  30,F
1B26:  MOVLW  00
1B28:  ADDWFC 31,F
1B2A:  MOVFF  31,37
1B2E:  MOVFF  30,36
....................     
....................    if(convertir_to_entero(bloqueado[0]) >0) for(i=0;i< convertir_to_entero(bloqueado[0]);i++) temporal3=temporal3+100; 
1B32:  MOVLB  1
1B34:  CLRF   x87
1B36:  MOVFF  173,186
1B3A:  MOVLB  0
1B3C:  RCALL  188E
1B3E:  MOVF   01,F
1B40:  BZ    1B62
1B42:  CLRF   41
1B44:  MOVLB  1
1B46:  CLRF   x87
1B48:  MOVFF  173,186
1B4C:  MOVLB  0
1B4E:  RCALL  188E
1B50:  MOVF   01,W
1B52:  SUBWF  41,W
1B54:  BC    1B62
1B56:  MOVLW  64
1B58:  ADDWF  x96,F
1B5A:  MOVLW  00
1B5C:  ADDWFC x97,F
1B5E:  INCF   41,F
1B60:  BRA    1B44
....................    if(convertir_to_entero(bloqueado[1]) >0) for(i=0;i< convertir_to_entero(bloqueado[1]);i++) temporal3=temporal3+10; 
1B62:  MOVLB  1
1B64:  CLRF   x87
1B66:  MOVFF  174,186
1B6A:  MOVLB  0
1B6C:  RCALL  188E
1B6E:  MOVF   01,F
1B70:  BZ    1B92
1B72:  CLRF   41
1B74:  MOVLB  1
1B76:  CLRF   x87
1B78:  MOVFF  174,186
1B7C:  MOVLB  0
1B7E:  RCALL  188E
1B80:  MOVF   01,W
1B82:  SUBWF  41,W
1B84:  BC    1B92
1B86:  MOVLW  0A
1B88:  ADDWF  x96,F
1B8A:  MOVLW  00
1B8C:  ADDWFC x97,F
1B8E:  INCF   41,F
1B90:  BRA    1B74
....................    temporal3=temporal3+convertir_to_entero(bloqueado[2]); 
1B92:  MOVLB  1
1B94:  CLRF   x87
1B96:  MOVFF  175,186
1B9A:  MOVLB  0
1B9C:  RCALL  188E
1B9E:  MOVF   01,W
1BA0:  ADDWF  x96,F
1BA2:  MOVLW  00
1BA4:  ADDWFC x97,F
....................     
....................    entran1=(entraront+salieront)/2; 
1BA6:  MOVF   x8C,W
1BA8:  ADDWF  x8A,W
1BAA:  MOVLB  1
1BAC:  MOVWF  x86
1BAE:  MOVLB  0
1BB0:  MOVF   x8D,W
1BB2:  ADDWFC x8B,W
1BB4:  MOVLB  1
1BB6:  MOVWF  x87
1BB8:  BCF    FD8.0
1BBA:  RRCF   x87,W
1BBC:  MOVWF  39
1BBE:  RRCF   x86,W
1BC0:  MOVWF  38
....................     
....................    total2_t=(temporal1+temporal2)/2; 
1BC2:  MOVF   30,W
1BC4:  ADDWF  2E,W
1BC6:  MOVWF  x86
1BC8:  MOVF   31,W
1BCA:  ADDWFC 2F,W
1BCC:  MOVWF  x87
1BCE:  BCF    FD8.0
1BD0:  RRCF   x87,W
1BD2:  MOVWF  51
1BD4:  RRCF   x86,W
1BD6:  MOVWF  50
....................    ////////////////// 
.................... //!   lcd_gotoxy(16,1);// 
.................... //!   printf(lcd_putc,"S:%Lu",total2_t); 
.................... //!   lcd_gotoxy(16,2);// 
.................... //!   printf(lcd_putc,"R:%Lu",tempo_tn); 
....................    ///////////////// 
....................    leer_conta2(); 
1BD8:  MOVLB  0
1BDA:  CALL   07D0
....................    if( total2_t== tempo_tn ) {//dato recibido correcto 
1BDE:  MOVF   32,W
1BE0:  SUBWF  50,W
1BE2:  BNZ   1C02
1BE4:  MOVF   33,W
1BE6:  SUBWF  51,W
1BE8:  BNZ   1C02
....................          salian=salen1=total2_t; 
1BEA:  MOVFF  51,3B
1BEE:  MOVFF  50,3A
1BF2:  MOVFF  3B,3D
1BF6:  MOVFF  3A,3C
....................          graba_conta2(); 
1BFA:  CALL   066E
....................          error=0; 
1BFE:  CLRF   23
....................    } 
1C00:  BRA    1C06
....................    else error=2; 
1C02:  MOVLW  02
1C04:  MOVWF  23
....................    ///////////// 
....................    pasajet=entran1+salen1; 
1C06:  MOVF   3A,W
1C08:  ADDWF  38,W
1C0A:  MOVWF  x90
1C0C:  MOVF   3B,W
1C0E:  ADDWFC 39,W
1C10:  MOVWF  x91
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1C12:  MOVF   53,W
1C14:  ADDWF  52,W
1C16:  ADDWF  54,W
1C18:  MOVWF  4C
1C1A:  CLRF   4D
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,temporal1,temporal2,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,%03Lu,%03Lu,%02u,\r\n",pasajet,entran1,salen1,cta_bloqueo,temporal3,error); 
1C1C:  MOVLW  EC
1C1E:  MOVWF  FF6
1C20:  MOVLW  02
1C22:  MOVWF  FF7
1C24:  MOVLW  07
1C26:  MOVLB  1
1C28:  MOVWF  x86
1C2A:  MOVLB  0
1C2C:  RCALL  15D8
1C2E:  MOVLW  09
1C30:  MOVWF  FE9
1C32:  MOVFF  91,187
1C36:  MOVFF  90,186
1C3A:  RCALL  1600
1C3C:  MOVLW  2C
1C3E:  MOVLB  1
1C40:  MOVWF  x8F
1C42:  MOVLB  0
1C44:  CALL   1146
1C48:  MOVLW  09
1C4A:  MOVWF  FE9
1C4C:  MOVFF  39,187
1C50:  MOVFF  38,186
1C54:  RCALL  1600
1C56:  MOVLW  2C
1C58:  MOVLB  1
1C5A:  MOVWF  x8F
1C5C:  MOVLB  0
1C5E:  CALL   1146
1C62:  MOVLW  09
1C64:  MOVWF  FE9
1C66:  MOVFF  3B,187
1C6A:  MOVFF  3A,186
1C6E:  RCALL  1600
1C70:  MOVLW  2C
1C72:  MOVLB  1
1C74:  MOVWF  x8F
1C76:  MOVLB  0
1C78:  CALL   1146
1C7C:  MOVLW  0A
1C7E:  MOVWF  FE9
1C80:  MOVFF  4D,187
1C84:  MOVFF  4C,186
1C88:  RCALL  1600
1C8A:  MOVLW  2C
1C8C:  MOVLB  1
1C8E:  MOVWF  x8F
1C90:  MOVLB  0
1C92:  CALL   1146
1C96:  MOVLW  0A
1C98:  MOVWF  FE9
1C9A:  MOVFF  97,187
1C9E:  MOVFF  96,186
1CA2:  RCALL  1600
1CA4:  MOVLW  2C
1CA6:  MOVLB  1
1CA8:  MOVWF  x8F
1CAA:  MOVLB  0
1CAC:  CALL   1146
1CB0:  MOVFF  23,186
1CB4:  MOVLW  01
1CB6:  MOVLB  1
1CB8:  MOVWF  x87
1CBA:  MOVLB  0
1CBC:  RCALL  16C4
1CBE:  MOVLW  15
1CC0:  MOVWF  FF6
1CC2:  MOVLW  03
1CC4:  MOVWF  FF7
1CC6:  MOVLW  03
1CC8:  MOVLB  1
1CCA:  MOVWF  x86
1CCC:  MOVLB  0
1CCE:  RCALL  15D8
....................    lcd_cuentas(); 
1CD0:  CALL   0A18
....................    /////////////////////////// 
.................... //!   lcd_gotoxy(8,4); 
.................... //!   printf(lcd_putc,"M:%Ld E:%Ld T:%Ld ",entran1,salen1,pasajet); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1CD4:  MOVLW  09
1CD6:  MOVLB  1
1CD8:  MOVWF  x90
1CDA:  MOVLW  03
1CDC:  MOVWF  x91
1CDE:  MOVLB  0
1CE0:  CALL   0822
....................    lcd_putc(0xAB); 
1CE4:  MOVLW  AB
1CE6:  MOVLB  1
1CE8:  MOVWF  x8F
1CEA:  MOVLB  0
1CEC:  CALL   0874
....................    //lcd_gotoxy(9,4);//cronometro para limpiar 
....................    //lcd_putc("    "); 
....................    clear_lcd1=1; 
1CF0:  MOVLW  01
1CF2:  MOVWF  xAB
....................    time_lcd1=0; 
1CF4:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1CF6:  CLRF   xAA
1CF8:  CLRF   xA9
....................    transmitir=0; 
1CFA:  CLRF   24
....................    enable_interrupts(INT_RDA); 
1CFC:  BSF    F9D.5
1CFE:  GOTO   319A (RETURN)
.................... } 
....................  
.................... void envia2(){//Crea paquete para enviar a modulo GPRS cuando no hay conexion con esclavo 
....................    disable_interrupts(INT_RDA); 
*
1740:  BCF    F9D.5
....................    cta_bloqueo=cta_bloq1+cta_bloq2+cta_bloq3; 
1742:  MOVF   53,W
1744:  ADDWF  52,W
1746:  ADDWF  54,W
1748:  MOVWF  4C
174A:  CLRF   4D
....................    memset(entran, 0, sizeof(entran));//entran=0; 
174C:  MOVLW  01
174E:  MOVWF  FEA
1750:  MOVLW  6B
1752:  MOVWF  FE9
1754:  CLRF   00
1756:  CLRF   02
1758:  MOVLW  04
175A:  MOVWF  01
175C:  RCALL  143E
....................    memset(salen, 0, sizeof(salen));//salen=0; 
175E:  MOVLW  01
1760:  MOVWF  FEA
1762:  MOVLW  6F
1764:  MOVWF  FE9
1766:  CLRF   00
1768:  CLRF   02
176A:  MOVLW  04
176C:  MOVWF  01
176E:  RCALL  143E
....................    memset(bloqueado, 0, sizeof(bloqueado));//bloqueado=0; 
1770:  MOVLW  01
1772:  MOVWF  FEA
1774:  MOVLW  73
1776:  MOVWF  FE9
1778:  CLRF   00
177A:  CLRF   02
177C:  MOVLW  03
177E:  MOVWF  01
1780:  RCALL  143E
....................    i=10; 
1782:  MOVLW  0A
1784:  MOVWF  41
....................    ii=0; 
1786:  CLRF   42
....................    entran1=(entraront+salieront)/2; 
1788:  MOVF   x8C,W
178A:  ADDWF  x8A,W
178C:  MOVLB  1
178E:  MOVWF  x86
1790:  MOVLB  0
1792:  MOVF   x8D,W
1794:  ADDWFC x8B,W
1796:  MOVLB  1
1798:  MOVWF  x87
179A:  BCF    FD8.0
179C:  RRCF   x87,W
179E:  MOVWF  39
17A0:  RRCF   x86,W
17A2:  MOVWF  38
....................    leer_conta2(); 
17A4:  MOVLB  0
17A6:  CALL   07D0
....................    pasajet=entran1+salian; 
17AA:  MOVF   3C,W
17AC:  ADDWF  38,W
17AE:  MOVWF  x90
17B0:  MOVF   3D,W
17B2:  ADDWFC 39,W
17B4:  MOVWF  x91
....................    error=1; 
17B6:  MOVLW  01
17B8:  MOVWF  23
....................    //fprintf(GPS,"ACC+01:%04Lu,%04Lu,%04Lu,DESC,DESC,%03Lu,%03Lu,%02u,\r\n",pasajet,entraront,salieront,cta_bloqueo,temporal3,error); 
....................    fprintf(GPS,"ACC+01:%04Lu,%04Lu,DESC,%03Lu,000,%02u,\r\n",pasajet,entran1,cta_bloqueo,error); 
17BA:  MOVLW  1A
17BC:  MOVWF  FF6
17BE:  MOVLW  03
17C0:  MOVWF  FF7
17C2:  MOVLW  07
17C4:  MOVLB  1
17C6:  MOVWF  x86
17C8:  MOVLB  0
17CA:  RCALL  15D8
17CC:  MOVLW  09
17CE:  MOVWF  FE9
17D0:  MOVFF  91,187
17D4:  MOVFF  90,186
17D8:  RCALL  1600
17DA:  MOVLW  2C
17DC:  MOVLB  1
17DE:  MOVWF  x8F
17E0:  MOVLB  0
17E2:  RCALL  1146
17E4:  MOVLW  09
17E6:  MOVWF  FE9
17E8:  MOVFF  39,187
17EC:  MOVFF  38,186
17F0:  RCALL  1600
17F2:  MOVLW  2C
17F4:  MOVWF  FF6
17F6:  MOVLW  03
17F8:  MOVWF  FF7
17FA:  MOVLW  06
17FC:  MOVLB  1
17FE:  MOVWF  x86
1800:  MOVLB  0
1802:  RCALL  15D8
1804:  MOVLW  0A
1806:  MOVWF  FE9
1808:  MOVFF  4D,187
180C:  MOVFF  4C,186
1810:  RCALL  1600
1812:  MOVLW  37
1814:  MOVWF  FF6
1816:  MOVLW  03
1818:  MOVWF  FF7
181A:  MOVLW  05
181C:  MOVLB  1
181E:  MOVWF  x86
1820:  MOVLB  0
1822:  RCALL  15D8
1824:  MOVFF  23,186
1828:  MOVLW  01
182A:  MOVLB  1
182C:  MOVWF  x87
182E:  MOVLB  0
1830:  RCALL  16C4
1832:  MOVLW  40
1834:  MOVWF  FF6
1836:  MOVLW  03
1838:  MOVWF  FF7
183A:  MOVLW  03
183C:  MOVLB  1
183E:  MOVWF  x86
1840:  MOVLB  0
1842:  RCALL  15D8
.................... //!   lcd_gotoxy(1,4); 
.................... //!   printf(lcd_putc,"T:%04Lu BS:%03Lu ",pasajet,cta_bloqueo); 
....................    lcd_gotoxy(9,3);//cronometro para limpiar 
1844:  MOVLW  09
1846:  MOVLB  1
1848:  MOVWF  x90
184A:  MOVLW  03
184C:  MOVWF  x91
184E:  MOVLB  0
1850:  CALL   0822
....................    lcd_putc(0xAB); 
1854:  MOVLW  AB
1856:  MOVLB  1
1858:  MOVWF  x8F
185A:  MOVLB  0
185C:  CALL   0874
....................    lcd_gotoxy(9,4);//cronometro para limpiar 
1860:  MOVLW  09
1862:  MOVLB  1
1864:  MOVWF  x90
1866:  MOVLW  04
1868:  MOVWF  x91
186A:  MOVLB  0
186C:  CALL   0822
....................    lcd_putc("DESC"); 
1870:  MOVLW  44
1872:  MOVWF  FF6
1874:  MOVLW  03
1876:  MOVWF  FF7
1878:  CALL   09F8
....................    clear_lcd1=1; 
187C:  MOVLW  01
187E:  MOVWF  xAB
....................    time_lcd1=0; 
1880:  CLRF   xAC
....................    ///////////////////////////// 
....................    time_envio=0;//reinicia el tiempo para el siguiente envio 
1882:  CLRF   xAA
1884:  CLRF   xA9
....................    flag_enviar=0; 
1886:  CLRF   46
....................    enable_interrupts(INT_RDA); 
1888:  BSF    F9D.5
188A:  GOTO   3190 (RETURN)
.................... } 
....................  
.................... void limpiar(){//borra cuentas de subidas, bajadas y bloqueos 
....................    tem_entraront=0; 
*
0CD0:  CLRF   x93
0CD2:  CLRF   x92
....................    tem_salieront=0; 
0CD4:  CLRF   x95
0CD6:  CLRF   x94
....................    salian=0; 
0CD8:  CLRF   3D
0CDA:  CLRF   3C
....................    graba_conta2(); 
0CDC:  RCALL  066E
....................    leer_conta2(); 
0CDE:  RCALL  07D0
....................    pasaje=0; 
0CE0:  CLRF   x8F
0CE2:  CLRF   x8E
....................    pasajet=0; 
0CE4:  CLRF   x91
0CE6:  CLRF   x90
....................    salieront=0; 
0CE8:  CLRF   x8D
0CEA:  CLRF   x8C
....................    entraront=0; 
0CEC:  CLRF   x8B
0CEE:  CLRF   x8A
....................    write_ent(); 
0CF0:  RCALL  0C64
....................    write_sal(); 
0CF2:  RCALL  0C9A
....................    cta_bloqueo=0; 
0CF4:  CLRF   4D
0CF6:  CLRF   4C
....................    cta_bloq1=0; 
0CF8:  CLRF   52
....................    cta_bloq2=0; 
0CFA:  CLRF   53
....................    cta_bloq3=0; 
0CFC:  CLRF   54
....................    write_ext_eeprom(9,cta_bloq1);//bloq1 
0CFE:  MOVLB  1
0D00:  CLRF   x8B
0D02:  MOVLW  09
0D04:  MOVWF  x8A
0D06:  MOVFF  52,18C
0D0A:  MOVLB  0
0D0C:  RCALL  0568
....................    write_ext_eeprom(10,cta_bloq2);//bloq2 
0D0E:  MOVLB  1
0D10:  CLRF   x8B
0D12:  MOVLW  0A
0D14:  MOVWF  x8A
0D16:  MOVFF  53,18C
0D1A:  MOVLB  0
0D1C:  RCALL  0568
....................    write_ext_eeprom(11,cta_bloq3);//bloq3 
0D1E:  MOVLB  1
0D20:  CLRF   x8B
0D22:  MOVLW  0B
0D24:  MOVWF  x8A
0D26:  MOVFF  54,18C
0D2A:  MOVLB  0
0D2C:  RCALL  0568
....................    lcd_putc("\f"); 
0D2E:  MOVLW  4A
0D30:  MOVWF  FF6
0D32:  MOVLW  03
0D34:  MOVWF  FF7
0D36:  RCALL  09F8
....................    lcd_cuentas(); 
0D38:  RCALL  0A18
0D3A:  RETURN 0
.................... } 
....................  
.................... void detecta_suma(){//Realiza suma de entradas o salidas 
....................     if( (!detec1)&&(!detec2)&&(!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){//suma sin bloqueos 
*
1FD2:  MOVF   x69,F
1FD4:  BNZ   2040
1FD6:  MOVF   x6A,F
1FD8:  BNZ   2040
1FDA:  MOVF   x6B,F
1FDC:  BNZ   2040
1FDE:  MOVF   x6C,F
1FE0:  BNZ   2040
1FE2:  MOVF   x6D,F
1FE4:  BNZ   2040
1FE6:  MOVF   x6E,F
1FE8:  BNZ   2040
....................       sumae1=fse1+fse2+fse3; 
1FEA:  MOVF   29,W
1FEC:  ADDWF  28,W
1FEE:  ADDWF  2A,W
1FF0:  MOVWF  25
....................       sumas1=fss1+fss2+fss3; 
1FF2:  MOVF   2C,W
1FF4:  ADDWF  2B,W
1FF6:  ADDWF  2D,W
1FF8:  MOVWF  26
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................       if( (sumae1>=2)||(sumas1>=2) ){ 
1FFA:  MOVF   25,W
1FFC:  SUBLW  01
1FFE:  BNC   2006
2000:  MOVF   26,W
2002:  SUBLW  01
2004:  BC    2022
....................          if(sumae1>sumas1) { 
2006:  MOVF   25,W
2008:  SUBWF  26,W
200A:  BC    2018
....................             entraront++; 
200C:  INCF   x8A,F
200E:  BTFSC  FD8.2
2010:  INCF   x8B,F
....................             write_ent(); 
2012:  CALL   0C64
....................          } 
2016:  BRA    2022
....................          else{ 
....................             salieront++; 
2018:  INCF   x8C,F
201A:  BTFSC  FD8.2
201C:  INCF   x8D,F
....................             write_sal(); 
201E:  CALL   0C9A
....................          } 
....................       } 
....................       sumae1=fse1=fse2=fse3=0; 
2022:  CLRF   2A
2024:  MOVFF  2A,29
2028:  MOVFF  29,28
202C:  MOVFF  28,25
....................       sumas1=fss1=fss2=fss3=0; 
2030:  CLRF   2D
2032:  MOVFF  2D,2C
2036:  MOVFF  2C,2B
203A:  MOVFF  2B,26
....................       //envio_PC(); 
....................    }//fin suma sin bloqueos 
203E:  BRA    213E
....................    else if( (en_b1)||(en_b2)||(en_b3) ){//contar con bloqueos 
2040:  MOVF   x9E,F
2042:  BNZ   204E
2044:  MOVF   x9F,F
2046:  BNZ   204E
2048:  MOVF   xA0,F
204A:  BTFSC  FD8.2
204C:  BRA    213E
....................             lim_b= en_b1+ en_b2+ en_b3; 
204E:  MOVF   x9F,W
2050:  ADDWF  x9E,W
2052:  ADDWF  xA0,W
2054:  MOVWF  27
.................... //!            lcd_gotoxy(9,2);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"lim_b:%u ",lim_b);//habilitar unicamente para hacer diagnosticos 
.................... //!            lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
.................... //!            printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................              
....................             if(lim_b==1){//un solo bloqueo 
2056:  DECFSZ 27,W
2058:  BRA    20EA
....................                if(en_b1){ 
205A:  MOVF   x9E,F
205C:  BZ    208A
....................                   if( (!detec3)&&(!detec4)&&(!detec5)&&(!detec6) ){ 
205E:  MOVF   x6B,F
2060:  BNZ   2088
2062:  MOVF   x6C,F
2064:  BNZ   2088
2066:  MOVF   x6D,F
2068:  BNZ   2088
206A:  MOVF   x6E,F
206C:  BNZ   2088
....................                      if(sen_ent==1){ 
206E:  DECFSZ 5B,W
2070:  BRA    207E
....................                         entraront++; 
2072:  INCF   x8A,F
2074:  BTFSC  FD8.2
2076:  INCF   x8B,F
....................                         write_ent(); 
2078:  CALL   0C64
....................                      } 
207C:  BRA    2088
....................                      else{ 
....................                         salieront++; 
207E:  INCF   x8C,F
2080:  BTFSC  FD8.2
2082:  INCF   x8D,F
....................                         write_sal(); 
2084:  CALL   0C9A
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin bloqueo par 1 
2088:  BRA    20E8
....................                else if(en_b2){//bloqueo en par 2 
208A:  MOVF   x9F,F
208C:  BZ    20BA
....................                   if( (!detec1)&&(!detec2)&&(!detec5)&&(!detec6) ){ 
208E:  MOVF   x69,F
2090:  BNZ   20B8
2092:  MOVF   x6A,F
2094:  BNZ   20B8
2096:  MOVF   x6D,F
2098:  BNZ   20B8
209A:  MOVF   x6E,F
209C:  BNZ   20B8
....................                      if(sen_ent){ 
209E:  MOVF   5B,F
20A0:  BZ    20AE
....................                         entraront++; 
20A2:  INCF   x8A,F
20A4:  BTFSC  FD8.2
20A6:  INCF   x8B,F
....................                         write_ent(); 
20A8:  CALL   0C64
....................                      } 
20AC:  BRA    20B8
....................                      else{ 
....................                         salieront++; 
20AE:  INCF   x8C,F
20B0:  BTFSC  FD8.2
20B2:  INCF   x8D,F
....................                         write_sal(); 
20B4:  CALL   0C9A
....................                      } 
....................                   }//fin sensores 0 
....................                }//fin par 2 
20B8:  BRA    20E8
....................                else if(en_b3){//bloqueao en par 3 
20BA:  MOVF   xA0,F
20BC:  BZ    20E8
....................                   if( (!detec3)&&(!detec4)&&(!detec1)&&(!detec2) ){ 
20BE:  MOVF   x6B,F
20C0:  BNZ   20E8
20C2:  MOVF   x6C,F
20C4:  BNZ   20E8
20C6:  MOVF   x69,F
20C8:  BNZ   20E8
20CA:  MOVF   x6A,F
20CC:  BNZ   20E8
....................                      if(sen_ent){ 
20CE:  MOVF   5B,F
20D0:  BZ    20DE
....................                         entraront++; 
20D2:  INCF   x8A,F
20D4:  BTFSC  FD8.2
20D6:  INCF   x8B,F
....................                         write_ent(); 
20D8:  CALL   0C64
....................                      } 
20DC:  BRA    20E8
....................                      else{ 
....................                         salieront++; 
20DE:  INCF   x8C,F
20E0:  BTFSC  FD8.2
20E2:  INCF   x8D,F
....................                         write_sal(); 
20E4:  CALL   0C9A
....................                      } 
....................                   } 
....................                }//fin par 3 
....................             }//fin un solo bloqueo 
20E8:  BRA    2122
.................... //----------------------------------------------------------------------------- 
....................             else{//mas de un bloqueo 
....................                sumae1=fse1+fse2+fse3; 
20EA:  MOVF   29,W
20EC:  ADDWF  28,W
20EE:  ADDWF  2A,W
20F0:  MOVWF  25
....................                sumas1=fss1+fss2+fss3; 
20F2:  MOVF   2C,W
20F4:  ADDWF  2B,W
20F6:  ADDWF  2D,W
20F8:  MOVWF  26
....................                //lcd_gotoxy(9,3);//habilitar unicamente para hacer diagnosticos 
....................                //printf(lcd_putc,"Se:%u Ss:%u",sumae1,sumas1);//habilitar unicamente para hacer diagnosticos 
....................                if( (sumae1>=1)||(sumas1>=1) ){ 
20FA:  MOVF   25,W
20FC:  SUBLW  00
20FE:  BNC   2106
2100:  MOVF   26,W
2102:  SUBLW  00
2104:  BC    2122
....................                   if(sumae1>sumas1) { 
2106:  MOVF   25,W
2108:  SUBWF  26,W
210A:  BC    2118
....................                      entraront++; 
210C:  INCF   x8A,F
210E:  BTFSC  FD8.2
2110:  INCF   x8B,F
....................                      write_ent(); 
2112:  CALL   0C64
....................                   } 
2116:  BRA    2122
....................                   else{ 
....................                      salieront++; 
2118:  INCF   x8C,F
211A:  BTFSC  FD8.2
211C:  INCF   x8D,F
....................                      write_sal(); 
211E:  CALL   0C9A
....................                   } 
....................                } 
....................             }//fin mas de un bloqueo 
....................                sumae1=fse1=fse2=fse3=0; 
2122:  CLRF   2A
2124:  MOVFF  2A,29
2128:  MOVFF  29,28
212C:  MOVFF  28,25
....................                sumas1=fss1=fss2=fss3=0; 
2130:  CLRF   2D
2132:  MOVFF  2D,2C
2136:  MOVFF  2C,2B
213A:  MOVFF  2B,26
.................... //----------------------------------------------------------------------------- 
....................    }//end bloqueos 
213E:  RETURN 0
.................... } 
....................  
.................... void finsuma(){//Pinta en LCD la nueva cifra de entrada o salida 
.................... //!      lcd_gotoxy(9,4);//habilitar unicamente para hacer diagnosticos 
.................... //!      printf(lcd_putc,"se:%u ss:%u ",sen_ent,sen_sal);//habilitar unicamente para hacer diagnosticos 
....................       pasaje=(entraront+salieront)/2; 
*
0C26:  MOVF   x8C,W
0C28:  ADDWF  x8A,W
0C2A:  MOVLB  1
0C2C:  MOVWF  x86
0C2E:  MOVLB  0
0C30:  MOVF   x8D,W
0C32:  ADDWFC x8B,W
0C34:  MOVLB  1
0C36:  MOVWF  x87
0C38:  BCF    FD8.0
0C3A:  RRCF   x87,W
0C3C:  MOVLB  0
0C3E:  MOVWF  x8F
0C40:  MOVLB  1
0C42:  RRCF   x86,W
0C44:  MOVLB  0
0C46:  MOVWF  x8E
....................       lcd_cuentas(); 
0C48:  RCALL  0A18
....................       sen_ent=0; 
0C4A:  CLRF   5B
....................       sen_sal=0; 
0C4C:  CLRF   5C
....................       fse1=fse2=fse3=0; 
0C4E:  CLRF   2A
0C50:  MOVFF  2A,29
0C54:  MOVFF  29,28
....................       fss1=fss2=fss3=0; 
0C58:  CLRF   2D
0C5A:  MOVFF  2D,2C
0C5E:  MOVFF  2C,2B
0C62:  RETURN 0
.................... } 
....................  
.................... void contando1(){//Revisa maquina de estados para par 1 
....................    if(entra_temp1!=edo1) { 
*
2140:  MOVF   x76,W
2142:  SUBWF  x7B,W
2144:  BZ    214E
....................       entra_temp1=edo1; 
2146:  MOVFF  76,7B
....................       enable1=1; 
214A:  MOVLW  01
214C:  MOVWF  x7A
....................    } 
....................    if (enable1==1){ 
214E:  DECFSZ x7A,W
2150:  BRA    218E
....................          switch (edo1) { 
2152:  MOVLW  01
2154:  SUBWF  x76,W
2156:  ADDLW  F4
2158:  BC    218A
215A:  ADDLW  0C
215C:  GOTO   2190
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
2160:  BRA    218A
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss1) fse1=1;//si no ha salido antes 
2162:  MOVF   2B,F
2164:  BNZ   216C
2166:  MOVLW  01
2168:  MOVWF  28
216A:  BRA    216E
....................                      else fss1=0; 
216C:  CLRF   2B
....................                      detecta_suma(); 
216E:  RCALL  1FD2
....................                      break;} 
2170:  BRA    218A
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
2172:  RCALL  1FD2
....................                      break;} 
2174:  BRA    218A
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
2176:  BRA    218A
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse1) fss1=1;//si no ha entrado antes 
2178:  MOVF   28,F
217A:  BNZ   2182
217C:  MOVLW  01
217E:  MOVWF  2B
2180:  BRA    2184
....................                      else fse1=0; 
2182:  CLRF   28
....................                      detecta_suma(); 
2184:  RCALL  1FD2
....................                      break;} 
2186:  BRA    218A
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
2188:  RCALL  1FD2
....................                      break;} 
....................          } 
....................       enable1=0; 
218A:  CLRF   x7A
....................       entra_act1=0; 
218C:  CLRF   x75
....................    } 
218E:  RETURN 0
.................... } 
....................  
.................... void contando2(){//Revisa maquina de estados para par 2 
....................    if(entra_temp2!=edo2) { 
*
2448:  MOVF   x7D,W
244A:  SUBWF  x82,W
244C:  BZ    2456
....................       entra_temp2=edo2; 
244E:  MOVFF  7D,82
....................       enable2=1; 
2452:  MOVLW  01
2454:  MOVWF  x81
....................    } 
....................    if (enable2==1){ 
2456:  DECFSZ x81,W
2458:  BRA    2496
....................          switch (edo2) { 
245A:  MOVLW  01
245C:  SUBWF  x7D,W
245E:  ADDLW  F4
2460:  BC    2492
2462:  ADDLW  0C
2464:  GOTO   2498
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
2468:  BRA    2492
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss2) fse2=1; 
246A:  MOVF   2C,F
246C:  BNZ   2474
246E:  MOVLW  01
2470:  MOVWF  29
2472:  BRA    2476
....................                      else fss2=0; 
2474:  CLRF   2C
....................                      detecta_suma(); 
2476:  RCALL  1FD2
....................                      break;} 
2478:  BRA    2492
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
247A:  RCALL  1FD2
....................                      break;} 
247C:  BRA    2492
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
247E:  BRA    2492
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse2) fss2=1; 
2480:  MOVF   29,F
2482:  BNZ   248A
2484:  MOVLW  01
2486:  MOVWF  2C
2488:  BRA    248C
....................                      else fse2=0; 
248A:  CLRF   29
....................                      detecta_suma(); 
248C:  RCALL  1FD2
....................                      break;} 
248E:  BRA    2492
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
2490:  RCALL  1FD2
....................                      break;} 
....................          } 
....................       enable2=0; 
2492:  CLRF   x81
....................       entra_act2=0; 
2494:  CLRF   x7C
....................    } 
2496:  RETURN 0
.................... } 
....................  
.................... void contando3(){//Revisa maquina de estados para par 3 
....................    if(entra_temp3!=edo3) { 
*
2752:  MOVF   x84,W
2754:  SUBWF  x89,W
2756:  BZ    2760
....................       entra_temp3=edo3; 
2758:  MOVFF  84,89
....................       enable3=1; 
275C:  MOVLW  01
275E:  MOVWF  x88
....................    } 
....................    if (enable3==1){ 
2760:  DECFSZ x88,W
2762:  BRA    27A0
....................          switch (edo3) { 
2764:  MOVLW  01
2766:  SUBWF  x84,W
2768:  ADDLW  F4
276A:  BC    279C
276C:  ADDLW  0C
276E:  GOTO   27A2
....................             case 1: {//LLEGA PERSONA EN ENTRADA1 
....................                      break;} 
2772:  BRA    279C
....................             case 5: {//PERSONA A ENTRADO 
....................                      if(!fss3) fse3=1; 
2774:  MOVF   2D,F
2776:  BNZ   277E
2778:  MOVLW  01
277A:  MOVWF  2A
277C:  BRA    2780
....................                      else fss3=0; 
277E:  CLRF   2D
....................                      detecta_suma(); 
2780:  RCALL  1FD2
....................                      break;} 
2782:  BRA    279C
....................             case 6: {//entraba y se regresa 
....................                      detecta_suma(); 
2784:  RCALL  1FD2
....................                      break;} 
2786:  BRA    279C
....................             case 7: {//PERSONA DETECTADO -SALIENDO 
....................                      break;} 
2788:  BRA    279C
....................             case 11: {//PERSONA A SALIDO 
....................                      if(!fse3) fss3=1; 
278A:  MOVF   2A,F
278C:  BNZ   2794
278E:  MOVLW  01
2790:  MOVWF  2D
2792:  BRA    2796
....................                      else fse3=0; 
2794:  CLRF   2A
....................                      detecta_suma(); 
2796:  RCALL  1FD2
....................                      break;} 
2798:  BRA    279C
....................             case 12: {//SALIA y se regresa 
....................                      detecta_suma(); 
279A:  RCALL  1FD2
....................                      break;} 
....................          } 
....................       enable3=0; 
279C:  CLRF   x88
....................       entra_act3=0; 
279E:  CLRF   x83
....................    } 
27A0:  RETURN 0
.................... } 
....................  
.................... void sensando1(){//Define estados para la maquina de estados del par 1 
.................... /////normal/////// 
.................... if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==0)){//LLEGA PERSONA EN ENTRADA1 
*
1D4C:  MOVF   x75,F
1D4E:  BNZ   1D94
1D50:  DECFSZ x69,W
1D52:  BRA    1D94
1D54:  MOVF   x6A,F
1D56:  BNZ   1D94
1D58:  MOVF   x77,F
1D5A:  BNZ   1D94
1D5C:  MOVF   x78,F
1D5E:  BNZ   1D94
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1D60:  MOVF   5B,F
1D62:  BNZ   1D6A
1D64:  MOVF   5C,F
1D66:  BTFSC  FD8.2
1D68:  RCALL  1D02
....................    lcd_gotoxy(8,2); 
1D6A:  MOVLW  08
1D6C:  MOVLB  1
1D6E:  MOVWF  x90
1D70:  MOVLW  02
1D72:  MOVWF  x91
1D74:  MOVLB  0
1D76:  CALL   0822
....................    lcd_putc(0x7F);//flecha del sentido 
1D7A:  MOVLW  7F
1D7C:  MOVLB  1
1D7E:  MOVWF  x8F
1D80:  MOVLB  0
1D82:  CALL   0874
....................    des1=1; 
1D86:  MOVLW  01
1D88:  MOVWF  x98
....................    //// 
....................    edo1=1; 
1D8A:  MOVWF  x76
....................    entra1=1; 
1D8C:  MOVWF  x77
....................    edoa1=1; 
1D8E:  MOVWF  x79
....................    entra_act1=1;} 
1D90:  MOVWF  x75
1D92:  BRA    1FD0
.................... ///prioridad 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA ENTRANDO 
1D94:  MOVF   x75,F
1D96:  BNZ   1DB4
1D98:  DECFSZ x69,W
1D9A:  BRA    1DB4
1D9C:  DECFSZ x6A,W
1D9E:  BRA    1DB4
1DA0:  DECFSZ x77,W
1DA2:  BRA    1DB4
1DA4:  MOVF   x78,F
1DA6:  BNZ   1DB4
....................    edo1=3; 
1DA8:  MOVLW  03
1DAA:  MOVWF  x76
....................    edoa1=0; 
1DAC:  CLRF   x79
....................    entra_act1=1;} 
1DAE:  MOVLW  01
1DB0:  MOVWF  x75
1DB2:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==1)&&(sale1==0)){//PERSONA CASI TERMINA DE ENTRAR 
1DB4:  MOVF   x75,F
1DB6:  BNZ   1DD2
1DB8:  MOVF   x69,F
1DBA:  BNZ   1DD2
1DBC:  DECFSZ x6A,W
1DBE:  BRA    1DD2
1DC0:  DECFSZ x77,W
1DC2:  BRA    1DD2
1DC4:  MOVF   x78,F
1DC6:  BNZ   1DD2
....................    edo1=4; 
1DC8:  MOVLW  04
1DCA:  MOVWF  x76
....................    entra_act1=1;} 
1DCC:  MOVLW  01
1DCE:  MOVWF  x75
1DD0:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==1)&&(sale1==0)){//PERSONA A ENTRADO 
1DD2:  MOVF   x75,F
1DD4:  BNZ   1E2A
1DD6:  MOVF   x69,F
1DD8:  BNZ   1E2A
1DDA:  MOVF   x6A,F
1DDC:  BNZ   1E2A
1DDE:  MOVF   x79,F
1DE0:  BNZ   1E2A
1DE2:  DECFSZ x77,W
1DE4:  BRA    1E2A
1DE6:  MOVF   x78,F
1DE8:  BNZ   1E2A
....................    lcd_gotoxy(8,2); 
1DEA:  MOVLW  08
1DEC:  MOVLB  1
1DEE:  MOVWF  x90
1DF0:  MOVLW  02
1DF2:  MOVWF  x91
1DF4:  MOVLB  0
1DF6:  CALL   0822
....................    lcd_putc(" "); 
1DFA:  MOVLW  4C
1DFC:  MOVWF  FF6
1DFE:  MOVLW  03
1E00:  MOVWF  FF7
1E02:  CALL   09F8
....................    des1=0; 
1E06:  CLRF   x98
....................    if(entra_temp1==4){ 
1E08:  MOVF   x7B,W
1E0A:  SUBLW  04
1E0C:  BNZ   1E1A
....................       edo1=5; 
1E0E:  MOVLW  05
1E10:  MOVWF  x76
....................       entra1=0; 
1E12:  CLRF   x77
....................       entra_act1=1; 
1E14:  MOVLW  01
1E16:  MOVWF  x75
....................    } 
1E18:  BRA    1E28
....................    else {//entraba y se regresa 
....................       des1=0; 
1E1A:  CLRF   x98
....................       edo1=6; 
1E1C:  MOVLW  06
1E1E:  MOVWF  x76
....................       entra1=0; 
1E20:  CLRF   x77
....................       edoa1=0; 
1E22:  CLRF   x79
....................       entra_act1=1;   
1E24:  MOVLW  01
1E26:  MOVWF  x75
....................    } 
.................... } 
1E28:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==1)&&(sale1==0)){//entraba y se regresa 
1E2A:  MOVF   x75,F
1E2C:  BNZ   1E6E
1E2E:  MOVF   x69,F
1E30:  BNZ   1E6E
1E32:  MOVF   x6A,F
1E34:  BNZ   1E6E
1E36:  DECFSZ x79,W
1E38:  BRA    1E6E
1E3A:  DECFSZ x77,W
1E3C:  BRA    1E6E
1E3E:  MOVF   x78,F
1E40:  BNZ   1E6E
....................    lcd_gotoxy(8,2); 
1E42:  MOVLW  08
1E44:  MOVLB  1
1E46:  MOVWF  x90
1E48:  MOVLW  02
1E4A:  MOVWF  x91
1E4C:  MOVLB  0
1E4E:  CALL   0822
....................    lcd_putc(" "); 
1E52:  MOVLW  4E
1E54:  MOVWF  FF6
1E56:  MOVLW  03
1E58:  MOVWF  FF7
1E5A:  CALL   09F8
....................    des1=0; 
1E5E:  CLRF   x98
....................    edo1=6; 
1E60:  MOVLW  06
1E62:  MOVWF  x76
....................    entra1=0; 
1E64:  CLRF   x77
....................    edoa1=0; 
1E66:  CLRF   x79
....................    entra_act1=1;} 
1E68:  MOVLW  01
1E6A:  MOVWF  x75
1E6C:  BRA    1FD0
.................... ///// 
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==1)&&(sale1==0)){ 
1E6E:  MOVF   x75,F
1E70:  BNZ   1E8E
1E72:  DECFSZ x69,W
1E74:  BRA    1E8E
1E76:  MOVF   x6A,F
1E78:  BNZ   1E8E
1E7A:  DECFSZ x77,W
1E7C:  BRA    1E8E
1E7E:  MOVF   x78,F
1E80:  BNZ   1E8E
....................    edo1=2; 
1E82:  MOVLW  02
1E84:  MOVWF  x76
....................    edoa1=1; 
1E86:  MOVLW  01
1E88:  MOVWF  x79
....................    entra_act1=1;}//checar prioridad 
1E8A:  MOVWF  x75
1E8C:  BRA    1FD0
.................... //////sentido inverso/// 
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
1E8E:  MOVF   x75,F
1E90:  BNZ   1ED8
1E92:  MOVF   x69,F
1E94:  BNZ   1ED8
1E96:  DECFSZ x6A,W
1E98:  BRA    1ED8
1E9A:  MOVF   x77,F
1E9C:  BNZ   1ED8
1E9E:  MOVF   x78,F
1EA0:  BNZ   1ED8
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
1EA2:  MOVF   5B,F
1EA4:  BNZ   1EAC
1EA6:  MOVF   5C,F
1EA8:  BTFSC  FD8.2
1EAA:  RCALL  1D02
....................    lcd_gotoxy(8,2); 
1EAC:  MOVLW  08
1EAE:  MOVLB  1
1EB0:  MOVWF  x90
1EB2:  MOVLW  02
1EB4:  MOVWF  x91
1EB6:  MOVLB  0
1EB8:  CALL   0822
....................    lcd_putc(0x7E);//flecha del sentido 
1EBC:  MOVLW  7E
1EBE:  MOVLB  1
1EC0:  MOVWF  x8F
1EC2:  MOVLB  0
1EC4:  CALL   0874
....................    des1=1; 
1EC8:  MOVLW  01
1ECA:  MOVWF  x98
....................    edo1=7; 
1ECC:  MOVLW  07
1ECE:  MOVWF  x76
....................    sale1=1; 
1ED0:  MOVLW  01
1ED2:  MOVWF  x78
....................    entra_act1=1;} 
1ED4:  MOVWF  x75
1ED6:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 1 
1ED8:  MOVF   x75,F
1EDA:  BNZ   1EF8
1EDC:  MOVF   x69,F
1EDE:  BNZ   1EF8
1EE0:  DECFSZ x6A,W
1EE2:  BRA    1EF8
1EE4:  MOVF   x77,F
1EE6:  BNZ   1EF8
1EE8:  DECFSZ x78,W
1EEA:  BRA    1EF8
....................    edo1=8; 
1EEC:  MOVLW  08
1EEE:  MOVWF  x76
....................    edoa1=1; 
1EF0:  MOVLW  01
1EF2:  MOVWF  x79
....................    entra_act1=1;} 
1EF4:  MOVWF  x75
1EF6:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==1)&&(entra1==0)&&(sale1==1)){//SALIENDO POR ENTRADA PARTE 2 
1EF8:  MOVF   x75,F
1EFA:  BNZ   1F18
1EFC:  DECFSZ x69,W
1EFE:  BRA    1F18
1F00:  DECFSZ x6A,W
1F02:  BRA    1F18
1F04:  MOVF   x77,F
1F06:  BNZ   1F18
1F08:  DECFSZ x78,W
1F0A:  BRA    1F18
....................    edo1=9; 
1F0C:  MOVLW  09
1F0E:  MOVWF  x76
....................    edoa1=0; 
1F10:  CLRF   x79
....................    entra_act1=1;} 
1F12:  MOVLW  01
1F14:  MOVWF  x75
1F16:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==1)&&(detec2==0)&&(entra1==0)&&(sale1==1)){//CASI TERMINA DE SALIR 
1F18:  MOVF   x75,F
1F1A:  BNZ   1F36
1F1C:  DECFSZ x69,W
1F1E:  BRA    1F36
1F20:  MOVF   x6A,F
1F22:  BNZ   1F36
1F24:  MOVF   x77,F
1F26:  BNZ   1F36
1F28:  DECFSZ x78,W
1F2A:  BRA    1F36
....................    edo1=10; 
1F2C:  MOVLW  0A
1F2E:  MOVWF  x76
....................    entra_act1=1;} 
1F30:  MOVLW  01
1F32:  MOVWF  x75
1F34:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==0)&&(entra1==0)&&(sale1==1)){//PERSONA A SALIDO POR ENTRADA 
1F36:  MOVF   x75,F
1F38:  BNZ   1F8E
1F3A:  MOVF   x69,F
1F3C:  BNZ   1F8E
1F3E:  MOVF   x6A,F
1F40:  BNZ   1F8E
1F42:  MOVF   x79,F
1F44:  BNZ   1F8E
1F46:  MOVF   x77,F
1F48:  BNZ   1F8E
1F4A:  DECFSZ x78,W
1F4C:  BRA    1F8E
....................    lcd_gotoxy(8,2); 
1F4E:  MOVLW  08
1F50:  MOVLB  1
1F52:  MOVWF  x90
1F54:  MOVLW  02
1F56:  MOVWF  x91
1F58:  MOVLB  0
1F5A:  CALL   0822
....................    lcd_putc(" "); 
1F5E:  MOVLW  50
1F60:  MOVWF  FF6
1F62:  MOVLW  03
1F64:  MOVWF  FF7
1F66:  CALL   09F8
....................    if(entra_temp1==10) { 
1F6A:  MOVF   x7B,W
1F6C:  SUBLW  0A
1F6E:  BNZ   1F7E
....................       des1=0; 
1F70:  CLRF   x98
....................       edo1=11; 
1F72:  MOVLW  0B
1F74:  MOVWF  x76
....................       sale1=0; 
1F76:  CLRF   x78
....................       entra_act1=1;} 
1F78:  MOVLW  01
1F7A:  MOVWF  x75
1F7C:  BRA    1F8C
....................    else { 
....................       des1=0; 
1F7E:  CLRF   x98
....................       edo1=12; 
1F80:  MOVLW  0C
1F82:  MOVWF  x76
....................       sale1=0; 
1F84:  CLRF   x78
....................       edoa1=0; 
1F86:  CLRF   x79
....................       entra_act1=1; 
1F88:  MOVLW  01
1F8A:  MOVWF  x75
....................    } 
.................... } 
1F8C:  BRA    1FD0
.................... else if((entra_act1==0)&&(detec1==0)&&(detec2==0)&&(edoa1==1)&&(entra1==0)&&(sale1==1)){//SALIA y se regresa 
1F8E:  MOVF   x75,F
1F90:  BNZ   1FD0
1F92:  MOVF   x69,F
1F94:  BNZ   1FD0
1F96:  MOVF   x6A,F
1F98:  BNZ   1FD0
1F9A:  DECFSZ x79,W
1F9C:  BRA    1FD0
1F9E:  MOVF   x77,F
1FA0:  BNZ   1FD0
1FA2:  DECFSZ x78,W
1FA4:  BRA    1FD0
....................    lcd_gotoxy(8,2); 
1FA6:  MOVLW  08
1FA8:  MOVLB  1
1FAA:  MOVWF  x90
1FAC:  MOVLW  02
1FAE:  MOVWF  x91
1FB0:  MOVLB  0
1FB2:  CALL   0822
....................    lcd_putc(" "); 
1FB6:  MOVLW  52
1FB8:  MOVWF  FF6
1FBA:  MOVLW  03
1FBC:  MOVWF  FF7
1FBE:  CALL   09F8
....................    des1=0; 
1FC2:  CLRF   x98
....................    edo1=12; 
1FC4:  MOVLW  0C
1FC6:  MOVWF  x76
....................    sale1=0; 
1FC8:  CLRF   x78
....................    edoa1=0; 
1FCA:  CLRF   x79
....................    entra_act1=1;} 
1FCC:  MOVLW  01
1FCE:  MOVWF  x75
1FD0:  RETURN 0
.................... } 
....................  
.................... void sensando2(){//Define estados para la maquina de estados del par 2 
.................... /////normal/////// 
.................... if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==0)){//LLEGA PERSONA EN ENTRADA1 
*
21C2:  MOVF   x7C,F
21C4:  BNZ   220A
21C6:  DECFSZ x6B,W
21C8:  BRA    220A
21CA:  MOVF   x6C,F
21CC:  BNZ   220A
21CE:  MOVF   x7E,F
21D0:  BNZ   220A
21D2:  MOVF   x7F,F
21D4:  BNZ   220A
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
21D6:  MOVF   5B,F
21D8:  BNZ   21E0
21DA:  MOVF   5C,F
21DC:  BTFSC  FD8.2
21DE:  RCALL  1D02
....................    lcd_gotoxy(8,3); 
21E0:  MOVLW  08
21E2:  MOVLB  1
21E4:  MOVWF  x90
21E6:  MOVLW  03
21E8:  MOVWF  x91
21EA:  MOVLB  0
21EC:  CALL   0822
....................    lcd_putc(0x7F); 
21F0:  MOVLW  7F
21F2:  MOVLB  1
21F4:  MOVWF  x8F
21F6:  MOVLB  0
21F8:  CALL   0874
....................    des2=1; 
21FC:  MOVLW  01
21FE:  MOVWF  x99
....................    edo2=1; 
2200:  MOVWF  x7D
....................    entra2=1; 
2202:  MOVWF  x7E
....................    edoa2=1; 
2204:  MOVWF  x80
....................    entra_act2=1;} 
2206:  MOVWF  x7C
2208:  BRA    2446
.................... ///prioridad 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA ENTRANDO 
220A:  MOVF   x7C,F
220C:  BNZ   222A
220E:  DECFSZ x6B,W
2210:  BRA    222A
2212:  DECFSZ x6C,W
2214:  BRA    222A
2216:  DECFSZ x7E,W
2218:  BRA    222A
221A:  MOVF   x7F,F
221C:  BNZ   222A
....................    edo2=3; 
221E:  MOVLW  03
2220:  MOVWF  x7D
....................    edoa2=0; 
2222:  CLRF   x80
....................    entra_act2=1;} 
2224:  MOVLW  01
2226:  MOVWF  x7C
2228:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==1)&&(sale2==0)){//PERSONA CASI TERMINA DE ENTRAR 
222A:  MOVF   x7C,F
222C:  BNZ   2248
222E:  MOVF   x6B,F
2230:  BNZ   2248
2232:  DECFSZ x6C,W
2234:  BRA    2248
2236:  DECFSZ x7E,W
2238:  BRA    2248
223A:  MOVF   x7F,F
223C:  BNZ   2248
....................    edo2=4; 
223E:  MOVLW  04
2240:  MOVWF  x7D
....................    entra_act2=1;} 
2242:  MOVLW  01
2244:  MOVWF  x7C
2246:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==1)&&(sale2==0)){//PERSONA A ENTRADO 
2248:  MOVF   x7C,F
224A:  BNZ   22A0
224C:  MOVF   x6B,F
224E:  BNZ   22A0
2250:  MOVF   x6C,F
2252:  BNZ   22A0
2254:  MOVF   x80,F
2256:  BNZ   22A0
2258:  DECFSZ x7E,W
225A:  BRA    22A0
225C:  MOVF   x7F,F
225E:  BNZ   22A0
....................    lcd_gotoxy(8,3); 
2260:  MOVLW  08
2262:  MOVLB  1
2264:  MOVWF  x90
2266:  MOVLW  03
2268:  MOVWF  x91
226A:  MOVLB  0
226C:  CALL   0822
....................    lcd_putc(" "); 
2270:  MOVLW  54
2272:  MOVWF  FF6
2274:  MOVLW  03
2276:  MOVWF  FF7
2278:  CALL   09F8
....................    if(entra_temp2==4){ 
227C:  MOVF   x82,W
227E:  SUBLW  04
2280:  BNZ   2290
....................       des2=0; 
2282:  CLRF   x99
....................       edo2=5; 
2284:  MOVLW  05
2286:  MOVWF  x7D
....................       entra2=0; 
2288:  CLRF   x7E
....................       entra_act2=1;} 
228A:  MOVLW  01
228C:  MOVWF  x7C
228E:  BRA    229E
....................    else{ 
....................       des2=0; 
2290:  CLRF   x99
....................       edo2=6; 
2292:  MOVLW  06
2294:  MOVWF  x7D
....................       entra2=0; 
2296:  CLRF   x7E
....................       edoa2=0; 
2298:  CLRF   x80
....................       entra_act2=1;} 
229A:  MOVLW  01
229C:  MOVWF  x7C
.................... } 
229E:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==1)&&(sale2==0)){//entraba y se regresa 
22A0:  MOVF   x7C,F
22A2:  BNZ   22E4
22A4:  MOVF   x6B,F
22A6:  BNZ   22E4
22A8:  MOVF   x6C,F
22AA:  BNZ   22E4
22AC:  DECFSZ x80,W
22AE:  BRA    22E4
22B0:  DECFSZ x7E,W
22B2:  BRA    22E4
22B4:  MOVF   x7F,F
22B6:  BNZ   22E4
....................    lcd_gotoxy(8,3); 
22B8:  MOVLW  08
22BA:  MOVLB  1
22BC:  MOVWF  x90
22BE:  MOVLW  03
22C0:  MOVWF  x91
22C2:  MOVLB  0
22C4:  CALL   0822
....................    lcd_putc(" "); 
22C8:  MOVLW  56
22CA:  MOVWF  FF6
22CC:  MOVLW  03
22CE:  MOVWF  FF7
22D0:  CALL   09F8
....................    des2=0; 
22D4:  CLRF   x99
....................    edo2=6; 
22D6:  MOVLW  06
22D8:  MOVWF  x7D
....................    entra2=0; 
22DA:  CLRF   x7E
....................    edoa2=0; 
22DC:  CLRF   x80
....................    entra_act2=1;} 
22DE:  MOVLW  01
22E0:  MOVWF  x7C
22E2:  BRA    2446
.................... ///// 
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==1)&&(sale2==0)){ 
22E4:  MOVF   x7C,F
22E6:  BNZ   2304
22E8:  DECFSZ x6B,W
22EA:  BRA    2304
22EC:  MOVF   x6C,F
22EE:  BNZ   2304
22F0:  DECFSZ x7E,W
22F2:  BRA    2304
22F4:  MOVF   x7F,F
22F6:  BNZ   2304
....................    edo2=2; 
22F8:  MOVLW  02
22FA:  MOVWF  x7D
....................    edoa2=1; 
22FC:  MOVLW  01
22FE:  MOVWF  x80
....................    entra_act2=1;}//checar prioridad 
2300:  MOVWF  x7C
2302:  BRA    2446
.................... //////sentido inverso/// 
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
2304:  MOVF   x7C,F
2306:  BNZ   234E
2308:  MOVF   x6B,F
230A:  BNZ   234E
230C:  DECFSZ x6C,W
230E:  BRA    234E
2310:  MOVF   x7E,F
2312:  BNZ   234E
2314:  MOVF   x7F,F
2316:  BNZ   234E
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2318:  MOVF   5B,F
231A:  BNZ   2322
231C:  MOVF   5C,F
231E:  BTFSC  FD8.2
2320:  RCALL  1D02
....................    lcd_gotoxy(8,3); 
2322:  MOVLW  08
2324:  MOVLB  1
2326:  MOVWF  x90
2328:  MOVLW  03
232A:  MOVWF  x91
232C:  MOVLB  0
232E:  CALL   0822
....................    lcd_putc(0x7E);//flecha del sentido 
2332:  MOVLW  7E
2334:  MOVLB  1
2336:  MOVWF  x8F
2338:  MOVLB  0
233A:  CALL   0874
....................    des2=1; 
233E:  MOVLW  01
2340:  MOVWF  x99
....................    edo2=7; 
2342:  MOVLW  07
2344:  MOVWF  x7D
....................    sale2=1; 
2346:  MOVLW  01
2348:  MOVWF  x7F
....................    entra_act2=1;} 
234A:  MOVWF  x7C
234C:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 1 
234E:  MOVF   x7C,F
2350:  BNZ   236E
2352:  MOVF   x6B,F
2354:  BNZ   236E
2356:  DECFSZ x6C,W
2358:  BRA    236E
235A:  MOVF   x7E,F
235C:  BNZ   236E
235E:  DECFSZ x7F,W
2360:  BRA    236E
....................    edo2=8; 
2362:  MOVLW  08
2364:  MOVWF  x7D
....................    edoa2=1; 
2366:  MOVLW  01
2368:  MOVWF  x80
....................    entra_act2=1;} 
236A:  MOVWF  x7C
236C:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==1)&&(entra2==0)&&(sale2==1)){//SALIENDO POR ENTRADA PARTE 2 
236E:  MOVF   x7C,F
2370:  BNZ   238E
2372:  DECFSZ x6B,W
2374:  BRA    238E
2376:  DECFSZ x6C,W
2378:  BRA    238E
237A:  MOVF   x7E,F
237C:  BNZ   238E
237E:  DECFSZ x7F,W
2380:  BRA    238E
....................    edo2=9; 
2382:  MOVLW  09
2384:  MOVWF  x7D
....................    edoa2=0; 
2386:  CLRF   x80
....................    entra_act2=1;} 
2388:  MOVLW  01
238A:  MOVWF  x7C
238C:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==1)&&(detec4==0)&&(entra2==0)&&(sale2==1)){//CASI TERMINA DE SALIR 
238E:  MOVF   x7C,F
2390:  BNZ   23AC
2392:  DECFSZ x6B,W
2394:  BRA    23AC
2396:  MOVF   x6C,F
2398:  BNZ   23AC
239A:  MOVF   x7E,F
239C:  BNZ   23AC
239E:  DECFSZ x7F,W
23A0:  BRA    23AC
....................    edo2=10; 
23A2:  MOVLW  0A
23A4:  MOVWF  x7D
....................    entra_act2=1;} 
23A6:  MOVLW  01
23A8:  MOVWF  x7C
23AA:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==0)&&(entra2==0)&&(sale2==1)){//PERSONA A SALIDO POR ENTRADA 
23AC:  MOVF   x7C,F
23AE:  BNZ   2404
23B0:  MOVF   x6B,F
23B2:  BNZ   2404
23B4:  MOVF   x6C,F
23B6:  BNZ   2404
23B8:  MOVF   x80,F
23BA:  BNZ   2404
23BC:  MOVF   x7E,F
23BE:  BNZ   2404
23C0:  DECFSZ x7F,W
23C2:  BRA    2404
....................    lcd_gotoxy(8,3); 
23C4:  MOVLW  08
23C6:  MOVLB  1
23C8:  MOVWF  x90
23CA:  MOVLW  03
23CC:  MOVWF  x91
23CE:  MOVLB  0
23D0:  CALL   0822
....................    lcd_putc(" "); 
23D4:  MOVLW  58
23D6:  MOVWF  FF6
23D8:  MOVLW  03
23DA:  MOVWF  FF7
23DC:  CALL   09F8
....................    if(entra_temp2==10){ 
23E0:  MOVF   x82,W
23E2:  SUBLW  0A
23E4:  BNZ   23F4
....................       des2=0; 
23E6:  CLRF   x99
....................       edo2=11; 
23E8:  MOVLW  0B
23EA:  MOVWF  x7D
....................       sale2=0; 
23EC:  CLRF   x7F
....................       entra_act2=1;} 
23EE:  MOVLW  01
23F0:  MOVWF  x7C
23F2:  BRA    2402
....................    else{ 
....................       des2=0; 
23F4:  CLRF   x99
....................       edo2=12; 
23F6:  MOVLW  0C
23F8:  MOVWF  x7D
....................       sale2=0; 
23FA:  CLRF   x7F
....................       edoa2=0; 
23FC:  CLRF   x80
....................       entra_act2=1;} 
23FE:  MOVLW  01
2400:  MOVWF  x7C
.................... } 
2402:  BRA    2446
.................... else if((entra_act2==0)&&(detec3==0)&&(detec4==0)&&(edoa2==1)&&(entra2==0)&&(sale2==1)){//SALIA y se regresa 
2404:  MOVF   x7C,F
2406:  BNZ   2446
2408:  MOVF   x6B,F
240A:  BNZ   2446
240C:  MOVF   x6C,F
240E:  BNZ   2446
2410:  DECFSZ x80,W
2412:  BRA    2446
2414:  MOVF   x7E,F
2416:  BNZ   2446
2418:  DECFSZ x7F,W
241A:  BRA    2446
....................    lcd_gotoxy(8,3); 
241C:  MOVLW  08
241E:  MOVLB  1
2420:  MOVWF  x90
2422:  MOVLW  03
2424:  MOVWF  x91
2426:  MOVLB  0
2428:  CALL   0822
....................    lcd_putc(" "); 
242C:  MOVLW  5A
242E:  MOVWF  FF6
2430:  MOVLW  03
2432:  MOVWF  FF7
2434:  CALL   09F8
....................    des2=0; 
2438:  CLRF   x99
....................    edo2=12; 
243A:  MOVLW  0C
243C:  MOVWF  x7D
....................    sale2=0; 
243E:  CLRF   x7F
....................    edoa2=0; 
2440:  CLRF   x80
....................    entra_act2=1;} 
2442:  MOVLW  01
2444:  MOVWF  x7C
2446:  RETURN 0
.................... } 
....................  
.................... void sensando3(){//Define estados para la maquina de estados del par 3 
.................... /////normal/////// 
.................... if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==0)){//LLEGA PERSONA EN ENTRADA1 
*
24CA:  MOVF   x83,F
24CC:  BNZ   2512
24CE:  DECFSZ x6D,W
24D0:  BRA    2512
24D2:  MOVF   x6E,F
24D4:  BNZ   2512
24D6:  MOVF   x85,F
24D8:  BNZ   2512
24DA:  MOVF   x86,F
24DC:  BNZ   2512
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
24DE:  MOVF   5B,F
24E0:  BNZ   24E8
24E2:  MOVF   5C,F
24E4:  BTFSC  FD8.2
24E6:  RCALL  1D02
....................    lcd_gotoxy(8,4); 
24E8:  MOVLW  08
24EA:  MOVLB  1
24EC:  MOVWF  x90
24EE:  MOVLW  04
24F0:  MOVWF  x91
24F2:  MOVLB  0
24F4:  CALL   0822
....................    lcd_putc(0x7F); 
24F8:  MOVLW  7F
24FA:  MOVLB  1
24FC:  MOVWF  x8F
24FE:  MOVLB  0
2500:  CALL   0874
....................    des3=1; 
2504:  MOVLW  01
2506:  MOVWF  x9A
....................    edo3=1; 
2508:  MOVWF  x84
....................    entra3=1; 
250A:  MOVWF  x85
....................    edoa3=1; 
250C:  MOVWF  x87
....................    entra_act3=1;} 
250E:  MOVWF  x83
2510:  BRA    2750
.................... ///prioridad 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA ENTRANDO 
2512:  MOVF   x83,F
2514:  BNZ   2532
2516:  DECFSZ x6D,W
2518:  BRA    2532
251A:  DECFSZ x6E,W
251C:  BRA    2532
251E:  DECFSZ x85,W
2520:  BRA    2532
2522:  MOVF   x86,F
2524:  BNZ   2532
....................    edo3=3; 
2526:  MOVLW  03
2528:  MOVWF  x84
....................    edoa3=0; 
252A:  CLRF   x87
....................    entra_act3=1;} 
252C:  MOVLW  01
252E:  MOVWF  x83
2530:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==1)&&(sale3==0)){//PERSONA CASI TERMINA DE ENTRAR 
2532:  MOVF   x83,F
2534:  BNZ   2550
2536:  MOVF   x6D,F
2538:  BNZ   2550
253A:  DECFSZ x6E,W
253C:  BRA    2550
253E:  DECFSZ x85,W
2540:  BRA    2550
2542:  MOVF   x86,F
2544:  BNZ   2550
....................    edo3=4; 
2546:  MOVLW  04
2548:  MOVWF  x84
....................    entra_act3=1;} 
254A:  MOVLW  01
254C:  MOVWF  x83
254E:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==1)&&(sale3==0)){//PERSONA A ENTRADO 
2550:  MOVF   x83,F
2552:  BNZ   25A8
2554:  MOVF   x6D,F
2556:  BNZ   25A8
2558:  MOVF   x6E,F
255A:  BNZ   25A8
255C:  MOVF   x87,F
255E:  BNZ   25A8
2560:  DECFSZ x85,W
2562:  BRA    25A8
2564:  MOVF   x86,F
2566:  BNZ   25A8
....................    lcd_gotoxy(8,4); 
2568:  MOVLW  08
256A:  MOVLB  1
256C:  MOVWF  x90
256E:  MOVLW  04
2570:  MOVWF  x91
2572:  MOVLB  0
2574:  CALL   0822
....................    lcd_putc(" "); 
2578:  MOVLW  5C
257A:  MOVWF  FF6
257C:  MOVLW  03
257E:  MOVWF  FF7
2580:  CALL   09F8
....................    if(entra_temp3==4){ 
2584:  MOVF   x89,W
2586:  SUBLW  04
2588:  BNZ   2598
....................       des3=0; 
258A:  CLRF   x9A
....................       edo3=5; 
258C:  MOVLW  05
258E:  MOVWF  x84
....................       entra3=0; 
2590:  CLRF   x85
....................       entra_act3=1;} 
2592:  MOVLW  01
2594:  MOVWF  x83
2596:  BRA    25A6
....................    else{ 
....................       des3=0; 
2598:  CLRF   x9A
....................       edo3=6; 
259A:  MOVLW  06
259C:  MOVWF  x84
....................       entra3=0; 
259E:  CLRF   x85
....................       edoa3=0; 
25A0:  CLRF   x87
....................       entra_act3=1;} 
25A2:  MOVLW  01
25A4:  MOVWF  x83
.................... } 
25A6:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==1)&&(sale3==0)){//entraba y se regresa 
25A8:  MOVF   x83,F
25AA:  BNZ   25EC
25AC:  MOVF   x6D,F
25AE:  BNZ   25EC
25B0:  MOVF   x6E,F
25B2:  BNZ   25EC
25B4:  DECFSZ x87,W
25B6:  BRA    25EC
25B8:  DECFSZ x85,W
25BA:  BRA    25EC
25BC:  MOVF   x86,F
25BE:  BNZ   25EC
....................    lcd_gotoxy(8,4); 
25C0:  MOVLW  08
25C2:  MOVLB  1
25C4:  MOVWF  x90
25C6:  MOVLW  04
25C8:  MOVWF  x91
25CA:  MOVLB  0
25CC:  CALL   0822
....................    lcd_putc(" "); 
25D0:  MOVLW  5E
25D2:  MOVWF  FF6
25D4:  MOVLW  03
25D6:  MOVWF  FF7
25D8:  CALL   09F8
....................    des3=0; 
25DC:  CLRF   x9A
....................    edo3=6; 
25DE:  MOVLW  06
25E0:  MOVWF  x84
....................    entra3=0; 
25E2:  CLRF   x85
....................    edoa3=0; 
25E4:  CLRF   x87
....................    entra_act3=1;} 
25E6:  MOVLW  01
25E8:  MOVWF  x83
25EA:  BRA    2750
.................... ///// 
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==1)&&(sale3==0)){ 
25EC:  MOVF   x83,F
25EE:  BNZ   260C
25F0:  DECFSZ x6D,W
25F2:  BRA    260C
25F4:  MOVF   x6E,F
25F6:  BNZ   260C
25F8:  DECFSZ x85,W
25FA:  BRA    260C
25FC:  MOVF   x86,F
25FE:  BNZ   260C
....................    //sentidos(); 
....................    edo3=2; 
2600:  MOVLW  02
2602:  MOVWF  x84
....................    edoa3=1; 
2604:  MOVLW  01
2606:  MOVWF  x87
....................    entra_act3=1;}//checar prioridad 
2608:  MOVWF  x83
260A:  BRA    2750
.................... //////sentido inverso/// 
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==0)){//PERSONA DETECTADO -SALIENDO POR ENTRADA 
260C:  MOVF   x83,F
260E:  BNZ   2658
2610:  MOVF   x6D,F
2612:  BNZ   2658
2614:  DECFSZ x6E,W
2616:  BRA    2658
2618:  MOVF   x85,F
261A:  BNZ   2658
261C:  MOVF   x86,F
261E:  BNZ   2658
....................    if( (sen_ent==0)&&(sen_sal==0) ) sentidos(); 
2620:  MOVF   5B,F
2622:  BNZ   262C
2624:  MOVF   5C,F
2626:  BTFSC  FD8.2
2628:  CALL   1D02
....................    lcd_gotoxy(8,4); 
262C:  MOVLW  08
262E:  MOVLB  1
2630:  MOVWF  x90
2632:  MOVLW  04
2634:  MOVWF  x91
2636:  MOVLB  0
2638:  CALL   0822
....................    lcd_putc(0x7E);//flecha del sentido 
263C:  MOVLW  7E
263E:  MOVLB  1
2640:  MOVWF  x8F
2642:  MOVLB  0
2644:  CALL   0874
....................    des3=1; 
2648:  MOVLW  01
264A:  MOVWF  x9A
....................    edo3=7; 
264C:  MOVLW  07
264E:  MOVWF  x84
....................    sale3=1; 
2650:  MOVLW  01
2652:  MOVWF  x86
....................    entra_act3=1;} 
2654:  MOVWF  x83
2656:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 1 
2658:  MOVF   x83,F
265A:  BNZ   2678
265C:  MOVF   x6D,F
265E:  BNZ   2678
2660:  DECFSZ x6E,W
2662:  BRA    2678
2664:  MOVF   x85,F
2666:  BNZ   2678
2668:  DECFSZ x86,W
266A:  BRA    2678
....................    edo3=8; 
266C:  MOVLW  08
266E:  MOVWF  x84
....................    edoa3=1; 
2670:  MOVLW  01
2672:  MOVWF  x87
....................    entra_act3=1;} 
2674:  MOVWF  x83
2676:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==1)&&(entra3==0)&&(sale3==1)){//SALIENDO POR ENTRADA PARTE 2 
2678:  MOVF   x83,F
267A:  BNZ   2698
267C:  DECFSZ x6D,W
267E:  BRA    2698
2680:  DECFSZ x6E,W
2682:  BRA    2698
2684:  MOVF   x85,F
2686:  BNZ   2698
2688:  DECFSZ x86,W
268A:  BRA    2698
....................    edo3=9; 
268C:  MOVLW  09
268E:  MOVWF  x84
....................    edoa3=0; 
2690:  CLRF   x87
....................    entra_act3=1;} 
2692:  MOVLW  01
2694:  MOVWF  x83
2696:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==1)&&(detec6==0)&&(entra3==0)&&(sale3==1)){//CASI TERMINA DE SALIR 
2698:  MOVF   x83,F
269A:  BNZ   26B6
269C:  DECFSZ x6D,W
269E:  BRA    26B6
26A0:  MOVF   x6E,F
26A2:  BNZ   26B6
26A4:  MOVF   x85,F
26A6:  BNZ   26B6
26A8:  DECFSZ x86,W
26AA:  BRA    26B6
....................    edo3=10; 
26AC:  MOVLW  0A
26AE:  MOVWF  x84
....................    entra_act3=1;} 
26B0:  MOVLW  01
26B2:  MOVWF  x83
26B4:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==0)&&(entra3==0)&&(sale3==1)){//PERSONA A SALIDO POR ENTRADA 
26B6:  MOVF   x83,F
26B8:  BNZ   270E
26BA:  MOVF   x6D,F
26BC:  BNZ   270E
26BE:  MOVF   x6E,F
26C0:  BNZ   270E
26C2:  MOVF   x87,F
26C4:  BNZ   270E
26C6:  MOVF   x85,F
26C8:  BNZ   270E
26CA:  DECFSZ x86,W
26CC:  BRA    270E
....................    lcd_gotoxy(8,4); 
26CE:  MOVLW  08
26D0:  MOVLB  1
26D2:  MOVWF  x90
26D4:  MOVLW  04
26D6:  MOVWF  x91
26D8:  MOVLB  0
26DA:  CALL   0822
....................    lcd_putc(" "); 
26DE:  MOVLW  60
26E0:  MOVWF  FF6
26E2:  MOVLW  03
26E4:  MOVWF  FF7
26E6:  CALL   09F8
....................    if(entra_temp3==10){ 
26EA:  MOVF   x89,W
26EC:  SUBLW  0A
26EE:  BNZ   26FE
....................       des3=0; 
26F0:  CLRF   x9A
....................       edo3=11; 
26F2:  MOVLW  0B
26F4:  MOVWF  x84
....................       sale3=0; 
26F6:  CLRF   x86
....................       entra_act3=1;} 
26F8:  MOVLW  01
26FA:  MOVWF  x83
26FC:  BRA    270C
....................    else{ 
....................       des3=0; 
26FE:  CLRF   x9A
....................       edo3=12; 
2700:  MOVLW  0C
2702:  MOVWF  x84
....................       sale3=0; 
2704:  CLRF   x86
....................       edoa3=0; 
2706:  CLRF   x87
....................       entra_act3=1;} 
2708:  MOVLW  01
270A:  MOVWF  x83
.................... } 
270C:  BRA    2750
.................... else if((entra_act3==0)&&(detec5==0)&&(detec6==0)&&(edoa3==1)&&(entra3==0)&&(sale3==1)){//SALIA y se regresa 
270E:  MOVF   x83,F
2710:  BNZ   2750
2712:  MOVF   x6D,F
2714:  BNZ   2750
2716:  MOVF   x6E,F
2718:  BNZ   2750
271A:  DECFSZ x87,W
271C:  BRA    2750
271E:  MOVF   x85,F
2720:  BNZ   2750
2722:  DECFSZ x86,W
2724:  BRA    2750
....................    lcd_gotoxy(8,4); 
2726:  MOVLW  08
2728:  MOVLB  1
272A:  MOVWF  x90
272C:  MOVLW  04
272E:  MOVWF  x91
2730:  MOVLB  0
2732:  CALL   0822
....................    lcd_putc(" "); 
2736:  MOVLW  62
2738:  MOVWF  FF6
273A:  MOVLW  03
273C:  MOVWF  FF7
273E:  CALL   09F8
....................    des3=0; 
2742:  CLRF   x9A
....................    edo3=12; 
2744:  MOVLW  0C
2746:  MOVWF  x84
....................    sale3=0; 
2748:  CLRF   x86
....................    edoa3=0; 
274A:  CLRF   x87
....................    entra_act3=1;} 
274C:  MOVLW  01
274E:  MOVWF  x83
2750:  RETURN 0
.................... } 
....................  
.................... void sensores(){//Detecta estado (bloqueado o libre) de los sensores 
.................... //sensor1 
.................... ent1=input(entrada01); 
*
27D4:  BSF    F93.4
27D6:  CLRF   55
27D8:  BTFSC  F81.4
27DA:  INCF   55,F
.................... if(ent1==1){ 
27DC:  DECFSZ 55,W
27DE:  BRA    27F8
....................    sub_cta1=0; 
27E0:  CLRF   5E
27E2:  CLRF   5D
....................    detec1=0; 
27E4:  CLRF   x69
....................    bloq_p1=0;//deshabilita bloqueo par1 
27E6:  CLRF   x9B
....................    tim_p1=0; 
27E8:  CLRF   xA2
27EA:  CLRF   xA1
....................    if(en_b1) {//pregunta si esta sonando el par1 
27EC:  MOVF   x9E,F
27EE:  BZ    27F6
....................       output_low(salida01);//apaga alarma bloqueo 
27F0:  BCF    F94.3
27F2:  BCF    F8B.3
....................       en_b1=0; 
27F4:  CLRF   x9E
....................    } 
.................... } 
27F6:  BRA    2852
.................... else { 
....................    if(sub_cta1>=s_cta) detec1=1;//revisa si se interumpio la luz en (5ms*4) 
27F8:  MOVF   5E,F
27FA:  BNZ   2802
27FC:  MOVF   5D,W
27FE:  SUBLW  04
2800:  BC    2806
2802:  MOVLW  01
2804:  MOVWF  x69
....................    if(sub_d1!=detec1) {//si, cambia de estado el sensor 
2806:  MOVF   x69,W
2808:  SUBWF  x6F,W
280A:  BZ    2852
....................       sub_d1=detec1; 
280C:  MOVFF  69,6F
....................       enable1=1; 
2810:  MOVLW  01
2812:  MOVWF  x7A
....................       lcd_gotoxy(5,2); 
2814:  MOVLW  05
2816:  MOVLB  1
2818:  MOVWF  x90
281A:  MOVLW  02
281C:  MOVWF  x91
281E:  MOVLB  0
2820:  CALL   0822
....................       printf(lcd_putc,"1:%d",sub_d1); 
2824:  MOVLW  31
2826:  MOVLB  1
2828:  MOVWF  x8F
282A:  MOVLB  0
282C:  CALL   0874
2830:  MOVLW  3A
2832:  MOVLB  1
2834:  MOVWF  x8F
2836:  MOVLB  0
2838:  CALL   0874
283C:  MOVFF  6F,186
2840:  MOVLW  18
2842:  MOVLB  1
2844:  MOVWF  x87
2846:  MOVLB  0
2848:  CALL   106A
....................       sensando1(); 
284C:  CALL   1D4C
....................       contando1(); 
2850:  RCALL  2140
....................    } 
.................... } 
.................... //sensor2 
.................... ent2=input(entrada02); 
2852:  BSF    F95.4
2854:  CLRF   56
2856:  BTFSC  F83.4
2858:  INCF   56,F
.................... if(ent2==1){ 
285A:  DECFSZ 56,W
285C:  BRA    287A
....................    output_high(salida02);// 
285E:  BCF    F94.4
2860:  BSF    F8B.4
....................    sub_cta2=0; 
2862:  CLRF   x60
2864:  CLRF   5F
....................    detec2=0; 
2866:  CLRF   x6A
....................    bloq_p1=0;//deshabilita bloqueo 
2868:  CLRF   x9B
....................    tim_p1=0; 
286A:  CLRF   xA2
286C:  CLRF   xA1
....................    if(en_b1) { 
286E:  MOVF   x9E,F
2870:  BZ    2878
....................       output_low(salida01);//apaga alarma bloqueo 
2872:  BCF    F94.3
2874:  BCF    F8B.3
....................       en_b1=0; 
2876:  CLRF   x9E
....................    } 
.................... } 
2878:  BRA    28E2
.................... else { 
....................    output_low(salida02); 
287A:  BCF    F94.4
287C:  BCF    F8B.4
....................    if(sub_cta2>=s_cta) detec2=1; 
287E:  MOVF   x60,F
2880:  BNZ   2888
2882:  MOVF   5F,W
2884:  SUBLW  04
2886:  BC    288C
2888:  MOVLW  01
288A:  MOVWF  x6A
....................    if(sub_d2!=detec2) { 
288C:  MOVF   x6A,W
288E:  SUBWF  x70,W
2890:  BZ    28E2
....................       sub_d2=detec2; 
2892:  MOVFF  6A,70
....................       enable1=1; 
2896:  MOVLW  01
2898:  MOVWF  x7A
....................       lcd_gotoxy(1,2); 
289A:  MOVLB  1
289C:  MOVWF  x90
289E:  MOVLW  02
28A0:  MOVWF  x91
28A2:  MOVLB  0
28A4:  CALL   0822
....................       printf(lcd_putc,"2:%d ",sub_d2); 
28A8:  MOVLW  32
28AA:  MOVLB  1
28AC:  MOVWF  x8F
28AE:  MOVLB  0
28B0:  CALL   0874
28B4:  MOVLW  3A
28B6:  MOVLB  1
28B8:  MOVWF  x8F
28BA:  MOVLB  0
28BC:  CALL   0874
28C0:  MOVFF  70,186
28C4:  MOVLW  18
28C6:  MOVLB  1
28C8:  MOVWF  x87
28CA:  MOVLB  0
28CC:  CALL   106A
28D0:  MOVLW  20
28D2:  MOVLB  1
28D4:  MOVWF  x8F
28D6:  MOVLB  0
28D8:  CALL   0874
....................       sensando1(); 
28DC:  CALL   1D4C
....................       contando1(); 
28E0:  RCALL  2140
....................    } 
.................... } 
.................... //sensor3 
.................... ent3=input(entrada03); 
28E2:  BSF    F93.2
28E4:  CLRF   57
28E6:  BTFSC  F81.2
28E8:  INCF   57,F
.................... if(ent3==1){ 
28EA:  DECFSZ 57,W
28EC:  BRA    2906
....................    sub_cta3=0; 
28EE:  CLRF   x62
28F0:  CLRF   x61
....................    detec3=0; 
28F2:  CLRF   x6B
....................    bloq_p2=0;//deshabilita bloqueo 
28F4:  CLRF   x9C
....................    tim_p2=0; 
28F6:  CLRF   xA4
28F8:  CLRF   xA3
....................    if(en_b2) { 
28FA:  MOVF   x9F,F
28FC:  BZ    2904
....................       output_low(salida01);//apaga alarma bloqueo 
28FE:  BCF    F94.3
2900:  BCF    F8B.3
....................       en_b2=0; 
2902:  CLRF   x9F
....................    } 
.................... } 
2904:  BRA    295E
.................... else { 
....................    if(sub_cta3>=s_cta) detec3=1; 
2906:  MOVF   x62,F
2908:  BNZ   2910
290A:  MOVF   x61,W
290C:  SUBLW  04
290E:  BC    2914
2910:  MOVLW  01
2912:  MOVWF  x6B
....................    if(sub_d3!=detec3) { 
2914:  MOVF   x6B,W
2916:  SUBWF  x71,W
2918:  BZ    295E
....................       sub_d3=detec3; 
291A:  MOVFF  6B,71
....................       enable2=1; 
291E:  MOVLW  01
2920:  MOVWF  x81
....................       lcd_gotoxy(5,3); 
2922:  MOVLW  05
2924:  MOVLB  1
2926:  MOVWF  x90
2928:  MOVLW  03
292A:  MOVWF  x91
292C:  MOVLB  0
292E:  CALL   0822
....................       printf(lcd_putc,"3:%d",sub_d3); 
2932:  MOVLW  33
2934:  MOVLB  1
2936:  MOVWF  x8F
2938:  MOVLB  0
293A:  CALL   0874
293E:  MOVLW  3A
2940:  MOVLB  1
2942:  MOVWF  x8F
2944:  MOVLB  0
2946:  CALL   0874
294A:  MOVFF  71,186
294E:  MOVLW  18
2950:  MOVLB  1
2952:  MOVWF  x87
2954:  MOVLB  0
2956:  CALL   106A
....................       sensando2(); 
295A:  RCALL  21C2
....................       contando2(); 
295C:  RCALL  2448
....................    } 
.................... } 
.................... //sensor4 
.................... ent4=input(entrada04); 
295E:  BSF    F93.3
2960:  CLRF   58
2962:  BTFSC  F81.3
2964:  INCF   58,F
.................... if(ent4==1){ 
2966:  DECFSZ 58,W
2968:  BRA    2986
....................    output_high(salida02);// 
296A:  BCF    F94.4
296C:  BSF    F8B.4
....................    sub_cta4=0; 
296E:  CLRF   x64
2970:  CLRF   x63
....................    detec4=0; 
2972:  CLRF   x6C
....................    bloq_p2=0;//deshabilita bloqueo 
2974:  CLRF   x9C
....................    tim_p2=0; 
2976:  CLRF   xA4
2978:  CLRF   xA3
....................    if(en_b2) { 
297A:  MOVF   x9F,F
297C:  BZ    2984
....................       output_low(salida01);//apaga alarma bloqueo 
297E:  BCF    F94.3
2980:  BCF    F8B.3
....................       en_b2=0; 
2982:  CLRF   x9F
....................    } 
.................... } 
2984:  BRA    29EE
.................... else { 
....................     output_low(salida02); 
2986:  BCF    F94.4
2988:  BCF    F8B.4
....................     if(sub_cta4>=s_cta) detec4=1; 
298A:  MOVF   x64,F
298C:  BNZ   2994
298E:  MOVF   x63,W
2990:  SUBLW  04
2992:  BC    2998
2994:  MOVLW  01
2996:  MOVWF  x6C
....................     if(sub_d4!=detec4) { 
2998:  MOVF   x6C,W
299A:  SUBWF  x72,W
299C:  BZ    29EE
....................       sub_d4=detec4; 
299E:  MOVFF  6C,72
....................       enable2=1; 
29A2:  MOVLW  01
29A4:  MOVWF  x81
....................       lcd_gotoxy(1,3); 
29A6:  MOVLB  1
29A8:  MOVWF  x90
29AA:  MOVLW  03
29AC:  MOVWF  x91
29AE:  MOVLB  0
29B0:  CALL   0822
....................       printf(lcd_putc,"4:%d ",sub_d4); 
29B4:  MOVLW  34
29B6:  MOVLB  1
29B8:  MOVWF  x8F
29BA:  MOVLB  0
29BC:  CALL   0874
29C0:  MOVLW  3A
29C2:  MOVLB  1
29C4:  MOVWF  x8F
29C6:  MOVLB  0
29C8:  CALL   0874
29CC:  MOVFF  72,186
29D0:  MOVLW  18
29D2:  MOVLB  1
29D4:  MOVWF  x87
29D6:  MOVLB  0
29D8:  CALL   106A
29DC:  MOVLW  20
29DE:  MOVLB  1
29E0:  MOVWF  x8F
29E2:  MOVLB  0
29E4:  CALL   0874
....................       sensando2(); 
29E8:  CALL   21C2
....................       contando2(); 
29EC:  RCALL  2448
....................    } 
.................... } 
.................... //sensor5 
.................... ent5=input(entrada05); 
29EE:  BSF    F93.0
29F0:  CLRF   59
29F2:  BTFSC  F81.0
29F4:  INCF   59,F
.................... if(ent5==1){ 
29F6:  DECFSZ 59,W
29F8:  BRA    2A12
....................    sub_cta5=0; 
29FA:  CLRF   x66
29FC:  CLRF   x65
....................    detec5=0; 
29FE:  CLRF   x6D
....................    bloq_p3=0;//deshabilita bloqueo 
2A00:  CLRF   x9D
....................    tim_p3=0; 
2A02:  CLRF   xA6
2A04:  CLRF   xA5
....................    if(en_b3) { 
2A06:  MOVF   xA0,F
2A08:  BZ    2A10
....................       output_low(salida01);//apaga alarma bloqueo 
2A0A:  BCF    F94.3
2A0C:  BCF    F8B.3
....................       en_b3=0; 
2A0E:  CLRF   xA0
....................    } 
.................... } 
2A10:  BRA    2A6A
.................... else { 
....................     if(sub_cta5>=s_cta) detec5=1; 
2A12:  MOVF   x66,F
2A14:  BNZ   2A1C
2A16:  MOVF   x65,W
2A18:  SUBLW  04
2A1A:  BC    2A20
2A1C:  MOVLW  01
2A1E:  MOVWF  x6D
....................     if(sub_d5!=detec5) { 
2A20:  MOVF   x6D,W
2A22:  SUBWF  x73,W
2A24:  BZ    2A6A
....................       sub_d5=detec5; 
2A26:  MOVFF  6D,73
....................       enable3=1; 
2A2A:  MOVLW  01
2A2C:  MOVWF  x88
....................       lcd_gotoxy(5,4); 
2A2E:  MOVLW  05
2A30:  MOVLB  1
2A32:  MOVWF  x90
2A34:  MOVLW  04
2A36:  MOVWF  x91
2A38:  MOVLB  0
2A3A:  CALL   0822
....................       printf(lcd_putc,"5:%d",sub_d5); 
2A3E:  MOVLW  35
2A40:  MOVLB  1
2A42:  MOVWF  x8F
2A44:  MOVLB  0
2A46:  CALL   0874
2A4A:  MOVLW  3A
2A4C:  MOVLB  1
2A4E:  MOVWF  x8F
2A50:  MOVLB  0
2A52:  CALL   0874
2A56:  MOVFF  73,186
2A5A:  MOVLW  18
2A5C:  MOVLB  1
2A5E:  MOVWF  x87
2A60:  MOVLB  0
2A62:  CALL   106A
....................       sensando3(); 
2A66:  RCALL  24CA
....................       contando3(); 
2A68:  RCALL  2752
....................    } 
.................... } 
.................... //sensor6 
.................... ent6=input(entrada06); 
2A6A:  BSF    F93.1
2A6C:  CLRF   5A
2A6E:  BTFSC  F81.1
2A70:  INCF   5A,F
.................... if(ent6==1){ 
2A72:  DECFSZ 5A,W
2A74:  BRA    2A92
....................    output_high(salida02);// 
2A76:  BCF    F94.4
2A78:  BSF    F8B.4
....................    sub_cta6=0; 
2A7A:  CLRF   x68
2A7C:  CLRF   x67
....................    detec6=0; 
2A7E:  CLRF   x6E
....................    bloq_p3=0;//deshabilita bloqueo 
2A80:  CLRF   x9D
....................    tim_p3=0; 
2A82:  CLRF   xA6
2A84:  CLRF   xA5
....................    if(en_b3) { 
2A86:  MOVF   xA0,F
2A88:  BZ    2A90
....................       output_low(salida01);//apaga alarma bloqueo 
2A8A:  BCF    F94.3
2A8C:  BCF    F8B.3
....................       en_b3=0; 
2A8E:  CLRF   xA0
....................    } 
.................... } 
2A90:  BRA    2AF8
.................... else { 
....................    output_low(salida02);// 
2A92:  BCF    F94.4
2A94:  BCF    F8B.4
....................    if(sub_cta6>=s_cta)   detec6=1; 
2A96:  MOVF   x68,F
2A98:  BNZ   2AA0
2A9A:  MOVF   x67,W
2A9C:  SUBLW  04
2A9E:  BC    2AA4
2AA0:  MOVLW  01
2AA2:  MOVWF  x6E
....................    if(sub_d6!=detec6) { 
2AA4:  MOVF   x6E,W
2AA6:  SUBWF  x74,W
2AA8:  BZ    2AF8
....................       sub_d6=detec6; 
2AAA:  MOVFF  6E,74
....................       enable3=1; 
2AAE:  MOVLW  01
2AB0:  MOVWF  x88
....................       lcd_gotoxy(1,4); 
2AB2:  MOVLB  1
2AB4:  MOVWF  x90
2AB6:  MOVLW  04
2AB8:  MOVWF  x91
2ABA:  MOVLB  0
2ABC:  CALL   0822
....................       printf(lcd_putc,"6:%d ",sub_d6); 
2AC0:  MOVLW  36
2AC2:  MOVLB  1
2AC4:  MOVWF  x8F
2AC6:  MOVLB  0
2AC8:  CALL   0874
2ACC:  MOVLW  3A
2ACE:  MOVLB  1
2AD0:  MOVWF  x8F
2AD2:  MOVLB  0
2AD4:  CALL   0874
2AD8:  MOVFF  74,186
2ADC:  MOVLW  18
2ADE:  MOVLB  1
2AE0:  MOVWF  x87
2AE2:  MOVLB  0
2AE4:  CALL   106A
2AE8:  MOVLW  20
2AEA:  MOVLB  1
2AEC:  MOVWF  x8F
2AEE:  MOVLB  0
2AF0:  CALL   0874
....................       sensando3(); 
2AF4:  RCALL  24CA
....................       contando3(); 
2AF6:  RCALL  2752
....................    } 
.................... } 
.................... ////////////////////////// 
.................... if( (detec1==1)&&(detec2==1)&&(bloq_p1==0) ){ 
2AF8:  DECFSZ x69,W
2AFA:  BRA    2B0C
2AFC:  DECFSZ x6A,W
2AFE:  BRA    2B0C
2B00:  MOVF   x9B,F
2B02:  BNZ   2B0C
....................          bloq_p1=1; 
2B04:  MOVLW  01
2B06:  MOVWF  x9B
....................          tim_p1=0; 
2B08:  CLRF   xA2
2B0A:  CLRF   xA1
....................       } 
.................... if( (detec3==1)&&(detec4==1)&&(bloq_p2==0) ){ 
2B0C:  DECFSZ x6B,W
2B0E:  BRA    2B20
2B10:  DECFSZ x6C,W
2B12:  BRA    2B20
2B14:  MOVF   x9C,F
2B16:  BNZ   2B20
....................          bloq_p2=1; 
2B18:  MOVLW  01
2B1A:  MOVWF  x9C
....................          tim_p2=0; 
2B1C:  CLRF   xA4
2B1E:  CLRF   xA3
....................       } 
.................... if( (detec5==1)&&(detec6==1)&&(bloq_p3==0) ){ 
2B20:  DECFSZ x6D,W
2B22:  BRA    2B34
2B24:  DECFSZ x6E,W
2B26:  BRA    2B34
2B28:  MOVF   x9D,F
2B2A:  BNZ   2B34
....................          bloq_p3=1; 
2B2C:  MOVLW  01
2B2E:  MOVWF  x9D
....................          tim_p3=0; 
2B30:  CLRF   xA6
2B32:  CLRF   xA5
....................       } 
2B34:  GOTO   3330 (RETURN)
.................... }//end sensores 
....................  
.................... void sentidos(){//Define si la persona esta entrando o saliendo 
....................  if( (!sen_ent)&&(!sen_sal) ){ 
*
1D02:  MOVF   5B,F
1D04:  BNZ   1D4A
1D06:  MOVF   5C,F
1D08:  BNZ   1D4A
....................    if ( ( (detec1==1)&&(detec3==1) )|| ( (detec1==1)&&(detec5==1) )|| ( (detec3==1)&&(detec5==1) ) ) { 
1D0A:  DECFSZ x69,W
1D0C:  BRA    1D14
1D0E:  DECFSZ x6B,W
1D10:  BRA    1D14
1D12:  BRA    1D26
1D14:  DECFSZ x69,W
1D16:  BRA    1D1E
1D18:  DECFSZ x6D,W
1D1A:  BRA    1D1E
1D1C:  BRA    1D26
1D1E:  DECFSZ x6B,W
1D20:  BRA    1D2A
1D22:  DECFSZ x6D,W
1D24:  BRA    1D2A
....................       sen_ent=1; 
1D26:  MOVLW  01
1D28:  MOVWF  5B
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Sub"); 
....................    } 
....................    if ( ( (detec2==1)&&(detec4==1) )|| ( (detec2==1)&&(detec6==1) )|| ( (detec4==1)&&(detec6==1) ) ) { 
1D2A:  DECFSZ x6A,W
1D2C:  BRA    1D34
1D2E:  DECFSZ x6C,W
1D30:  BRA    1D34
1D32:  BRA    1D46
1D34:  DECFSZ x6A,W
1D36:  BRA    1D3E
1D38:  DECFSZ x6E,W
1D3A:  BRA    1D3E
1D3C:  BRA    1D46
1D3E:  DECFSZ x6C,W
1D40:  BRA    1D4A
1D42:  DECFSZ x6E,W
1D44:  BRA    1D4A
....................       sen_sal=1; 
1D46:  MOVLW  01
1D48:  MOVWF  5C
.................... //!      lcd_gotoxy(17,4); 
.................... //!      lcd_putc("Baj"); 
....................    } 
....................  } 
1D4A:  RETURN 0
.................... } 
....................  
.................... void rd_eeprom(){//Revisa si cadena recibida es un instruccion 
....................    a=b=0; 
*
0EC0:  CLRF   49
0EC2:  CLRF   48
0EC4:  MOVFF  48,44
....................    n=word_size;// 
0EC8:  CLRF   4B
0ECA:  MOVLW  0A
0ECC:  MOVWF  4A
....................    //i=0; 
....................    //i=2; 
....................    while ((b <=data_set)&&(a==0)){//NUMERO TOTAL DE INSTRUCCIONES 
0ECE:  MOVF   49,F
0ED0:  BNZ   0F66
0ED2:  MOVF   48,W
0ED4:  SUBLW  09
0ED6:  BNC   0F66
0ED8:  MOVF   44,F
0EDA:  BNZ   0F66
....................        i=0; 
0EDC:  CLRF   41
....................        b++; 
0EDE:  INCF   48,F
0EE0:  BTFSC  FD8.2
0EE2:  INCF   49,F
....................        while (i < word_size) {//word_size=10 
0EE4:  MOVF   41,W
0EE6:  SUBLW  09
0EE8:  BNC   0F5A
....................            memory[i] = read_eeprom(n+i); 
0EEA:  CLRF   03
0EEC:  MOVF   41,W
0EEE:  ADDLW  76
0EF0:  MOVWF  FE9
0EF2:  MOVLW  01
0EF4:  ADDWFC 03,W
0EF6:  MOVWF  FEA
0EF8:  MOVF   41,W
0EFA:  ADDWF  4A,W
0EFC:  MOVLB  1
0EFE:  MOVWF  x88
0F00:  MOVLW  00
0F02:  ADDWFC 4B,W
0F04:  MOVWF  x89
0F06:  MOVFF  FF2,18A
0F0A:  BCF    FF2.7
0F0C:  MOVFF  188,FA9
0F10:  BCF    FA6.6
0F12:  BCF    FA6.7
0F14:  BSF    FA6.0
0F16:  MOVF   FA8,W
0F18:  BTFSC  x8A.7
0F1A:  BSF    FF2.7
0F1C:  MOVWF  FEF
....................             
....................            if (memory[i] != XX[i]) 
0F1E:  CLRF   03
0F20:  MOVF   41,W
0F22:  ADDLW  76
0F24:  MOVWF  FE9
0F26:  MOVLW  01
0F28:  ADDWFC 03,W
0F2A:  MOVWF  FEA
0F2C:  MOVFF  FEF,186
0F30:  CLRF   03
0F32:  MOVF   41,W
0F34:  ADDLW  4E
0F36:  MOVWF  FE9
0F38:  MOVLW  01
0F3A:  ADDWFC 03,W
0F3C:  MOVWF  FEA
0F3E:  MOVF   FEF,W
0F40:  SUBWF  x86,W
0F42:  BZ    0F4A
....................                break; 
0F44:  MOVLB  0
0F46:  BRA    0F5A
0F48:  MOVLB  1
....................            i++; 
0F4A:  INCF   41,F
....................            if (i==word_size) a=1; 
0F4C:  MOVF   41,W
0F4E:  SUBLW  0A
0F50:  BNZ   0F56
0F52:  MOVLW  01
0F54:  MOVWF  44
0F56:  MOVLB  0
0F58:  BRA    0EE4
....................        } 
....................        //fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
0F5A:  MOVLW  0A
0F5C:  ADDWF  4A,F
0F5E:  MOVLW  00
0F60:  ADDWFC 4B,F
....................        restart_wdt(); 
0F62:  CLRWDT
0F64:  BRA    0ECE
....................    } 
0F66:  GOTO   2F68 (RETURN)
.................... } 
....................  
.................... void rd_eeprom_inicio(){// 
....................    a=b=0; 
....................    n=word_size;// 
....................     
....................    while (b <=data_set){//NUMERO TOTAL DE INSTRUCCIONES 
....................        i=0; 
....................        b++; 
....................        while (i < word_size) {//word_size=10 
....................            memory[i] = read_eeprom(n+i); 
....................            i++; 
....................            if (i==word_size) a=1; 
....................        } 
....................        fprintf(monitor,"memory:%s\r",memory); 
....................        n=n+word_size;//WORD_SIZE=30 
....................        //restart_wdt(); 
....................    } 
.................... } 
....................  
.................... /* 
.................... void llaves(){//Graba las instrucciones de control en eeprom 
.................... int tem; 
.................... ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
....................       switch (tem) { 
....................         case 1:{for (i=0;i<word_size;++i)  texto[i]=texto1[i]; 
....................               break;} 
....................         case 2:{for (i=0;i<word_size;++i)  texto[i]=texto2[i]; 
....................               break;} 
....................         case 3:{for (i=0;i<word_size;++i)  texto[i]=texto3[i]; 
....................               break;} 
....................         case 4:{for (i=0;i<word_size;++i)  texto[i]=texto4[i]; 
....................               break;} 
....................         case 5:{for (i=0;i<word_size;++i)  texto[i]=texto5[i]; 
....................               break;} 
....................         case 6:{for (i=0;i<word_size;++i)  texto[i]=texto6[i]; 
....................               break;} 
....................         case 7:{for (i=0;i<word_size;++i)  texto[i]=texto7[i]; 
....................               break;} 
....................         case 8:{for (i=0;i<word_size;++i)  texto[i]=texto8[i]; 
....................               break;} 
....................         case 9:{for (i=0;i<word_size;++i)  texto[i]=texto9[i]; 
....................               break;} 
....................       } 
....................       a=i=0; 
....................       while (i < word_size) {  //word_size=8 
....................               memory[i] = read_eeprom((tem*word_size)+i); 
....................               fprintf(monitor,"tx[]:%s",texto); 
....................               if (memory[i] != texto[i]){ 
....................              // fprintf(monitor,"es diferente."); 
....................               break; 
....................               } 
....................               i++; 
....................               if (i==word_size){ 
....................              // fprintf(monitor,"a=1"); 
....................               a=1; 
....................               } 
....................       } 
....................       if (a==0){ 
....................          i=0; 
....................          fprintf(monitor,"e."); 
....................         // fprintf(monitor,"texto[]:%s",texto); 
....................          while (texto[i] != 0x00){ 
....................             write_eeprom(i+(tem*word_size),texto[i]); 
....................             i++; 
....................          } 
....................       } 
....................    }//end for 
.................... } 
.................... */ 
....................  
.................... void lcd_cuentas(){//Escribe las cuenta en LCD  
....................     lcd_gotoxy(1,1); 
*
0A18:  MOVLW  01
0A1A:  MOVLB  1
0A1C:  MOVWF  x90
0A1E:  MOVWF  x91
0A20:  MOVLB  0
0A22:  RCALL  0822
....................     if(master) { 
0A24:  MOVF   45,F
0A26:  BTFSC  FD8.2
0A28:  BRA    0B48
....................        printf(lcd_putc,"1 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0A2A:  MOVLW  31
0A2C:  MOVLB  1
0A2E:  MOVWF  x8F
0A30:  MOVLB  0
0A32:  RCALL  0874
0A34:  MOVLW  20
0A36:  MOVLB  1
0A38:  MOVWF  x8F
0A3A:  MOVLB  0
0A3C:  RCALL  0874
0A3E:  MOVFF  148,18F
0A42:  RCALL  0874
0A44:  MOVFF  149,18F
0A48:  RCALL  0874
0A4A:  MOVFF  14A,18F
0A4E:  RCALL  0874
0A50:  MOVFF  14B,18F
0A54:  RCALL  0874
0A56:  MOVFF  14C,18F
0A5A:  RCALL  0874
0A5C:  MOVLW  20
0A5E:  MOVLB  1
0A60:  MOVWF  x8F
0A62:  MOVLB  0
0A64:  RCALL  0874
....................        lcd_gotoxy(14,1); 
0A66:  MOVLW  0E
0A68:  MOVLB  1
0A6A:  MOVWF  x90
0A6C:  MOVLW  01
0A6E:  MOVWF  x91
0A70:  MOVLB  0
0A72:  RCALL  0822
....................        printf(lcd_putc,"S1:%Ld ",entraront); 
0A74:  MOVLW  70
0A76:  MOVWF  FF6
0A78:  MOVLW  03
0A7A:  MOVWF  FF7
0A7C:  MOVLW  03
0A7E:  MOVLB  1
0A80:  MOVWF  x86
0A82:  MOVLB  0
0A84:  RCALL  08D4
0A86:  MOVLW  10
0A88:  MOVWF  FE9
0A8A:  MOVFF  8B,187
0A8E:  MOVFF  8A,186
0A92:  RCALL  08FC
0A94:  MOVLW  20
0A96:  MOVLB  1
0A98:  MOVWF  x8F
0A9A:  MOVLB  0
0A9C:  RCALL  0874
....................        lcd_gotoxy(14,2); 
0A9E:  MOVLW  0E
0AA0:  MOVLB  1
0AA2:  MOVWF  x90
0AA4:  MOVLW  02
0AA6:  MOVWF  x91
0AA8:  MOVLB  0
0AAA:  RCALL  0822
....................        printf(lcd_putc,"B1:%Ld ",salieront); 
0AAC:  MOVLW  78
0AAE:  MOVWF  FF6
0AB0:  MOVLW  03
0AB2:  MOVWF  FF7
0AB4:  MOVLW  03
0AB6:  MOVLB  1
0AB8:  MOVWF  x86
0ABA:  MOVLB  0
0ABC:  RCALL  08D4
0ABE:  MOVLW  10
0AC0:  MOVWF  FE9
0AC2:  MOVFF  8D,187
0AC6:  MOVFF  8C,186
0ACA:  RCALL  08FC
0ACC:  MOVLW  20
0ACE:  MOVLB  1
0AD0:  MOVWF  x8F
0AD2:  MOVLB  0
0AD4:  RCALL  0874
....................        lcd_gotoxy(14,3); 
0AD6:  MOVLW  0E
0AD8:  MOVLB  1
0ADA:  MOVWF  x90
0ADC:  MOVLW  03
0ADE:  MOVWF  x91
0AE0:  MOVLB  0
0AE2:  RCALL  0822
....................        printf(lcd_putc,"S2:%Ld ",sub_atras); 
0AE4:  MOVLW  80
0AE6:  MOVWF  FF6
0AE8:  MOVLW  03
0AEA:  MOVWF  FF7
0AEC:  MOVLW  03
0AEE:  MOVLB  1
0AF0:  MOVWF  x86
0AF2:  MOVLB  0
0AF4:  RCALL  08D4
0AF6:  MOVLW  10
0AF8:  MOVWF  FE9
0AFA:  MOVFF  35,187
0AFE:  MOVFF  34,186
0B02:  RCALL  08FC
0B04:  MOVLW  20
0B06:  MOVLB  1
0B08:  MOVWF  x8F
0B0A:  MOVLB  0
0B0C:  RCALL  0874
....................        lcd_gotoxy(14,4); 
0B0E:  MOVLW  0E
0B10:  MOVLB  1
0B12:  MOVWF  x90
0B14:  MOVLW  04
0B16:  MOVWF  x91
0B18:  MOVLB  0
0B1A:  RCALL  0822
....................        printf(lcd_putc,"B2:%Ld ",baj_atras); 
0B1C:  MOVLW  88
0B1E:  MOVWF  FF6
0B20:  MOVLW  03
0B22:  MOVWF  FF7
0B24:  MOVLW  03
0B26:  MOVLB  1
0B28:  MOVWF  x86
0B2A:  MOVLB  0
0B2C:  RCALL  08D4
0B2E:  MOVLW  10
0B30:  MOVWF  FE9
0B32:  MOVFF  37,187
0B36:  MOVFF  36,186
0B3A:  RCALL  08FC
0B3C:  MOVLW  20
0B3E:  MOVLB  1
0B40:  MOVWF  x8F
0B42:  MOVLB  0
0B44:  RCALL  0874
....................     } 
0B46:  BRA    0C24
....................     else{ 
....................        printf(lcd_putc,"2 %c%c%c%c%c ",version[0],version[1],version[2],version[3],version[4]); 
0B48:  MOVLW  32
0B4A:  MOVLB  1
0B4C:  MOVWF  x8F
0B4E:  MOVLB  0
0B50:  RCALL  0874
0B52:  MOVLW  20
0B54:  MOVLB  1
0B56:  MOVWF  x8F
0B58:  MOVLB  0
0B5A:  RCALL  0874
0B5C:  MOVFF  148,18F
0B60:  RCALL  0874
0B62:  MOVFF  149,18F
0B66:  RCALL  0874
0B68:  MOVFF  14A,18F
0B6C:  RCALL  0874
0B6E:  MOVFF  14B,18F
0B72:  RCALL  0874
0B74:  MOVFF  14C,18F
0B78:  RCALL  0874
0B7A:  MOVLW  20
0B7C:  MOVLB  1
0B7E:  MOVWF  x8F
0B80:  MOVLB  0
0B82:  RCALL  0874
....................        lcd_gotoxy(14,1); 
0B84:  MOVLW  0E
0B86:  MOVLB  1
0B88:  MOVWF  x90
0B8A:  MOVLW  01
0B8C:  MOVWF  x91
0B8E:  MOVLB  0
0B90:  RCALL  0822
....................        lcd_putc("S1:    "); 
0B92:  MOVLW  90
0B94:  MOVWF  FF6
0B96:  MOVLW  03
0B98:  MOVWF  FF7
0B9A:  RCALL  09F8
....................        lcd_gotoxy(14,2); 
0B9C:  MOVLW  0E
0B9E:  MOVLB  1
0BA0:  MOVWF  x90
0BA2:  MOVLW  02
0BA4:  MOVWF  x91
0BA6:  MOVLB  0
0BA8:  RCALL  0822
....................        lcd_putc("B1:    "); 
0BAA:  MOVLW  98
0BAC:  MOVWF  FF6
0BAE:  MOVLW  03
0BB0:  MOVWF  FF7
0BB2:  RCALL  09F8
....................        lcd_gotoxy(14,3); 
0BB4:  MOVLW  0E
0BB6:  MOVLB  1
0BB8:  MOVWF  x90
0BBA:  MOVLW  03
0BBC:  MOVWF  x91
0BBE:  MOVLB  0
0BC0:  RCALL  0822
....................        printf(lcd_putc,"S2:%Ld ",entraront); 
0BC2:  MOVLW  A0
0BC4:  MOVWF  FF6
0BC6:  MOVLW  03
0BC8:  MOVWF  FF7
0BCA:  MOVLW  03
0BCC:  MOVLB  1
0BCE:  MOVWF  x86
0BD0:  MOVLB  0
0BD2:  RCALL  08D4
0BD4:  MOVLW  10
0BD6:  MOVWF  FE9
0BD8:  MOVFF  8B,187
0BDC:  MOVFF  8A,186
0BE0:  RCALL  08FC
0BE2:  MOVLW  20
0BE4:  MOVLB  1
0BE6:  MOVWF  x8F
0BE8:  MOVLB  0
0BEA:  RCALL  0874
....................        lcd_gotoxy(14,4); 
0BEC:  MOVLW  0E
0BEE:  MOVLB  1
0BF0:  MOVWF  x90
0BF2:  MOVLW  04
0BF4:  MOVWF  x91
0BF6:  MOVLB  0
0BF8:  RCALL  0822
....................        printf(lcd_putc,"B2:%Ld ",salieront); 
0BFA:  MOVLW  A8
0BFC:  MOVWF  FF6
0BFE:  MOVLW  03
0C00:  MOVWF  FF7
0C02:  MOVLW  03
0C04:  MOVLB  1
0C06:  MOVWF  x86
0C08:  MOVLB  0
0C0A:  RCALL  08D4
0C0C:  MOVLW  10
0C0E:  MOVWF  FE9
0C10:  MOVFF  8D,187
0C14:  MOVFF  8C,186
0C18:  RCALL  08FC
0C1A:  MOVLW  20
0C1C:  MOVLB  1
0C1E:  MOVWF  x8F
0C20:  MOVLB  0
0C22:  RCALL  0874
....................     } 
0C24:  RETURN 0
....................      
.................... } 
....................  
.................... void write_ent(){//Graba en eeprom las subidas del poste 
....................    disable_interrupts(GLOBAL); 
*
0C64:  BCF    FF2.6
0C66:  BCF    FF2.7
0C68:  BTFSC  FF2.7
0C6A:  BRA    0C66
....................    write_ext_eeprom(2,entraront);//parte baja 
0C6C:  MOVLB  1
0C6E:  CLRF   x8B
0C70:  MOVLW  02
0C72:  MOVWF  x8A
0C74:  MOVFF  8A,18C
0C78:  MOVLB  0
0C7A:  RCALL  0568
....................    write_ext_eeprom(1,(entraront>>8) );//parte alta 
0C7C:  MOVFF  8B,186
0C80:  MOVLB  1
0C82:  CLRF   x87
0C84:  CLRF   x8B
0C86:  MOVLW  01
0C88:  MOVWF  x8A
0C8A:  MOVFF  8B,18C
0C8E:  MOVLB  0
0C90:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
0C92:  MOVLW  C0
0C94:  IORWF  FF2,F
....................    finsuma(); 
0C96:  RCALL  0C26
0C98:  RETURN 0
.................... } 
....................  
.................... void write_sal(){//Graba en eeprom las bajadas del poste 
....................    disable_interrupts(GLOBAL); 
0C9A:  BCF    FF2.6
0C9C:  BCF    FF2.7
0C9E:  BTFSC  FF2.7
0CA0:  BRA    0C9C
....................    write_ext_eeprom(4,salieront);//parte baja 
0CA2:  MOVLB  1
0CA4:  CLRF   x8B
0CA6:  MOVLW  04
0CA8:  MOVWF  x8A
0CAA:  MOVFF  8C,18C
0CAE:  MOVLB  0
0CB0:  RCALL  0568
....................    write_ext_eeprom(3,(salieront>>8) );//parte alta 
0CB2:  MOVFF  8D,186
0CB6:  MOVLB  1
0CB8:  CLRF   x87
0CBA:  CLRF   x8B
0CBC:  MOVLW  03
0CBE:  MOVWF  x8A
0CC0:  MOVFF  8D,18C
0CC4:  MOVLB  0
0CC6:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
0CC8:  MOVLW  C0
0CCA:  IORWF  FF2,F
....................    finsuma(); 
0CCC:  RCALL  0C26
0CCE:  RETURN 0
.................... } 
....................  
.................... void entraron_total(){//Graba en eeprom el total de subidas 
....................    disable_interrupts(GLOBAL); 
*
0D3C:  BCF    FF2.6
0D3E:  BCF    FF2.7
0D40:  BTFSC  FF2.7
0D42:  BRA    0D3E
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0D44:  MOVLB  1
0D46:  CLRF   x86
0D48:  CLRF   x87
0D4A:  CLRF   x89
0D4C:  CLRF   x88
....................     
....................    reg_h=read_ext_eeprom(1); 
0D4E:  CLRF   x8B
0D50:  MOVLW  01
0D52:  MOVWF  x8A
0D54:  MOVLB  0
0D56:  RCALL  0728
0D58:  MOVFF  01,186
....................    reg_l=read_ext_eeprom(2); 
0D5C:  MOVLB  1
0D5E:  CLRF   x8B
0D60:  MOVLW  02
0D62:  MOVWF  x8A
0D64:  MOVLB  0
0D66:  RCALL  0728
0D68:  MOVFF  01,187
....................    total=reg_h; 
0D6C:  MOVLB  1
0D6E:  CLRF   x89
0D70:  MOVFF  186,188
....................    total=(total<<8)|reg_l; 
0D74:  MOVFF  188,18B
0D78:  CLRF   x8A
0D7A:  MOVF   x8A,W
0D7C:  IORWF  x87,W
0D7E:  MOVWF  x88
0D80:  MOVFF  18B,189
....................    entraront=total; 
0D84:  MOVFF  189,8B
0D88:  MOVFF  188,8A
....................    enable_interrupts(GLOBAL); 
0D8C:  MOVLW  C0
0D8E:  IORWF  FF2,F
0D90:  MOVLB  0
0D92:  GOTO   2D84 (RETURN)
.................... } 
....................  
.................... void salieron_total(){//Graba en eeprom el total de bajadas 
....................    disable_interrupts(GLOBAL); 
0D96:  BCF    FF2.6
0D98:  BCF    FF2.7
0D9A:  BTFSC  FF2.7
0D9C:  BRA    0D98
....................    unsigned int reg_h=0,reg_l=0; 
....................    unsigned int16 total=0; 
0D9E:  MOVLB  1
0DA0:  CLRF   x86
0DA2:  CLRF   x87
0DA4:  CLRF   x89
0DA6:  CLRF   x88
....................     
....................    reg_h=read_ext_eeprom(3); 
0DA8:  CLRF   x8B
0DAA:  MOVLW  03
0DAC:  MOVWF  x8A
0DAE:  MOVLB  0
0DB0:  RCALL  0728
0DB2:  MOVFF  01,186
....................    reg_l=read_ext_eeprom(4); 
0DB6:  MOVLB  1
0DB8:  CLRF   x8B
0DBA:  MOVLW  04
0DBC:  MOVWF  x8A
0DBE:  MOVLB  0
0DC0:  RCALL  0728
0DC2:  MOVFF  01,187
....................    total=reg_h; 
0DC6:  MOVLB  1
0DC8:  CLRF   x89
0DCA:  MOVFF  186,188
....................    total=(total<<8)|reg_l; 
0DCE:  MOVFF  188,18B
0DD2:  CLRF   x8A
0DD4:  MOVF   x8A,W
0DD6:  IORWF  x87,W
0DD8:  MOVWF  x88
0DDA:  MOVFF  18B,189
....................    salieront=total; 
0DDE:  MOVFF  189,8D
0DE2:  MOVFF  188,8C
....................    enable_interrupts(GLOBAL); 
0DE6:  MOVLW  C0
0DE8:  IORWF  FF2,F
0DEA:  MOVLB  0
0DEC:  GOTO   2D88 (RETURN)
.................... } 
....................  
.................... void graba_conta2(){//Graba en eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
066E:  BCF    FF2.6
0670:  BCF    FF2.7
0672:  BTFSC  FF2.7
0674:  BRA    0670
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
0676:  MOVLB  1
0678:  CLRF   x86
067A:  CLRF   x87
067C:  CLRF   x89
067E:  CLRF   x88
....................    totalc=0; 
0680:  CLRF   x89
0682:  CLRF   x88
....................    reg_lc=0; 
0684:  CLRF   x87
....................    reg_hc=0; 
0686:  CLRF   x86
....................     
....................    totalc=salian; 
0688:  MOVFF  3D,189
068C:  MOVFF  3C,188
....................    reg_lc=totalc; 
0690:  MOVFF  188,187
....................    reg_hc=totalc>>8; 
0694:  MOVFF  189,186
....................    write_ext_eeprom(20,reg_hc); 
0698:  CLRF   x8B
069A:  MOVLW  14
069C:  MOVWF  x8A
069E:  MOVFF  186,18C
06A2:  MOVLB  0
06A4:  RCALL  0568
....................    write_ext_eeprom(21,reg_lc); 
06A6:  MOVLB  1
06A8:  CLRF   x8B
06AA:  MOVLW  15
06AC:  MOVWF  x8A
06AE:  MOVFF  187,18C
06B2:  MOVLB  0
06B4:  RCALL  0568
....................    enable_interrupts(GLOBAL); 
06B6:  MOVLW  C0
06B8:  IORWF  FF2,F
06BA:  RETURN 0
.................... } 
....................  
.................... void leer_conta2(){//Carga de eeprom el total de pasajes de poste esclavo 
....................    disable_interrupts(GLOBAL); 
*
07D0:  BCF    FF2.6
07D2:  BCF    FF2.7
07D4:  BTFSC  FF2.7
07D6:  BRA    07D2
....................    unsigned int reg_hc=0,reg_lc=0; 
....................    unsigned int16 totalc=0; 
07D8:  MOVLB  1
07DA:  CLRF   x86
07DC:  CLRF   x87
07DE:  CLRF   x89
07E0:  CLRF   x88
....................     
....................    reg_hc=read_ext_eeprom(20); 
07E2:  CLRF   x8B
07E4:  MOVLW  14
07E6:  MOVWF  x8A
07E8:  MOVLB  0
07EA:  RCALL  0728
07EC:  MOVFF  01,186
....................    reg_lc=read_ext_eeprom(21); 
07F0:  MOVLB  1
07F2:  CLRF   x8B
07F4:  MOVLW  15
07F6:  MOVWF  x8A
07F8:  MOVLB  0
07FA:  RCALL  0728
07FC:  MOVFF  01,187
....................    totalc=reg_hc; 
0800:  MOVLB  1
0802:  CLRF   x89
0804:  MOVFF  186,188
....................    totalc=totalc<<8; 
0808:  MOVFF  188,189
080C:  CLRF   x88
....................    totalc=totalc|reg_lc; 
080E:  MOVF   x87,W
0810:  IORWF  x88,F
....................    salian=totalc; 
0812:  MOVFF  189,3D
0816:  MOVFF  188,3C
....................    enable_interrupts(GLOBAL); 
081A:  MOVLW  C0
081C:  IORWF  FF2,F
081E:  MOVLB  0
0820:  RETURN 0
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) { 
*
0E12:  MOVF   FD0,W
0E14:  ANDLW  0F
0E16:  BTFSS  FD0.4
0E18:  MOVLW  00
0E1A:  BSF    FD0.0
0E1C:  BSF    FD0.1
0E1E:  BSF    FD0.4
0E20:  BSF    FD8.3
0E22:  BSF    FD8.4
0E24:  XORLW  07
0E26:  BZ    0E36
0E28:  XORLW  08
0E2A:  BZ    0E38
0E2C:  XORLW  01
0E2E:  BZ    0E44
0E30:  XORLW  02
0E32:  BZ    0E46
0E34:  BRA    0E46
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          break;} 
0E36:  BRA    0E46
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          fprintf(monitor,"SERIALTEST\r\n"); 
0E38:  MOVLW  B0
0E3A:  MOVWF  FF6
0E3C:  MOVLW  03
0E3E:  MOVWF  FF7
0E40:  RCALL  0DF0
....................          //fprintf(monitor,"0\r"); 
....................          break;} 
0E42:  BRA    0E46
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          break; 
0E44:  BRA    0E46
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          break; 
....................       }//END MODO 
....................    } 
0E46:  GOTO   2E66 (RETURN)
.................... } 
....................  
....................  
.................... int evaluar_string(char *command[]){ 
*
0FE4:  MOVLB  1
0FE6:  CLRF   x88
....................   // fprintf(monitor,"<"); 
....................    //fprintf(monitor,"%s",command); 
....................   // fprintf(monitor,">"); 
....................    int conteo_command=0; 
....................    int iresult; 
....................    while(conteo_command<=10){ 
0FE8:  MOVF   x88,W
0FEA:  SUBLW  0A
0FEC:  BNC   1034
....................   // lcd_gotoxy(9,4); 
....................   // printf(lcd_putc,":%s",command);//pinta en lcd si el numero de caso detectado (9 significa que no es un dato valido) 
....................    iresult=strcoll(textosearch[conteo_command],command); 
0FEE:  CLRF   03
0FF0:  MOVFF  188,02
0FF4:  BCF    FD8.0
0FF6:  RLCF   02,F
0FF8:  RLCF   03,F
0FFA:  MOVF   02,W
0FFC:  ADDLW  AE
0FFE:  MOVWF  FE9
1000:  MOVLW  00
1002:  ADDWFC 03,W
1004:  MOVWF  FEA
1006:  MOVFF  FEC,18B
100A:  MOVF   FED,F
100C:  MOVFF  FEF,18A
1010:  MOVFF  18B,18D
1014:  MOVFF  18A,18C
1018:  MOVFF  187,18F
101C:  MOVFF  186,18E
1020:  MOVLB  0
1022:  BRA    0F6A
1024:  MOVFF  01,189
....................   // fprintf(monitor,"%d",iresult); 
....................   // fprintf(monitor,"%s",textosearch[conteo_command]); 
....................    if(iresult==0){ 
1028:  MOVLB  1
102A:  MOVF   x89,F
102C:  BNZ   1030
....................   // fprintf(monitor,"Encontrado"); 
....................    //return (conteo_command); 
....................    break; 
102E:  BRA    1034
....................    } 
....................    //if(conteo_command==5){ 
....................       
....................  
....................    //} 
....................    
....................    conteo_command++; 
1030:  INCF   x88,F
1032:  BRA    0FE8
....................    } 
....................      
....................    return conteo_command; 
1034:  MOVFF  188,01
1038:  MOVLB  0
103A:  GOTO   2F78 (RETURN)
....................  
....................    } 
....................     

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 181E   PUT BROWNOUT BORV21 NOWDT WDT4096
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
